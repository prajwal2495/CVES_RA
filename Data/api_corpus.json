[{"id":912,"cve":"CVE-2013-6665","project_name":"chromium","description":"Heap-based buffer overflow in Chrome's resource provider in Google Chrome that\nhandles bitmap textures. The vulnerability allows remote attackers to cause a\ndenial of service or possibly have unspecified other impact via a large bitmap\ntexture size that triggers improper memory allocation in the software\nrenderer.\n\nThe fix for this vulnerability is to place a hard limit on the number of bytes\nthat can be allocated in a specific situation, regardless of different kinds\nof hardware.\n","mistakes":"The vulnerabliity here was a pretty simple oversight in terms of limiting resource constraints. The code would have handled a massive amounts of memory allocation differently on different pieces of hardware, leading to a buffer overflow in some situations. They didn't think of this early on. But, the way they fixed it was to hardcode a reasonable limit into the code.\nThe use of a magic number without a constant still seems fishy to me, but it's very good that they considered this situation and rectified it.\nInterestingly, they did not trust the fuzzer on this initially."},{"id":1457,"cve":"CVE-2017-5093","project_name":"chromium","description":"UI spoofing in Blink, a browser engine used in the Google Chrome browser. This\nvulnerability makes it possible to display a popup dialog in front of the\nFullscreen permission dialog, making it \"impossible\" to the user to know he/she\nentered fullscreen mode, enabling the attacker to subvert the true identity\nof the URL.\n","mistakes":"In my opinion, there were coding and design mistakes due to overlooking a\npotential use of incorrectly validated inputs to manipulate modals and the\nfullscreen feature. The fix looks proper as it involved additional tests,\ndeletion of previous code, additional checks for input validation, and the\nexiting of web-page initiated fullscreen when a dialog runs. It is interesting\nhow even developers at top tech companies overlook validating input and serves\nas a prime example to always make sure to validate input, as it may violate\nthe users' confidentality.\n"},{"id":1471,"cve":"CVE-2017-5107","project_name":"chromium","description":"User information leak via SVG. By rendering a FeConvolveMatrix SVG filter over\na target iframe and timing its execution an attacking page can extract pixel\nvalues from a cross-origin page being iframe'd.\n","mistakes":null},{"id":1425,"cve":"CVE-2017-5060","project_name":"chromium","description":"URL spoofing in Omnibox. Certain Cyrillic characters look incredibly similar\nto standard Roman Alphabet characters, so much so that certain fonts don't\ndistinguish between the two. Registering a domain with \"punycode\" escape\nsequences causes these characters to display in the browser.\n","mistakes":null},{"id":957,"cve":"CVE-2014-1748","project_name":"chromium","description":"The scrollbar rectangles for images were not properly being clipped to the the\nparent document that they interacted with (owning viewport). This non-limiting \neffect allowed for chiled documents to draw/cover over the respective parent\ndocuments by passing extremely large dimensions to for the scrollbar elements.\nAn attacker could use this by creating a transparent child document that covered \nthe parent. This could allow the attacker to spoof content or cause the \nuser to click on malicious links.\n","mistakes":"The main mistake that was made here was less of a mistake and more of an \noversight. The vulnerability was introduced when ScrollView::paint() needed\nto be clipped by the visible content (visibleContentRect), but it was never\nchecked that the scrollbar was also clipped as well, leading to an inconsistency\nbetween the two parts of the feature.\n\nThis was most likely missed due to the issue being with extremely large dimensions\nbeing specified for the elements. It is unclear how big these must have been to \ntrigger the vulnerability, so to originally test it would have probably needed to be \nthrough manual (or possibly fuzzer) investigation. Tests were added specifically\nto check for this issue when the code was fixed in order to prevent the same issue\npopping up again.\n\nThe fix here appears to be a proper fix, as the scrollbar is now properly clipped\nto the same size as the rect mentioned above.\n"},{"id":1128,"cve":"CVE-2015-1296","project_name":"chromium","description":"You could place special unicode characters in the URL so that a padlock character would be displayed at the beginning of the URL which could fool the user into thinking that they had a secure connection over HTTPS. Attackers could post links anywhere on the web that include these special characters so when people click on them and see the padlock icon they'd think that they're safe. The padlock icon verifies that the server is in fact who they claim to be. If you go on Facebook.com and see the padlock then it verifies that there isn't a third party impersonating Facebook. They could hide them with a hyperlink so that the characters don't appear in the link visible to the user, but when they click on it the web browser would copy it to the omnibox and display the padlock character. The omnibox is the address bar in chrome, they just call in the omnibox internally.","mistakes":"This issue happened at the Requirements phase. They should have considered\nall of the complex unicode inputs that people could use to attempt to spoof\nURLs. In order for this type of vulnerability to be caught they would have \nneeded to have someone who is very familiar with unicode to be on the team.\nThis person would have to know about the padlock character and know that \nthere are RTL characters that can be used to move characters to appear at\nthe beginning of the string. Throughout all of development no one must have\nthought of an attack like this. It's a really complex input so it's \nunderstandable that they never considered it originally though. They couldn't\nremove all unicode characters though because people who speak languages whose\nalphabet doesn't fit in ASCII need to be able to search for things with the\nomnibox.\n"},{"id":1334,"cve":"CVE-2016-5157","project_name":"chromium","description":"A Heap Buffer Overflow (out-of-bounds write) vulnerability was found in OpenJPEG, which is used in PDFium in Google Chrome. This would allow a remote attacker to arbitrarily execute code on a user's machine. After inspecting the code, it seemed that the vulnerability was due to casting arguments for method to a 32 byte integer, which could possibly cause the integer to exceed the boundaries. OpenJPEG is an open source library used to display JPEG images; this was a dependency in PDFium, which is an open source library which Google maintains. This is used to display PDF files through Google Chrome.\nThis bug in OpenJPEG was brought forth through a developer of the open source library attempting to close another Heap Buffer Overflow bug. I think that this vulnerability could have been stopped in its tracks if there had been unit tests for this section of code, as there are no unit tests in OpenJPEG.","mistakes":"The coding mistake that lead to this vulnerability was that the developer who\nimplemented this section of code had thought of the possibility of overflow, and\nthe very next commit provided checks to ensure that overflow couldn't happen before\nas these variables were being assigned, but they didn't think about the possibility\nthat after casting the variables could possibly cause overflow later.\n\nThe vulernability was introduced as the developer was attempting to fix another overflow bug\nwhich also had to do with casting. It seems like an oversight of the developer to not think\nthey had to recheck the output of these variables."},{"id":1154,"cve":"CVE-2015-6583","project_name":"chromium","description":"Google Chrome's browser does not display a location bar for hosted apps that\nnavigate away from an installation site. For example, when you install an app\nfrom Google Chrome's web store, launch the app open in a new window, and the\nlocation bar would disappear. This may make it easier for remote attackers to\nspoof content via a specially crafted app. Therefore, this will allow an\nattacker to perform a phishing attack and steal user's credentials.\n","mistakes":"This vulnerability appears to be introduced due to a coding and design\nmistake. The coding and design mistake made here was the location bar should\nhave been properly handled when navigating away into a new window. Also,\nthere may have been a requirements issue here as well due to the way a\nhosted app was initially defined as a bookmark app. The fix changed how\nthe browser handled the visibility of the location bar and how the hosted\napp was treated in the system. The fix corrects the unexpected behavior of\nthe location bar disappearing and validates the hosted app can be trusted.\n"},{"id":1231,"cve":"CVE-2016-1645","project_name":"chromium","description":"Attackers could write the metadata for an image, or the information that makes up the image, in such a way that when  it was read in certain programs or \ntools, it had the potential to create Denial of Service attacks which would crash applications or machines. Google used this library to interpret and render the images inside of PDF for viewing,\nin addition to getting the metadata for things like image tags for describing the photos, and alt-text for screen-readers and accessibility settings.  \nThe crash was caused by incorrectly converting integers to other types or from negative-to-positive, and would result in \"integer signdness errors\". \nThese errors could lead to out-of-bounds index writing, where the attacker could inject or execute code where they're not supposed to be able to, or number casting\nerrors, which could violate the integrity of the data. \nThis vulnerability was a problem for its potential to affect the Availability of systems and the integrity of the data. \nThe solution was to upgrade to r3002 of OpenJPEG, which based on intuition and reasoning, added checks for the data to ensure it did not run over. \n","mistakes":"There was a combination of design mistakes, coding mistakes, and either laziness or constraints.\n\nFirst, the team did not account for buffer overflows when they originally coded the method. This could have been avoided with \ninput sanitization, and checking the input to handle any potential out-of-bounds problems. \n\nOn top of failing to handle the problem originally, they did not write any unit tests to attempt to catch the problem before it happened. \nIt is possible that even with unit testing, they could not have caught this, but no tests were written period. Not at the VCC, and not at the fix.\nThere were 4-5 commits between the VCC and the fix, which would make it seem like writing test cases would be a good idea, as so many others had failed to fix \nit previously. \n\nIf the team had set up the method in such a way that it validated inputs and properly handled or expected buffer overflows, then this problem might have been avoided\nfrom the start. I am sure there were some difficulties though, as it appears that OpenJPEG is just a library that Chromium uses, so they were not necessarily testing\nor intending its use for the things that Google eventually utilized it for\n      \n"},{"id":905,"cve":"CVE-2013-6657","project_name":"chromium","description":"The code that was used to check for possible XSS attacks replaced blocked form elements with a blank internal page. Remote attackers could take advantage of this to bypass Same Origin Policy and instead force sensitive data to be submitted to the blank page, checking character-by-character which requests got blocked to determine the data's value through brute force.","mistakes":"The mistake made was most likely a case of not being able to anticipate every possible\nvulnerability. There were multiple commits stating that usage of the internal blank page\nwas safe (ie, not vulnerable to XSS) over a span of several years and by a few different people.\nPerhaps more familiarity with the specific implementation of the page could have prevented this\nbut ultimately, developers can't learn everything about everything or nothing would get done. Code\nreviews by different people may help.\n"},{"id":137,"cve":"CVE-2010-3248","project_name":"chromium","description":"A bug was found in chrome which did not retrict javascript from copying to the\nclipboard from any context ( anywhere you can run JavaScript). The person who found the vulnerability,\nwrote an exploit that would hijack the clipboard and constantly set the clipboard to\na malicious url.\n\nHere's how his exploit works. First, you start off by creating an invisible iframe element\nin the background and turning the design-mode/content-editable on. This gives the iframe\naccess to the \"execCommand\" in JS, which has a \"copy\" function which copies the current\nselected content to the clipboard. The attacker can take advantage of this by adding and setting\na text element inside the iframe to a malicious url and then calling the focus(), select()\nand finally the execCommand()'s copy function to copy to the clipboard. In his exploit,\nhe used setTimeout() to make an infinite recursive call on a function which would copy\nhis malicious url to the clipboard every 500ms.\n\nHere's a link to the custom exploit: https://bugs.chromium.org/p/chromium/issues/attachmentText?aid=118061\n","mistakes":"This bug was not present in Opera or Firefox, so it was a reasonable assumption that\nsomeone couldn't access the clipboard outside dedicated clipboard events. This is one\nof those important but very obscure vulnerabilities that are hard to actively defend against.\nThe only way to prevent these kind of vulnerabilities, would to be paranoid about every feature\nand have unit tests out the whazoo. While testing your code into the ground is a good way to\nensure it's safety, I'd say it wouldn't be economical ( or sane ) to write software like this.\n"},{"id":398,"cve":"CVE-2011-2850","project_name":"chromium","description":"Khmer characters were causing an out of bound error when being read. This out of bound \nerror was even being caused by a file made up of just one Khmer character. Khmer is not \na technical for certain characters, Khmer is actually the official language of Cambodia.\n\nAn attack taking advantage of this vulnerability would have remote attackers utilizing unspecified vectors \nto upload Khmer characters that would cause an out of bound error leading to denial of service.\n\nThe issue itself cropped up in the library they were using from Harfbuzz. Harfbuzz is used to convert unicode text to glyphs.\n","mistakes":"This seems like an issue that could have been caught earlier with improved testing. Harfbuzz itself \ncontains tests against a list of languages, Khmer originally not being one of them. Additionally, while \nit was eventually caught by their fuzzer, it existed for almost a year before a person or the fuzzer \ncaught this. With properly bounding unit tests they could have discovered the ease for OOB errors much \nearlier, especially when they can be caused by just a single character in Khmer or Tibetan.\n"},{"id":1222,"cve":"CVE-2016-1636","project_name":"chromium","description":"The code that handled subresource integrity checks was flawed in that if a resource was requested from the same origin a second time, a second check wouldn't be run. Instead the code checked to see if a test had been run, and considered it a success regardless of the result of the integrity check. This completely bipassed the SRI protection mechanism, which is a chromium subsystem that handles checking the integrity of fetched resources","mistakes":"This entire issue stemmed from a minor oversight in the middle of a revamp of subresourceIntegrity code. Not a major design failing, it seems like the developer overlooked the actual result of the check, and assumed that if it had happened, everything was kosher. This was in the middle of fixing another issue that also involved checking the cache"},{"id":388,"cve":"CVE-2011-2840","project_name":"chromium","description":"This bug allowed remote attackers to spoof the URL bar via \"unusual user\ninteraction.\" In other words, URL bar may be stolen if user clicking on\nchrome interface. Such as, user navigating to the 'view download page'\nwill leave url bar, which is filled with information, may be spoofed\n","mistakes":"This issue was a coding mistake because the browser originally had the\nfunction to kill the pending page, but the if statement was looking for\ntoo many conditions to call the dedicated function.\n"},{"id":79,"cve":"CVE-2010-1505","project_name":"chromium","description":"When opening a new tab, one could take advantage of a race condition and\nstart loading a page in that tab before the new tab process (NTP) completed.  \nThis resulted in the newly-loaded tab sharing the privileges of the new tab page.  \nThis vulnerability was the underlying cause of another bug (Chromium bug 12718) \nwhich saw form submissions being submitted as a GET instead of a POST since the \npage was loaded in the new tab process.  With the privileges of the new tab process,\nan attacker may have been able to execute a CSRF or similar attack taking advantage of\nthe side effects of these privileges (such as the change of form submissions from POST \nto GET).\n","mistakes":"At the VCC and between the VCC and fix, there appears to have been extensive refactoring\nwith moving functionality to new directories.  This was done in batches of massive commits, which\nlikely made it more challenging to identify issues and vulnerabilities in the files involved.  This\ncould be classified as a mistake made in version control practices.\n\nAs for the vulnerability itself, the fixes are simple and seem appropriate, and the developers\nhad the foresight to practice defense in depth by adding an additional safety check after the initial\nfix was made.  Overall, the only fix that needed to be made was an additional check for DOMUIScheme; the\nvulnerability appears to have been a result of a simple coding mistake.  \n\nOne could argue that a greater design mistake is implied by this vulnerability since it occurred\ndue to a race condition.  The condition could potentially lead to further vulnerabilities in the future; however,\nthe fix did not address this overall issue but rather the specifics of this vulnerability.\n"},{"id":898,"cve":"CVE-2013-6649","project_name":"chromium","description":"A use-after-free vulnerability in an SVG rendering function in the\nBlink engine in Chromium was found through unit testing.\n\nThis vulnerability allows for remote attackers to possibly cause a denial of\nservice (e.g., crashing the program) or other exploits by using vectors of an\nSVG image that is zero bytes in size.  If the Blink engine attempted to\nrender this image into a buffer, unstable behavior or remote code execution\ncould occur by referring to that address space (via a pointer).\n","mistakes":"There was definitely an overlooking of basic validation.  This can be\nattributed to the complex functions in the rendering code such as nested\nif statements which make it hard sometimes to accurately place validation\nconditions.  Checking for null/empty values is a must, especially in a\nlow-level language like C/C++ which is what Chromium is written in.  These\nkinds of mistakes are commonly associated with use-after-free and buffer\noverflows due to memory mismanagement.  It is interesting to note tests\nwere added, but none of them appear to directly check for zero-size images.\n\nThe code was also reviewed on that VCC commit, so reviewing procedures should\nprobably be revised, especially to review edge cases and validation in and\naround the changed code.\n"},{"id":925,"cve":"CVE-2014-1713","project_name":"chromium","description":"Memory addresses were continuing to be accessed after being freed. This could\nallow remote attackers to cause a denial of service or other unknown impact.\n\nThis vulnerability was the result of misusing C's built-in pointers.\n","mistakes":"This was a coding mistake made by not properly handling pointers. When the\nauthor added their code, they failed to recognize that their code would\ncontinue to access certain resources after being freed. One way to resolve\nthis is to dig through the code and figure out where resources are being used\nafter free. However, that can be very difficult and time consuming, the simple\nsolution was to switch over to C++'s smart pointers which automatically handle\nthese kinds of errors.\n"},{"id":63,"cve":"CVE-2010-0664","project_name":"chromium","description":"Certain URLS will cause the browser to crash due to stack exhaustion. The\nURLs are parsed recursively, so if there are too many nested protocols in\nthe URL the stack will run out of memory before it can completely parse it.\nThis causes a denial of service as the browser will crash, or an OOM (out\nof memory) message is thrown.\n","mistakes":"Personally I wouldn't have expected anyone to have to plan for this\nparticular vulnerability since it involved a url call to multiple\nprotocols, which would exhaust the system resources. I would expect people\nto test calling multiple protocols, but I wouldn't expect them to call\nthem as many times as it did to exhaust the stack resources. From my\nunderstanding it took several calls to different protocols to cause the\nissue.\n"},{"id":1107,"cve":"CVE-2015-1274","project_name":"chromium","description":"This vulnerability took advantage of Chrome's feature to automatically open\ncertain filetypes upon download. If a user at any point downloaded an\nexecutable file and checked the box to automatically open this type of file\nin the future, then any website could initiate a download of an executable\nfile and the browser would immediately execute it.\n","mistakes":"This can be described as a requirements mistake. By the original\nrequirements, it was perfectly valid behavior for any filetype to be\ntreated as auto-openable. However, an unintended effect of this was that\nexecutables were also candidates for auto-opening. After updating the\nrequirements, it is now no longer correct behavior for any executable\nfiletype to be allowed to auto-open.\n"},{"id":1229,"cve":"CVE-2016-1643","project_name":"chromium","description":"A function in Google's Webkit in Blink (a web browser Google introduced in\n2013) that was used to ensure a resource, called a shadow DOM (Document \nObject Model) was synchronized properly with the current content on the page \nthe user would be looking at, did not properly update the model when content\nchanged or was unavailable.  The out of sync resource would allow remote \nattackers to cause a denial of service or possibly have unspecified other impact\nthrough arbitrary code execution (hackers could craft their own code which the\nprogram would run blindly).  This is because the function, when it crashes, \ngives the attacker semi-reliable control of the stack of the chrome system.\nThe stack is the set of instructions the program will run in order.  \nControl of the stack means the user has control over what the program will \nexecute next. The reason for using a resource like a shadow DOM is allow \nfor a controllable boundary between the actual implementation of various items\nlike a slider, and the use of them. Rather than requiring users to code every last\npiece of everything on webpages, shadow DOMs are used to give developers access\nto elements that the implementers of the framework want you to have access to,\nwithout exposing the framwork itself.  Think of a shadow DOM as a way for\nframweork developers to let webpage developers work with complex pre-built \nitems like various kinds of input sliders or video frames, without exposing\nthe code for how those reach into the framework itself, all the while allowing\nthe user to both utilize, customize, and stylize those elements.  The problem\nthat was encountered here for this vulnerability is that the shadow DOM was\nnot being properly refreshed. When source images weren't loaded (the\n\u003cimg\u003e tag being the html component that is actually a secret call to items\nin the shadow DOM that do some magic reaching into the framework), the DOM\nwould suddenly have a refernce to items that were not actually on the current\npage (memory gets allocated for an image, then the image is never actually\nloaded, the DOM thinks there is an image but instead points to other mermory),\nwhich exposed the system to hackers.\n","mistakes":"This bug was introduced in one fell swoop after a large code rebase.  The team seemingly decided it was best to\nutilize the shadow DOM (Document Object Model) to silently take care of loading images in the background.  This is\nan interesting choice for the use of a shadow DOM because it would have to be maintained properly for it to not\nstart pointing to areas in memory that were not secure.  Unfortunately that is what happened here.  One user worked\non implementing utilizing a shadow DOM for the first time and did not account for when the shadow DOM itself was \nmissing or out of sync.  It was seemingly an oversight on the part of the user, and also all the users that \nreviewed the changes.  The change impacted many files.  It seems that the decision to utilize the shadow DOM \nframework is still in use today.  So this commit introduced the newly accepted framework into the system, \nand the bug that accompanied it.  The mistake could have likely been avoided had the change been smaller and \nsplit up over more reviews.  Coding and reviewing fatigue are a real thing, and as stated before, this was likely \njust an oversight."},{"id":132,"cve":"CVE-2010-3118","project_name":"chromium","description":"Chrome is a web browser, and supports some autocomplete functionality when a\nuser is entering a URL into the search-box. The search-box performs URL searching\nas well as searching on google.com, and is referred to as the 'Omnibox'.\nThe autosuggestion appears to be performed by sending a http call to a server\ncontaining the text the user has currently typed, and requests for possible\ncompletions of that text. This call is in http and an attacker could concievably\nsniff this information and see what text or partial URL a user is viewing.\n\nThis vulnerability (CVE-2010-3118) focuses on the case where a user includes\ntheir username and/or password in an https URL they enter into the search-box,\nsomething akin to \"https://user:password@host\". This will be included in the\nauto-complete request sent to the server over unsecure http.\n","mistakes":"The initial issue seems to best fall under a Design Mistake. The autosuggest\nfeature did not initially perform any comprehensive checks to see if\nautosuggestion was appropriate for the current URL.\n\nA fix was submitted that covered many different cases where autosuggestion\nwould not be appropriate, but still allowed it in some cases where it was\nnot appropriate. This could be considered a requirements mistake as it\nrelied upon a poorly defined requirement.\n\nSome of the comments in the issue tracker noted the different ways that\nURLs could contain sensitive information, and many of them are small edge-cases\nthat relied upon still developing technology (HTTPS). New edge cases could\nbe introduced as the standard grows, and these edge cases will need to\nbe updated once more. This file was curated in 2018, but I am unsure if\nmore edge cases have been found since this vulnerability was resolved.\n"},{"id":164,"cve":"CVE-2010-4039","project_name":"chromium","description":"In one of the startup scripts for the linux build wrapper for chrome, a line to\nimport libraries uses an environment variable. If this environment variable did\nnot exist, then it there would be a hanging \":\" left over. This causes the system\nto use the current directory for libraries. If malicious libraries are placed in an \nattacker-controlled directory, an unsuspecting user could have those libraries \nloaded into their chrome instance when they start it.\n","mistakes":"I don't think there were really any mistakes that led to this vulnerability.\nDevelopers should be aware of variables and making sure that they are set before\nusing them, which is the cause of this vulnerability. However, the application\nstill runs as expected even if the environmnet variable is null. It takes close\ninspection and thought to realize that an attacker could place malicious libraries\nin the directory that chrome is being run from, and being a build script, developers\naren't usually as concerned about checking for security vulnerabilities, just about\nmaking sure that the program will always be able to run given all environment conditons\n-- and in this case, it does.\n"},{"id":150,"cve":"CVE-2010-3413","project_name":"chromium","description":"The vulnerability is in the browser's built-in popup blocker functionality.\nThe blocker will sometimes attempt to read from an empty list of blocked\ncontents. This results in the blocker reading from a NULL pointer and causing\nthe browser to crash.\n\nOne big exploit that could arise from this vulnerability is a denial of\nservice (DoS) keeping the popup blocker from protecting the user's browser\nfrom potentially harmful popups.\n","mistakes":"The vulnerability arose because the popup blocker was not checking the value\nof the list of blocked items before trying to access it. This caused it to\ntry and read from the list, even if it was NULL. Checking for situations\nlike these are vital to every secure program's operation, because these\nchecks keep it from malfunctioning and causing unintended, potentially\nharmful, consequences.\n\nThis was a vulnerability that was coded in right from the beginning when the\npopup blocker was made. It was discovered by a common user who reported the\nproblem to the developers. This vulnerability isn't reported to have caused\nany serious damage to other users, but had it been discovered too late,\ncould have frustrated others in the future.\n"},{"id":1024,"cve":"CVE-2014-7936","project_name":"chromium","description":"There is a \"use after free\" error within this vulnerability. A \"use after free\"\nis an attempt to access memory when it's already freed. This can cause the software\nto crash, or potentially execute arbitrary code or elevate privileges to perform\nother remote executions. In this specific vulnerability, the ZoomBubbleView::Close\nfunction allows for document input (or other input) that can cause a denial of service\nattack from malicious parties. In addition, they could potentially utilize the document\ninput in ways that can violate the integrity of the system in other ways, such as\nrunning malicious scripts at lower levels of Chrome without the user knowing.\nDue to the nature of \"use after free\" as well, we could potentially see a vulnerability\nwith elevation of privileges to change parts of the application that should not be malleable.\n","mistakes":"I think this was another artifact of an earlier used piece of code. This is\na simple problem that just requires not using a depricated piece of code to\nbe fixed.\n"},{"id":1027,"cve":"CVE-2014-7939","project_name":"chromium","description":"If Harmony Proxy (a specific JS Proxy) in Google's JavaScript Engine V8 is\nenabled (disabled by default), it allows remote attackers to bypass the Same\nOrigin Policy via JavaScript code with Proxy.create and console.log calls.\n\nThe Same Origin Policy is an immensely important concept in web, it means that\na web page cannot access data from another web page unless they are of the same\norigin -- calculated based off of URI scheme, host name, and port number.\n\nThis allows access to the victim's URL as a proxy, and potentially committing\ninformation disclosure of user/victim data right to the attacker's own console.\n","mistakes":"This vulnerability seemed to be a widespread problem involving MIME sniffing.\nThis issue with MIME sniffing rised up against other browsers as well, most\nnotably Firefox. In the bug report, the Google employees are specifically\nreferencing the mozilla bug report forum and their proposed solution. It's\nreally quite interesting to see collaboration between the two giant browsers.\nThe Chromium team debated with other options for the fix, but ultimately ended\nup going with Firefox's proposed solution of locking down the window's\nprototype chain.\n\nThe fix for this originally ended up being quite simple, by adding a nosniff\noption in HTTP headers, but eventually the bug was re-opened and a new, more\ncomplicated, solution needed to be found (mentioned above). It seems the HTTP\nheader option was merely a step in the correct direction (this is now\ndefault in modern browsers).\n\nAs for the CWE entry, I found it very diffiuclt to pin down exactly which\nbroad CWE category this fits into. After much silent debate, I decided to\ncategorize it as XSS because ultimately, external JS code was being executed\nthat was not meant to be executed (even if it was via a proxy, aka not via\nthe site directly). It also directly relates to a violation of the Same\nOrigin Policy. Even though it's a bit strange, and therefore doesn't\nnecessarily have the mitigations recommended for broad XSS, there are some\nthat are still aparent. For example, I think the most applicable mitigation\nis actually Strategy: Attack Surface Reduction. This basically involves\nkeeping in mind all potential areas where untrusted inputs are possible,\nincluding things read from the network, URL components, external systems, etc.\nThis relates to the fact that the Chromium team had to think about a Harmony\nProxy as an area with untrusted input.\n"},{"id":1051,"cve":"CVE-2015-1217","project_name":"chromium","description":"The V8LazyEventListener listens for javascript events for a given type of event.\nThis vulnerability occurred in the prepareListenerObject function of this listener\nclass, which is responsible for binding DOM event types to listener objects.\nEssentially, the V8 engine needs bindings/wrappers to interact with WebKit, which\nthen in turn interacts more directly with DOM content in the Chromium app.\n\nThe vulnerability category is \"type confusion\", where a variable or object is\npreviously declared as one type but is accessed as another type.  This causes\nproblems in mainly C-like languages because they do not have memory safety that\nwill check if something like a pointer is trying to point to allocated memory\nof another type.  In this case, JavaScript code is constructed, compiled, and\nthen ran, partially based on DOM element input (what the listener should listen for).\nThe result is then cast to a function, although it is not necessarily a function,\ncausing type confusion that could cause a crash in the program or another DoS of\nsorts for a malicious actor.\n\nThis was fixed by removing testing assert statements and replacing them with conditional\nchecks for whether a context object is a document, whether it allows\ninline event handlers, and whether the internal script that is ran\nhas a result that is a function.  This ensures objects are of the proper type and are\nnot null, which could make the above exploits possible.\n","mistakes":"This is definitely a case of quick development of code between commits leading\nup to the vulnerability.  This code was overlooked, perhaps due to miscommunication\nsince it appears a different person was involved with each step of introducing and\nfixing this vulnerability.  More rigorous code reviews for common security standards\n(especially pertaining to C and how these subsystems are typically implemented in\nChromium) could add up in the long run to have a more fortified application build\nwith fewer common, easy to check for errors.  Make sure everyone reviewing understands\nwhat the code is trying to accomplish and if it does that (Validate and Verify).\n\nThe fix of checking for certain conditions before preceding to create the listener\nobject seems appropriate for this kind of vulnerability.  In the future, do not\nrely too heavily on asserts for runtime in the production environment.  These should\nbe converted to actual checks and handling of errors and exceptions.\n"},{"id":880,"cve":"CVE-2013-6627","project_name":"chromium","description":"An attack can access information beyond the length of a buffer storing HTTP\nresponse headers by having web server use pecially crafted informational\nHTTP response codes (1xx). These HTTP response codes are incorrectly processed\nand are nott removed from the front of the buffer. Other parts of the code\nalways assumes that the current HTTP response being parsed is at the front of\nthe buffer and the incorrectly processed 1xx response code produces a length\nlonger than the buffer of the responses. The attacker can use this to read the\nmain process' memory and change its execution.\n","mistakes":"The vulnerability appears to mainly stem from design mistakes. This is\nevident because the code shows that the developers did not know that 1xx\nHTTP response status codes are different from the other classes of status\ncodes. Also, the developers made a lot of assumptions without considering\nwhether the code written actually fit their assumptions.\n\nThe vulnerability shows miscommunication issues regarding the\nassumptions made (which influence which fix option was used). There also\nseems to be little communication between people on the team. I believe this\nbased on the defensiveness in the bug thread and the fact that a developer\nmoved around code without knowing how that code actually works.\n\nOverall, it appears that while the vulnerability was caused by a relatively\nsmall number of lines of code, the vulnerability was merely the symptom of\nlarger issues including design mistakes, assumptions, and miscommunications.\n"},{"id":1348,"cve":"CVE-2016-5173","project_name":"chromium","description":"In a regular webpage using Chromium and standard JavaScript, a remote attacker\nis able to modify and add functionality to JavaScript's core Object.prototype,\nthe default prototype that all JS objects inherit properties and methods from.\n\nModifying Object.prototype is normally not an issue, but Chromium's extensions\nsubsystem also adds functionality to the Object prototype and does not restrict\naccess to it. This is a concern because Chromium's extensions subsystem has access\nto lots of resources not intended to be invoked or loaded in to a client webpage.\nAn attacker's webpage (or otherwise executed JavaScript) can exploit this by\nloading in additional Chromium extensions resources allowing them to do things\nsuch as modifying what happens when objects are garbage-collected, executing\nnative functions that typically require user interaction without their\ninteraction, and otherwise calling native functions with attacker-controlled data.\n","mistakes":"The mistake here was a design mistake. The developers used a standard\nJavaScript implementation of directly binding properties to an object\nprototype and so the vulnerability wasn't obvious. The main concern comes\nfrom the fact that this code is in Chromium's extensions subsystem and has\naccess to many internal never-to-be-exposed resources and native functions.\nJavaScript at its core is notoriously lax and doesn't do any kind of access\ncontrol by default on modifying object prototypes. As a result, an attacker\nin this scenario is able to simply modify the base \"Object.prototype\" to\nadd their own functionality and carry out their exploit. The main takeaway\nfrom all of this is to expect attackers to abuse the tools you give them.\nAccounting for this and understanding more about how JavaScript works is\nkey to preventing something like this from happening again in the future.\nIn this case they solved this in all 50 files with better design, by\nextracting out a new function to do the required property binding safely\ninstead of directly adding them to the Object prototype.\n"},{"id":885,"cve":"CVE-2013-6634","project_name":"chromium","description":"An incorrect URL was used during user authentication in the Gaia subsystem. When a\nuser would login to some web application with credentials that were saved in Chrome,\nthe 302 response recieved from the web app was not properly validated. When attempting\nto redirect a user following authentication, Chrome decides whether to follow\nthe given url based on the information given to it.\n\nThe conditional logic that would decide whether the redirect url should be followed\nwas flawed, not referencing the correct url from the object in question. This\nenabled remote attackers to conduct session fixation attacks and hijack web\nsessions by triggering improper sync after a 302 HTTP status code.\n\nThis vulnerability was present in the master branch of chromium's source\nfrom around October 9, 2012 until a bug report was opened over a year later on\nOctober 14, 2013. A fix was merged on November 21, 2013- more than another month later.\n","mistakes":"At its core, CVE-2013-6634 was caused by a simple coding mistake. The programmer who\nimplemented the VCC accessed the wrong member of an object, therefor passing the wrong\nvalue into a function call that was to approve or dissaprove the traversal of a 302\nredirect. This could have been mitigatted with more testing- especially the use of a\ncode coverage tool could have identified the need for testing when a conditional like\nthis should resolve to true.\n\nThere do not appear to be tests in place to catch a regression of this issue. While\nit's unlikely a regression would happen in this location in the code, a refactor of the\nrequest object might be useful to prevent future similar errors.\n"},{"id":396,"cve":"CVE-2011-2848","project_name":"chromium","description":"Forward button and backward button on a browser help user navigate to the previous\nand the next page in the history easier. However, in some cases, after user goes\nforward manually, opens and closes a new tab, the URL bar is spoofed.\n\nThe problem lies in the way Google Chrome updates icons and URL bar everytime\nuser commits a page. The SSL/EV icon in URL bar should only be changed after\nnavigation has committed, but Chrome changes it when the browser starts navigating\nforward/backward, this means the icon changes even the actual URL may not be \ncomletely loaded. The URL bar then doesn't reflect the page that it's loaded to user.\nUser could be redirected to a non-SSL site or a phishing site and still think they\nare safe because the URL bar and SSL icons are good.\n","mistakes":"I think this vulnerability is more of a design mistake, the developer \nclearly didn't come up with an \"ideal behavior\" for handling URL bar as well\nas a complete test plan for user interactions. The actual fix and unit test for this \nvulnerability were quite simple. \n"},{"id":46,"cve":"CVE-2010-0643","project_name":"chromium","description":"Google Chrome before version 4.0.249.89 defaulted to a direct connection when\nthere were no proxies available which was different from how other web\nbrowsers handled this issue. Other browsers such as Firefox and IE (Internet\nExplorer) would display an error page if there were no available proxies.\n\nWhy is this an issue? When you have a direct connection remote HTTP servers\n(the website you visit) can see your IP address, user agent information, and\ncookies stored on your personal computer. This is a serious vulnerability\nbecause with direct connections you lose the anonymity that proxies provide.\nAn attacker could exploit this vulnerability to obtain sensitive information\nabout the identity of the user.\n","mistakes":"The mistake that led to this vulnerability was a design problem. Unlike, other browsers it was set up to use a direct connection when there were no proxies available. The main reason this was a problem because it exposed the user identity which could be used for malicious purposes. The system should have been designed to prevent a direct connection from being used without the user's knowledge. However, the design specification did not acknowledge that requirement.\n\nThe CWE entry I chose was Information exposure through sent data. With a direct connection, the user's sensitive data may be exposed to attackers. To mitigate this weakness you should define what data in the software is sensitive. This mitigation happens in the requirements phase to support the design. However, this is where the requirement was missed and evolved into a vulnerability.\n"},{"id":1086,"cve":"CVE-2015-1253","project_name":"chromium","description":"Scripting was allowed during DOM tree parsing. As a result, an attacker could infect remote browsers\nwith malicious code via them visiting a website with malicious javascript files. Once the file was a\nloaded into the browser upong page load a script tag could then beexecuted while the browser was accessing the HTML parsing\ntree. Executing javascript during this process is generally unstable and bypassed cross-origin security policy, which\nserve as a protection mechanism for a variety of other types of attacks.\n","mistakes":"This vulnerability was very obscure and probably could not have been forseen except by seasoned, security-minded engineers. That being said, a lack of understanding and attention to the lifecylce of DOM parsing was probably the root cause that lead to the initial VCC. Paying attention to the vital points in code where the system becomes subject to script execution is key to preventing these types of vulnerabilities in the future."},{"id":17,"cve":"CVE-2009-1413","project_name":"chromium","description":"This is a vulnerability in Chrome 1.0.x where Chrome does not cancel timeout\nfunctions when switching tabs, which makes it possible to execute universal\ncross site scripting by using Javascript's setTimeout function to run code on \na new page after the site has loaded.\n","mistakes":"The biggest mistake was not killing timeout functions created on one page \nwhen navigating to another page. This is ultimately what allowed for the \nUXSS style attack to occur. The fix was that the problem protocol\nwas already on its way to deprecation for other reasons, to stop processing\nChromeHTML protocol in IE URIs. If the ChromeHTML protocol was not to be \ndeprecated, a different solution would be needed.\n"},{"id":1447,"cve":"CVE-2017-5082","project_name":"chromium","description":"Insufficient hardening in credit card editor. FLAG_SECURE is not used within\nChrome on Android when putting in prefilled credit card numbers. This would\nallow another application on the same device to see the screen and capture\nthe numbers. By comparison Android Pay and Android Wallet use FLAG_SECURE for\ncredit card entry.\n","mistakes":null},{"id":1054,"cve":"CVE-2015-1220","project_name":"chromium","description":"In Google Chrome, there were multiple occasions where after a memory location is freed,\nthe location is then attempted to be used again. In this specific vulnerability, a \nlocation used for a GIF decoder is attempted to be used again after a gif fails to be\ndecoded. If a remote attacker chooses to attempt to take advantage of this vulnerability, \nthey could cause a denial of service for other users or other unpredicted behavior. \nThe way that it is anticipated that an attacker would take advantage of this is by a \n\"crafted frame size\" in a GIF. Any frame size larger than the screen size of a device \ncould cause the broken GIF to triggers a bug in the decoding code for the GIF.\n","mistakes":"One thing that I found interesting about this vulnerability is that it was found\ntwo months before it was fixed or looked at. Once it was looked at and recreated, \nit was labelled high priority and had a larger bounty than other common vulnerabilities. \nThis probably could have been done on a quicker schedule, but there might have been \na release or some other thing more important in the employee's workload.\n\nFrom reading into this vulnerability, this is a common issue that many services that\nhave gif loading have. On the Chromium team's internal comments, there was mention of \nthis issue also occuring on firefox. I believe that this was created by a coding mistake.\nThe team also mentioned that there was a quick fix in place that did not cover the edge case\nof this vulnerability-when the first frame of the gif is larger than the screen size.\n\nThe CWE associated with this vulnerability is concerned with memory use after a free, because\nof the error that occurs after the before mentioned issue with gif frame sizes. There are two\nsuggested mitigatons in the CWE entry. The first mitigation suggests choosing a language that \nprovides automatic memory management. For a engine such as blink that is quite large, it is not\nrealistic to rewrite the rendering engine in a new language. The second mitigation is to be sure\nto set your variables to NULL after they are freed, but even the mitigation strategy mentions \nthat this fix may not be very useful if there are multiple of complex data structures, and blink\nis a very complicated engine.\n\nHowever, considering they fixed the issue at its root cause(mishandling gif decoding), and changed\nthe quick fix, it seems like the fix was handled properly. \n"},{"id":722,"cve":"CVE-2012-5152","project_name":"chromium","description":"Extra memory was allocated if the playback rate of a video was higher \nthan normal and the skip feature was used(think youtube).\nThe C++ language allows for direct references to memory even \nif that reference is outside of the intended buffer.\nThe extra memory could be used for out-of-bounds read access. \n","mistakes":"It was a coding mistake. The author did not correctly account for a \nchange in playback rate properly when seeking would be applied. \nIt was an interaction of two features (seek and increased playback) \nthat had an unintended consequences. "},{"id":136,"cve":"CVE-2010-3247","project_name":"chromium","description":"Google Chrome doesn't properly restrict the characters in urls, allowing\nremote attackers to visually spoof the url bar using sequences of characters that\nare being used for a different purpose than their intended use (specifically homographic sequences)\n","mistakes":"The common mistake that led to this vulnerability was the lack of internationalization\nand localization for the URL. If it was considered, the url spoofing through the usage\nof homographic sequenced japanese characters would not have been possible. The lack of testing\nin regards to internalization and localization also contributed to this. If they tested foreign\ncharacters in their test case for the URL, they could've caught this earlier on. The lack of\ntesting on Google's end meant that it had to take the outside testing of a security\ncompany to happen to find this vulnerability for it to start to get addressed.\n"},{"id":1120,"cve":"CVE-2015-1287","project_name":"chromium","description":"There was a bug in Blink, the webkit used by Chromium that allowed an external\nresource to be loaded as CSS and interpreted with or without a correct MIME \n(media) type. This bug made it possible for an attacker to leak data by using\na CSS string injection. This bug was caused by the use of a method of interpreting\nCSS called \"quirks-mode\" which allowed for the parsing of non-standard CSS. \nThe bug had been encountered before in the past and an attempt was made to fix it\nby using a \"strict-mode\" to parse CSS with an incorrect MIME type. However, it was\ndiscovered that the attack was still possible if the attacker could change the\ncharset to UTF-16. From my research it looks like quirks-mode had been removed before\nbut it caused some issues with other tests and was added back in. Eventually it was \nremoved for good, the browser refuses to load cross-origin resources as CSS if the\nMIME type is incorrect. \n","mistakes":"It seems that the original existence of quirks-mode in the first place is for the \npurpose of parsing non-standard CSS. Non-standard CSS seems to be a sort of legacy\nsupport. \nIn the bug discussion one of the main arguments to drop quirks-mode was\nthat Firefox had already done it. This vulnerability is a design mistake, quirks-mode\nwas added in for compatibility purposes but it turned out that CSS with an incorrect\nMIME type could open up an opportunity for an attack.\nIt is possible that quirks-mode could have been fixed to make it more secure.\nHowever removing the option entirely fixed the issue with only a minor \nimpact on compatibility\n"},{"id":233,"cve":"CVE-2011-1112","project_name":"chromium","description":"\nWhen displaying a type of graphic known as an SVG, a value of infinity could\nbe used as one of the attributes, causing a write to an invalid memory location.\nThis would result in a segmentation fault.\n","mistakes":"This vulnerability was caused by a coding mistake. The coder(s) did not\nconsider the specific edge case that lead to this problem. Writing unit\ntests for the code probably would have helped the team consider edge\ncases such as this.\n"},{"id":570,"cve":"CVE-2011-3956","project_name":"chromium","description":"The extension implementation does not properly handle sandboxed origins, which may allow remote attackers to bypass the same origin policy via a crafted extension. So basically an extension could gain permissions beyond what it was initially given by the browser.","mistakes":"This bug was caused by the fact that origin was not checked by the browser before granting permissions to an extension. This can be caught by using a fuzzer to try and spoof the origin of a request.\nThe fix looks sufficient because they implement the check and add unit tests to verify proper permissions are granted."},{"id":573,"cve":"CVE-2011-3959","project_name":"chromium","description":"There was a buffer overflow in the way Google Chrome implemented locale \ninformation. This vulnerability affects one of the dependencies that Google\ncopied into their own repository and edited to work with their code.\nThe overflow could have lead to potential denial of service attacks \nand more. A Fuzzer from someone who works outside of Google discovered\nthe vulnerability. The bug affected over seven hundred versions of Chromium and was likely\nthere since or very close to the beginning.\n","mistakes":"There was a mistake in trusting the dependency and the way that Google handles\nits dependencies. By cloning the dependencies and manually changing items when needed\n(By Chromium), the project was missing out on bug fixed and other important updates. This also might have been an issue that could have been mitigated if the\nway it was implemented. Also, because this was a dependency, this was likely\nnot unit tested by the Google team.\n"},{"id":834,"cve":"CVE-2013-2879","project_name":"chromium","description":"This vulnerability occurs in a user signin process, where a user can be tricked into signing into an attacker's account, via Cross-Site Scripting, effectively phishing. This can cause the user's personal information to be revealed to the attacker. The attacker can then force an account sync with the victim, giving the attacker the ability to run code under the victim's privilege.\nThe vulnerability stems from the trust that the sign-in process has with the renderer process. There was trust between these two processes at points that the trust could be used against them in an attack.","mistakes":"The basis of this vulnerability was trust. When the file was changed to no longer support non web-based signin flow, certain trusts were not verified, leading to a trust between the sign-in process and the renderer process that opened up the subsystem to threats. Trust boundaries are important and should be reviewed when doing things like removing features.\nThe vulnerability was not found on a single or small set of lines, but rather within the overall design of the subsystem after the non web-based signin flow was removed. The fix involved removing very few lines and instead adding in the new logic that was needed after the loss of the previous feature. While a design may be fine before, this shows that it is good to re-verify a design after removing a decently sized feature."},{"id":964,"cve":"CVE-2014-3159","project_name":"chromium","description":"This vulnerability allows for a malicious site to spoof the URL of another\nsite through phishing attacks because the origin of requests were not properly \nchecked.\n\nA malicious person could write a short script. In this script, the URL location\nof a link could be changed. After it is changed, future clicking on that URL\nwill navigate a user to the new (malicious) URL.\n","mistakes":"Input from chrome for Android did not validate the origin of URLs,\nwhich is listed as a mitigation for this CWE. The fix looks proper as it\nensures that a URL is from the renderer before POSTing. I do not believe that\nthere was miscommunication or design mistakes, merely a vulnerabiltity left\nfrom improper code review.\n"},{"id":960,"cve":"CVE-2014-3154","project_name":"chromium","description":"This vulnerability was in Chrome's shutdown sequenece. If Chrome is running\nJavaScript in a window, some of the valid commands are to write to files and\nto close the current window. \n\nWhen the window is closed, the window thread did not properly remove the thread\nwriting to files, even though the memory that writer was targeting had been freed.\nThe code that closed the window thread assumed that any files it had accessed would\nno longer be used.\n\nThe fix ensured that the shutdown sequenece of a window also properly shut\ndown the file writing component.\n","mistakes":"This mistake was two-fold. There was an erroneous assert statement, along\nwith a case where a thread was not shut down properly.\n\nThe unneeded assert statement was primarily due to a miscommunication, where\na developer did not consider all the cases where a particular error could be\nsent out, or the code was later changed and the tests for that code were not\nchanged along with it.\n\nThe shutdown error was due to a design problem, where a thread was planned to\nbe shutdown, but it did not have it's components properly planned out, and an\nattached child thread was left running after the parent was shut down. More\nrigourous documentation could have prevented this problem. The parent thread\nshould have a list of child threads to ensure they are terminated at the same\ntime as their parent thread.\n"},{"id":935,"cve":"CVE-2014-1723","project_name":"chromium","description":"This vulnerability is actually a really cool one. Malicious actors could insert a right to left\n(RtL Character) into a url using their keyboard to create very misleading urls. The RtL reverses\ncharacters after it in a string in the GUI. This character is completely insivible to the users of chromium, \nso it was almost impossible to detect. For example, a malicious user could use this character and create \na url like \"coolcamsj.png\". However, due to the RtL character in the url, the browser would actually read \nthe string as \"coolcamgnp.js\" and load that, which has the potential to be malicious javascript. \n","mistakes":"Personally, I think that requirement mistakes were made that led to this vulnerability. The original\ncoders either didn't have knowledge of this character or how it could lead to problems in the future,\nbut it eventually came up. Luckily, it was reported by a good samaritan, hopefully before any malicious\nusers had the chance to use it against other users.\n"},{"id":797,"cve":"CVE-2013-2839","project_name":"chromium","description":"When a user attempts to copy and paste an image via dragging, the image is typecasted into a HTMLImageElement without\nproper checks being performed to make sure that the cast is legal. This allows illegal types of image elements,\nsuch as SVGS, to be casted as a HTMLImageElement.\n\nRight after the casting is performed, the cachedImage() method is\ncalled on the casted HTMLImageElement. Since the HTMLImageElement has a larger virtual table than a SVG file, the\nadjacent memory around the casted SVG is used as part of the virtual table.\n\nThese values in memory could be\ncontrolled if heap manipulation was performed before triggering the bug, allowing for arbitrary code execution.\n","mistakes":"The mistake occurred because the developer did not properly validate his inputs, which would be a coding mistake,\nalthough an argument can be made that the developer may not have followed the design correctly. All user input\nshould be validated to ensure that what the system receives is what it expects. Also, directly casting user input\ninto another form of data is also a fairly large risk and can lead to the issues with memory. In this example, the\ncasting of the illegal types into a HTMLImageElement allowed access to parts of the heap that could be manipulated\nby the user, which is highly dangerous.\n"},{"id":1050,"cve":"CVE-2015-1216","project_name":"chromium","description":"An implementation for custom bindings related to windows in Google's V8 \nJavaScript engine left a potential vulnerability where an attacker could trigger\na denial of service attack or cause other issues due to an entity not being freed\nproperly.\n","mistakes":"The CWE only gives a few brief mitigations for use-after-free. One is to use\na language with automatic memory management, and the other is making sure to\nset pointers to null after freeing them. The entire V8 module of Chromium is\nbuilt mainly with C++, and it would be incredibly difficult to move everything\nover to a different language, not to mention the fact that it would probably\ncreate some noticeable inefficiencies.\n\nThis vulnerability is a bit different than a conventional use-after-free,\nseeing as the exploitable entity in is actually set to null, but can then be\nmodified by code later in the function. The main mistake seems to be in the\noriginal implementation, when the programmer did not put a check for this null\nvalue that would have prevented it from leaking into code later on.\n\nUse-after-free is one of the harder vulnerabilities to catch, because it is often\noverlooked by unit tests and can show up in places you wouldn't expect. This case\nof use-after-free is unconventional and was not as clear as more textbook examples.\nLuckily, the fix was fairly simple and properly mitigated the vulnerability.\n"},{"id":1293,"cve":"CVE-2016-1707","project_name":"chromium","description":"On iPhones, remote attackers can make malicious web sites look safe by masking the URL with a trusted website like https://google.com.","mistakes":"I believe this was primarily a logic error that did not expect the url to be invalid. The first time the iOS web controller was included into Chromium, it was only making sure that the URL was as expected, but it did not really do anything if the URL was not as expected.\nFurthermore, this is an interesting case of a spoofing attack. This is an Improper Input Validation vulnerability instead of what is commonly a URL Redirect bug because the exploit works by inputing an invalid URL to force an error on Chrome."},{"id":998,"cve":"CVE-2014-3803","project_name":"chromium","description":"Blink, the rendering engine used by Chromium, has a feature which\nallows for attackers to enable microphone access and obtain speech-recognition\ntext from users. This can be done by using an INPUT element which uses a\ndeprecated attribute.\n","mistakes":"This vulnerability could have been prevented if the x-webkit-speech\nfeature was removed shortly after becoming deprecated. When they decided to\ndeprecate this feature, there was mention that it would later be removed,\nbut with no specific deadline or date to do it by. The fix was to disable\nthis deprecated feature, which was successful in fixing this vulnerability.\n"},{"id":1099,"cve":"CVE-2015-1266","project_name":"chromium","description":"Attackers were able to bypass restrictions in chrome to access GUI components\nthat should have only been accessible with certain permissions or through a proper\nroute. They could do this by attempting to visit a malformed url into the chrome\nURL bar.\n","mistakes":"The major mistake in this vulnerability was not thinking ahead to how the input\ncould be spoofed. They trusted the input from the user and expected that the only match\nfor that string would be for the valid route.\nSimply having a distrust for input from all users could have accounted for this.\n"},{"id":346,"cve":"CVE-2011-2783","project_name":"chromium","description":"In Chrome's developer mode, when using the extensions interface at\nchrome://extensions, it does not prompt the user with a dialogue box when\nloading an unpacked extension (an extension that is not available through Chrome's\nstore) that contains an NPAPI (Netscape Plugin Application Programming Interface,\nan interface that allows for plugins such as browser extensions to be developed \ndirectly for web browsers) plugin like it does with other extensions. Without\nthis prompt, it is easier for a malicious user to modify Chrome's functionality\nvia something like a Trojan horse attack.\n","mistakes":"The vulnerability was an oversight in the types of extensions that could be\nloaded. Ideally, assuming there are restrictions in place on the types of\nextensions that can be loaded (which there should be, otherwise you risk breaking\nthe distrust input protocol), there should be a list of those extensions\nthat is tested through incremental testing when anything related to the extensions\nloader is modified.\nWhile it is nice that they're ensuring that NPAPI extensions will now correctly\nprompt the user, it does leave a bit to be desired, specifically that there may be\nother extensions left that have the same problem; again, the best course of action\nshould be to ensure that every type of extension prompts the user when loaded, as intended."},{"id":1209,"cve":"CVE-2016-1623","project_name":"chromium","description":"Due to the implementation of the HTML parser, an unapproved frame component \ncould attatch itself to the page at the same time an approved component was detatching.\n\nThis allowed remote attackers to piggyback off the current state of the approved frame \nto execute commands remotely on the system.\n","mistakes":"This is an example of a design mistake. The system was designed to check\nagainst a method that it was possible to never advance and skip the guard altogether.\nIf it was designed to use a different guarding method, the exploit may not have occurred.\n"},{"id":1095,"cve":"CVE-2015-1262","project_name":"chromium","description":"A width field, m_totalWidth, was not initialized, but was used in other areas of the code. This could have caused denial of service or other unspecified impact via Unicode text.","mistakes":"The mistake was mostly a design issue. They initialized the variable, but it was initialized after a condition was checked. If the condition passed it would return and the value was never set, so the value just needed to be set at an earlier point in the code, which is what they did to mitiigate. To prevent against this issue , or mistakes similar to this, they could have code reviews to catch design/coding flaws that have the potential to harm the system such as this one. Another way to prevent against something like this would be to use TDD (test driven development). This way, when going through the conditions in the HarfBuzzShaper::shape() function, they could check for what the values of certain fields are, or if those fields were even set at all, and correct the issue if anything was not what it should be."},{"id":1342,"cve":"CVE-2016-5165","project_name":"chromium","description":"This vulnerability allows an attacker to send a specially crafted url that\nmakes use of the settings parameter in the chrome devtools to inject\nmalicous javascript. The script is executed the next time that the user opens\nthe developer tools in chrome. The attacker can write javascript to modify or\nexfiltrate data from whatever site the user opens devtools on. The url would\nlook something like the following: \"chrome-devtools://devtools/remote/serve_rev/@180642/devtools.html?settings={%22watchExpressions%22:%22[\\%22alert(document.domain)\\%22]%22}\"\n","mistakes":"I think the main take away from this vulnerability is that you should think\ncarefully about what exactly your are allowing a user to do when you are\nimplementing a new feature. It is important to consider the abuse and misuse\ncases that will be possible with the feature are adding and how you could\nmitigate those, especially if you are accepting user inputs.\n"},{"id":447,"cve":"CVE-2011-3045","project_name":"chromium","description":"Lack of a controlled space for use in an added image library allowed for certain\nPNG images to expand to 3 or 4 Gigabytes in size, triggering a 32-bit signed\ninteger overflow leading to a Denial of Service.\n","mistakes":"I believe the mistake made that resulted in this vulnerability occurred due\nto the team's acceptance of the third-party library, it appears they assumed\nthe library would take care of the vulnerabilities within without checking \nif it did. When they first introduced this bug, they probably didn't realize\na PNG file can unpack to overflow a 32-bit integer.\nAdditionally, there doesn't appear to be any unit tests related to the library,\nwhich means they assumed its open-source nature would result in security issues\nbeing fixed without much hassle. While this is true, there was a length of\ntime between the issue and the fix where special PNG images could DoS Chromium.\n"},{"id":878,"cve":"CVE-2013-6625","project_name":"chromium","description":"This vulnerability is an example of a use-after-free bug. This\nmeans that a chunk of memory in the program was given back to the operating\nsystem to be used for other things, but then the refernce to that memory was\nused later in the program's execution. When the reference is used again, the\nprogram will attempt to use whatever data was put there as the original value.\nThis could be hazerdous if the memory is now being written to or read from by\nother code.\nIn this case, the the use-after-free occurs during the rendering of the of the\nhtml DOM. The bug happens when a child node of an object dom is removed but a\nreference to that node is still kept, despite the fact that the memory is\nfreed. Child nodes can be removed after mutation, or blur events that occur in\nthe DOM. If another reference to that child node is kept somewhere else, then\na use-after-free can occur. This fix was to change the scope of the\nnodeChildrenWillBeRemoved to be the entire document instead of the document\nwithin the container. This ensure that references to the child node that are\noutside the scope of the document within the node being modified.\n","mistakes":"The fact that this vulnerability existed in code that was reintroduced, and\nthe fact that there was so much refactoring going on in this area of the\ncode leads me to believe that the primary cause of the vulnerability was\nmiscommunication.\n"},{"id":1168,"cve":"CVE-2015-6768","project_name":"chromium","description":"When stopping an HTML frame and its children, there is a point where\na loader for the frame is stopped. At the point where a frame loader is stopped,\nthere is an instance where a URI is called in order to replace the action of\nstopping the frame. Once the URI is called, the action suppresses the final step\nof fully closing the frame. Due to the frame never being fully closed, an\nattacker may now load whatever elements they desire.\n","mistakes":"There was a coding mistake that involved not accounting for an edge\ncase scenario within an edge case scenario. The developers could have\ntaken extra measures to ensure when the code fails it does so securely\nso an attacker cannot take advantage of a vulnerability like this.\nOtherwise, if you don't realize it from the beginning it won't be caught\nfor a while.\n"},{"id":145,"cve":"CVE-2010-3256","project_name":"chromium","description":"Google Chrome did not properly limit the number of stored autocomplete\nentries, which has unspecified impact and attack vectors. It was possible\nto overflill the system by creating a form with thousands of hidden fields \nthat are all added to list of autocomplete fields.\n","mistakes":"The mistake here was design mistake. The autocomplete feature did not limit\nthe amount of items it could store per form. This was not a coding mistake\nbecause it was not in the design to limit the input. The solution of limiting\nit to a set number of items seems like a patch but it will eliminate the issue.\n"},{"id":68,"cve":"CVE-2010-1231","project_name":"chromium","description":"The vulnerability was in Chrome's SafeBrowsingResourceHandler which controls a\nchain of ResourceHandlers that, when browsing in safe mode, do processing \non a url or a resource and decide whether it can be loaded or not.\n\nThe implementation of SafeBrowsingResourceHandler simultaneously did protective\nparsing of a url and retrieved the resource's HTTP headers. This caused the headers\nof the resource to possibly be processed before identifying if the url was safe\nto load or not. Once the headers were processed, ResourceHandlers further down the \nchain could use the post-processing header response to do a number of actions such\nas load the requested url, load a url from the header response, tell the DownloadManager\nto download a file from the url location, apply cookies to the browser, etc.\n\nThis could be exploited by using custom HTTP headers to start a download of a malicious \nfile that could exploit a program on the OS (ex. a .pdf file that exploits a know Adobe\nReader bug) or just be straight malware.\n","mistakes":"The mistake was attributed to mostly a design flaw. \n\nAt the point in time of development, SafeBrowsing was a generally new feature \nof Chrome 4.0 (released Jan 25 2010) when the vulnerability was discovered (Jan 29 2010).\nThe team had only recently set up the process for checking blacklists, blocking cookies,\nand parsing urls before loading partial resources for the page. Most likely the specific\nsteps of the process were disjoint and not easily extendable or easily added to. There \nwas just a miscommunication of what had to get done when and steps ended up out of order.\n"},{"id":59,"cve":"CVE-2010-0660","project_name":"chromium","description":"Chromium sends an HTTPS URL in the Referer header to an HTTP site when redirecting\nfrom a secure HTTPS site to an unsecure HTTP site. \n\nThe 'Referer' header is the address of the previous web page from which a link \nto the currently requested page was followed. An unsecure HTTP site may obtain \nsensitive information embedded in the HTTPS URL such as password reset links.\n\nEven if the security of the site is not compromised, the user of the site may \nnot want the information shared.\n","mistakes":"The mistake was essentially not handling an edge case where a request\nwas made from a secure site to an unsecure site using a redirect. The fix\nitself was only 2 lines of code to check to see if the referrer header should \nbe cleared before redirecting. It was clear that the developer's knew from the\nbeginning of the repository that the referrer should not be sent from an HTTPS \nsite to an HTTP, and did not in other cases, but this was not implemented in \nredirecting.\n\nThe CWE vulnerability mitigations suggest that this could have been avoided\nin the Architecture and Design phase by drawing unambiguous trust boundaries.\nIt would be interesting to see if there were updates to security related\ndesign documentation to show how a redirect can be used to leave a site\nsecured by HTTPS. \n\nThe fix itself appears well enough, but it is hard to tell if there was a lesson \nlearned by the developers from this mistake since it is unclear why this case\nwas missed (other than just complexity). It is not even safe to say that all\ninstances of the referrer crossing trust boundaries are handeled or that future\nfunctionality will not repeat the same mistakes.\n"},{"id":950,"cve":"CVE-2014-1741","project_name":"chromium","description":"There are a couple cases in lower level code that handles rendering characters where an offset was not handled in a overflow-sensitive manner. This might have had unspecified impacts via vectors related to ranges or open up to DoS attacks.","mistakes":"This is another example of a minor coding mistake overlooked in a huge commit. The offending code subtracts an offset without accounting for a possible overflow, which is only a minor part of a major rewrite of the subsystem to fix another bug. The fix accounts for this, and handles it in a way that's consisitant with the DOM spec"},{"id":141,"cve":"CVE-2010-3252","project_name":"chromium","description":"If a program opened a notification through Chrome and then terminated before\nan actively running notification closed, then the notification would try to\ndetach from the no-longer-existent program it came from and cause a corruption\nof memory.\n","mistakes":"The reason that this vulnerability occurred was because the Software Engineers\nworking on it never covered the case where a notification from Chrome outlives\nthe program that spawned it. The actual problem was that memory was freed before\nit was done being referenced but it wouldn't have been an issue had the team\nworking on it paid more attention to covering unlikely but possible scenarios\nfor their use cases to end up in, like in this race condition. It is probably\nuncommon, and maybe even unlikely, that a program that makes notifications won't\nlast at least as long as those notifications themselves. But it's not unreasonable\nand only required the simple fix of adding a method that gets called when a\nnotification provider terminates, simply going through and detaching it from all\nlive notifications first. A little bit more effort planning ahead could have\nhelped their system's overal integrity.\n"},{"id":1102,"cve":"CVE-2015-1269","project_name":"chromium","description":"Attackers can bypass HSTS restrictions due to a lack of canonicalizing DNS hostnames before comparing them to the HSTS list. HSTS is the security policy that declares to web borwsers they should only interact with the page via HTTPS connections. Before the fix, attackers could add a dot (.) character to the end of the connection string or use a string that isn't completely lowercase, which would then be compared to the HSTS and HPKP entries already preloaded on the system. These comparisons would then allow the attacker to bypass this secure connection and gain access to content not initially intended for users.","mistakes":"The mistake that was made was that the developers tried to rely on whiteboxing alone and didn't attempt to normalize any inputs. They may have originally felt that by whiteboxing, any unlisted inputs wouldn't be able to be used, therefore making the inputs secure.\nThe fix implemented looks proper, according to the CWE, now incorperating normalization methods along with the original whiteboxing method."},{"id":1473,"cve":"CVE-2017-5109","project_name":"chromium","description":"UI spoofing in browser. JavaScript-related functionality causes the\nnotification window for another domain/page to be displayed. This was caused\nby improper unload handler handling, which allows a permission request to be displayed\nfrom a domain after navigating to a new domain. For example, a malicious website can\nhave a button that takes you to Google Maps and request your location.\n","mistakes":"The fix was to close the permission bindings when the render frame host changes\nso that messages are no longer received to run code in the permission service.\nThis was a design oversight that may have been prevented by considering the\nflow of permissions when switching frames, and considering invalid states prior to implementation.\n"},{"id":1085,"cve":"CVE-2015-1252","project_name":"chromium","description":"The vulnerability was in Chromium's common utility functionality, specifically\na new implementation of a \"PartialCircularBuffer\" which was basically a buffer\nthat could wrap around *n number of times to have a continuous write of data.\n\nThe implementation, which was in C++, didn't handle the wrap around buffer write\ncase for large amounts of data properly. This had the possibiliy of resulting \nin data being written to memory that it was not intended for (an \"invalid write\"),\ncorruption of data, crashes or most significant to the security aspect of the\nissue allowing for arbitrary code execution as it was functionally a \"buffer \noverflow\" scenario.\n\nThe way that this could be exploited would be if an attacker found a way to \naccess the web logging that was being utilized and pushing any very large amount of\ndata to the target log write buffer which would result in a denial of service\nattack on the system. Since this particular issue was a common utility the potential\nattack possibilities while being more widespread would also depend on how the\n\"PartialCircularBuffer\" was being used in the different modules.\n","mistakes":"The chosen CWE is 787 (Out-of-bounds Write) has no mitigation strategies\nlisted however there are mitigation strategies in CWE-119 (Improper \nRestriction of Operations within the Bounds of a Memory Buffer) which is\nwhat NVD lists as the class of the CVE issue. I have chosen CWE-787 as\nthat is the exact issue that occured but the NVD listed CWE-119 has what\nI would consider applicable, specifically the mitigations in the\nimplementation stage. The fix is specifically addressing the mitigation\nof checking the buffer boundaries if accessing the buffer in a loop\nto make sure you are not in danger of writing past the allocated space.\nSince the issue at its core is a lack of checking proper space checking\non the buffer size vs input size when handling the wrap around case, the\nfix moves the wrap around content out of the initial write loop to ensure\nsafety when writing the given input. The initial implementation simply did\nnot include thorough enough testing to catch this edge case.\n"},{"id":1218,"cve":"CVE-2016-1632","project_name":"chromium","description":"Attackers can bypass intended access restrictions using JavaScript code.The attack\ncauses an incorrect cast.\n","mistakes":"With the limited information about the vulnerability, we can only say it was \nprobably a coding mistake. Potentially more testing could have been done beforehand.\n"},{"id":589,"cve":"CVE-2011-5319","project_name":"chromium","description":"The application does not restrict access to accelerometer data at high rates. This allows attackers to capture the keystrokes and moitor speech from the website without a permissions prompt.  The keystrokes and speech are a part of the website interaction.","mistakes":"I think that for this bug there really wasn't too much that could have been done before hand if the team did not know about the attack.  However, they could have had something around their events to try to always prevent attackers from getting their data.\nThey had a few different ideas for how to resolve this issue, a few did not work out for them.  They appear to have a proper fix by limiting how fast the data can be read."},{"id":758,"cve":"CVE-2013-0891","project_name":"chromium","description":"An integer overflow in Google Chrome in blob url request leads to a buffer overflow\nallowing an attacker to control a specific function of what bytes to read. This attacker\ncan lead to a denial of service, information disclosure, and other unforeseen issues.\n","mistakes":"The mistake that was made was the improper checking upon the limits of input\nwith the number value and testing the boundary conditions. The mistake and \nvulnerability was within a sub system of chromium but had the ability to release\nsensitive information.\n\nThe mistake was the lack of unit testing and so when someone realized that the\nboundaries could be exploited, another author went back to input the proper\nthe proper checking to fix the mistake. The vulnerability seems to be resolved\nas boundary checking was inputted and the variable types changed to be the proper\ntype. However, since there didn't seem to be any change in testing or lack of\ntesting, there's no sure way of seeing if the issue is totally resolved.\n"},{"id":681,"cve":"CVE-2012-5108","project_name":"chromium","description":"A design problem in the way Chromium handled multi-threaded audio output\nuse of audio output devices resulted in a race condition.  When an audio\noutput device was first created and initialized, it could be interrupted\nand potentially deleted before startup finished, resulting in the pointer\nto the callback function being null.  This use of memory after it had been\nfreed allowed for arbitrary code to be executed.\n","mistakes":"Mistakes were made in considering the design of how the audio output device\nthread stopped execution and was deleted.  The developers did not count for\nmultiple flows of execution in separate threads, where execution may be \ninterrupted and the audio device may be deleted before it finishes \nstarting.  Another mistake here was not checking for null in the pointer\nbefore trying to use it.\n"},{"id":135,"cve":"CVE-2010-3246","project_name":"chromium","description":"Google Chrome's pop-up blocker could be bypassed if a form submit opened window _blank; this would allow a site to gain the ability to open X number of chrome tabs.","mistakes":"It's hard to say someone shouldn't trust a third party tool that is as widely trusted as WebKit. This definitely should have been tested for, however. A strong negative path test case would have been the abuse case for this bug. The test that's been implemented now appears sufficient mitigation. The fix looks proper."},{"id":1227,"cve":"CVE-2016-1641","project_name":"chromium","description":"An image downloading function in a file related to web content could potentially\ngrab info that was freed out of order in such a way that an exploiter could\ncause a denial of service attack. This was demonstrated by a fuzzer with a\nfavicon download.\n","mistakes":"The CWE only gives a few brief mitigations for use-after-free. One is to use a language with automatic memory management, and the other is making sure to set pointers to null after freeing them. The majority of the web contents subsystem built mainly with C++, and it would be incredibly difficult to move everything over to a different language, not to mention the fact that it would probably create some noticeable inefficiencies. The fix actually involved just rewriting the function to avoid the problem area in the third party service entirely.\nThe main mistake made with this vulnerability was not realizing how the third- party service was touching other pieces of code. Working with a codebase this large, it can be near impossible to cover everything. However, special attention must be made to anything not kept within internal systems.\nLuckily, these mistakes were handled quite well once found. Unlike the other vulnerability I had (CVE-2015-1216), this one was actually picked up by a test of some sort (in this case a fuzzer). Along with this, even though the developer working on the bug couldn't reproduce it, they realized that the code still appeared unsafe and went through with assigning it to be fixed. It's important to not just brush off bigger vulnerabilities like this just because you cannot recreate it at first."},{"id":886,"cve":"CVE-2013-6635","project_name":"chromium","description":"This vulenrability is located in the editing implmentation of Blink\n(the underlying web browser engine). During editing it is possible to\nattempt to use a previously freed DOM node and cause a denial of service attack,\nor other impacts using Javascript code that results in the removal of said node\nduring the processing of the Document Object Model tree. The Document Object\nModel is a language and platform independent interface that allows scripts and\nprograms to access and modify the style, content, and structure of a document.\nThe DOM tree is usually created using the HTML tags and their hierarchy in the\ndocument.\n","mistakes":"The main mistake that was made was a coding mistake in the implmentation\nof the web engine (Blink) and it's interaction with Javascript code. The\nauthors of the code base did not ensure the node pointer was correctly\nprotected and removed from reference after it was expected to be freed.\nThe authors of the code mitigated the vulnerability by switching from a\npointer, which does not have automated memory management, to a smart\npointer, which is an abstract data type that acts as a pointer but can\nalso come with automated memory management.\n\nSomeone with more experience may have knew that Javascript code could be\nexecuted between the allocation of the pointer and the freeing of the pointer\nbut the authors implmentated the smart pointer without undue trouble.\n"},{"id":1189,"cve":"CVE-2015-6790","project_name":"chromium","description":"Chromium did not properly use HTML entities upon saving a page, allowing\noffline XSS. Anchor tags with escaped HTML characters following \"#\" in the href\nattribute would render as regular HTML entities. This could also be exploited\nby a double-quote character inside a single-quoted string. This made it possible\nto steal content or CSRF tokens by making a victim save and open a page that\nincluded a crafted anchor or mixed quotes.\n","mistakes":"The mistake made was a basic lack of santization. This vulnerability was in a\nthird party tool and it seemed to recieve little review or testing due to not being\ntheir own code. The vulnerability was quickly and easily fixed once reported, but\nthe vulnerability existed for a long time.\n\nThe fix they applied of sanitizing the data before saving satisfies the standard\nmitigation. They could have improved the mitigation by adding unit tests to make sure\nit does not regress.\n\nThe largest mistake they made was trusting the third party tool. It recieved little\nreview and the vulnerability was overlooked the few times it was modified. They could have\nimproved by adding unit tests or conducting a security review of the tool before\nintegrating it.\n"},{"id":563,"cve":"CVE-2011-3925","project_name":"chromium","description":"This vulnerability comes from how Chrome handled \"interstitial\" pages which\nare the pages that load before or after an expected webpage that have an ad or\nask if you're older than 18. Trying to reload a page when you were on an\ninterstitial page caused memory corruption in the browser process and crashed\nChrome.\n","mistakes":"The actual mistake that was made in the code was that they freed a link\nfrom memory but continued to try to access that memory if an interstitial\npage was refreshed. That's a classic example of freeing a variable before\nyou're actually done with it but that mistake was caused by a number of \nother, larger factors. The code that led to the vulnerability had been\nrefactored a large number of times and that includes extracting classes,\ncombining classes, shifting responsibilities, and redesigning how to\ninternally handle interstitial pages. All of that led to inconsistent and\nconfusing documentation and small pieces of code that only made sense prior\nto their refactoring.\n"},{"id":725,"cve":"CVE-2012-5155","project_name":"chromium","description":"Chromium doesn't check if Mac OS Xs sandbox successfully initializes,\nwhich means that if a malicious attacker compromises Chromium, the\ndamage isnt contained throughout the system. This has privilege and\nrestriction implications. If an attacker uses Chromium to hack the\nsystem it's run on, they could gain access to private files on the\nsystem and possibly run arbitrary code.\n","mistakes":"The mistakes that led to this vulnerability were not considering\nsandboxing for OSX, when it was considered and used for Windows and Linux.\nThis could have just been a simple misunderstanding or overlook on the\ndevelopers side of things.\n\nThe lesson learned from this vulnerability is to check the initialization\nof important subsystems/components that could compromise the integrity of\nthe system if they aren't initialized properly.\n\nThe mitigation for the CWE entry is being used,\nsince if sandboxing on OSX isn't initialized properly, Chromium will shut\ndown so it can't be compromised.\n"},{"id":1275,"cve":"CVE-2016-1689","project_name":"chromium","description":"A Heap Buffer Overflow vulnerability was found in Google Chrome's implementation of\nMedia Capture from DOM elements. DOM (Document Object Model) elements is an object that\nincludes how the HTML/XHTML/XML is formatted.  Media Capture from DOM elements is essentially just\ncapturing more information about the users actions on a video, image, etc. which is streamed\nback to the application and can then be used for various things. When Google Chrome\nadded this feature they had a bug where if the HTML media element's given size parameters\nwere wrong it would not check them, and would just attempt to use them, resulting in the\nHeap Buffer Overflow.\n","mistakes":"This vulnerability seemed to stem from a lack of design around the desired feature. This\nlack of design then caused the software to be implemented to trust inputs which shouldn't\nhave been trusted. It also seemed that this software was created for temporary use, due\nto the fact that the team was waiting for a specific library (libyuv::ARGBToA) to become \navailable for use.  This is understandable to an extent, as companies cannot always wait\naround for new functionality.  However, this does not excuse the poor design around the \nproblem and the lack of awareness of potential input disparities.\n"},{"id":1181,"cve":"CVE-2015-6781","project_name":"chromium","description":"Integer Overflow that allows remote attacker to cause denial of service or\npossibly have unspecified other impact via modified values in font data.\n","mistakes":"Looking at the issue report it seemed that it stemmed from a coding mistake\nsince part of the fix was to make sure that the value in question does not\nwrap around when it reaches the maximum integer. When getting the\nvulnerability fixed, there was a lot of miscommunications on which team\nis responsible for fixing the mistake, which led to the vulnerability to\nexist longer than it needed to.\n"},{"id":161,"cve":"CVE-2010-4036","project_name":"chromium","description":"This is a url spoofing related vulnerability that occurs when the user navigates back but the current page interrupts the action. The browser commits the previous url in the omnibar but the current page is still the second website. For example, if a user goes to www.google.com then goes to www.hack.me, when they attempt to go back chrome will put www.google.com in the omnibar but www.hack.me can interrupt this action with an alert that cancels the navigation but doesn't update the omnibar.\n","mistakes":null},{"id":857,"cve":"CVE-2013-2914","project_name":"chromium","description":"In the color chooser dialog on Chrome before 30.0.1599.66, \nthe listener in ColorChooserDialog did not properly dereference when the \ncolor chooser dialog was destroyed because of a page destruction (page \nclose). This led to a stale reference that attackers could use to cause\ndenial-of-service.\n","mistakes":"The coding mistake was a pretty simple one. The original author simply did\nnot kill the reference when the page was closed (destroyed). This is essentially\na XSS vulnerability; through this stale reference, attackers can cause \ndenial-of-service or attack using vectors through this reference.\n\nThe vulnerability was introduced in the initial commit, and was only exposed\nafter Chrome tried to initially make Aura, an obsolete client meant to provide\nnotifications and notification details in a client outside of Chrome. The \noriginal author must have forgotten he needed to destroy the reference so it\ncouldn't be used, or he didn't notice that he was leaving a stale reference.\n\nFor this color chooser dialog, this vulnerability could have been prevented,\nbut it's an easy thing to overlook. Next time, I'm sure the author will make\nsure something like this won't happen again.\n"},{"id":1253,"cve":"CVE-2016-1667","project_name":"chromium","description":"Web pages are constructed using a tree structure of both nodes and objects.\nThis tree structure constantly updates as different events occur. One of the\nupdates that happens to the tree stucture is called a \"node adoption\", when\nnodes are assigned ownership (not inserted) to a document.\n\nDuring node-adoption operations, script execution was not disabled. Since the\ndocument is being modified, attackers may violate the Same Origin Policy.\nThe Same Origin Policy should only allows script execution between web pages\nif both web pages originate from the same origin. When this policy is broken,\nan external web page may execute scripting on the web page that is trusted\nby the origin. This allows attackers to send data to their web page, from the\ntrusted page the user is on.\n","mistakes":"I believe this vulnerability was caused due to poor design. I don't believe\nit should be the programmer's responsibility to think about all scenarios\nwhere something could go wrong when adopting nodes to the dom. I believe if\nthe Chromium team had used something like a state pattern, where whenever\ndom manipulation would occur, the system would be in a state where no\nscripts can be executed.\n\nWithout this state pattern, it is the programmer's responsibility to think\nif the operation might need some sort of disablement of script execution.\nAs the system scales, and as proven by a similar vulnerability mentioned\nin the developers comments to each other, this sort of relaince on the\ndeveloper to think of scenarios will just lead to more of the same\nXSS vulnerability.\n"},{"id":185,"cve":"CVE-2010-4490","project_name":"chromium","description":"A malformed video could cause the application to crash by creating an\nindexing error.  A malformed video stream could have a stream index that is too\nlarge.  An attempt to index by this stream index would cause a buffer overflow.  In\nthis scenario the buffer overflow was causing a denial of service because it was\ncausing a segmentation fault resulting in the tab crashing.  A buffer overflow is\nalso potentially vulnerable to data corruption or malicious code execution.\n","mistakes":"The mistake they made was a logic mistake in which they did not include an edge case\nto check for malformed streams which allowed for the buffer overflow vulnerability to exist\ndue to indexing that may be bigger than the stream size. It was understandable that this \nwould be overlooked because the module is complex. In the bug log, they discussed their \nconcerns whether a malformed stream could have cause this vulnerability or if it got into\na bad state due a previous root cause."},{"id":1273,"cve":"CVE-2016-1687","project_name":"chromium","description":"This vulnerability in Chromium involved the exposure of private \nclasses related to Chrome extensions. This vulnerability can be \nexploited and lead to attackers obtaining sensitive information\nrelated to extensions.\n","mistakes":"This vulnerability seems like an accidental leakage. From the history of the code\nyou can see that the initial code was beleived to be hidden but did not end up so. \nThe fix that solved this mentioned ensuring \"privates are private\" leading me to beleive\nthey initially thought it was private. Possibly a misunderstanding of the technology and how\nto actually hide information from public. The feature originally was used to hide internal state\nof Javascript classes using utils.expose. This ended up having the opposite effect and allowed \nextensions to see private information. \n"},{"id":77,"cve":"CVE-2010-1503","project_name":"chromium","description":"A cross-site scripting (XSS) vulnerability in Google Chrome allows remote attackers \nto inject web scripts or HTML using Chrome net-internals. Users can access net-internals\nby typing 'chrome://net-internals' in the URL field of the Chrome web-browser, which in return,\ndisplays the network log event stream. This vulnerability occured because user input \nwas not HTML escaped. \n","mistakes":"The coding mistake that was made seems to be a simple programming error. \nThe programmer in the same commit as the VCC used the function EscapeForHTML \nmultiple times prior to the vulnerable line of code. It seems as though he \nthen neglected that the string argument \"key\" needed to be HTML encoded as well. \n"},{"id":258,"cve":"CVE-2011-1196","project_name":"chromium","description":"The OGG container allows for the streaming and presenting of digital multimedia to users. A OGG \ncontainer is made up of a byte sequence where sections of the sequence represent a different component \nof an OGG page header. Failure to track the index operations are working on can lead to buffer (in this case, heap) overflows \nwhich can cause a multitude of problems.\n\nThe vulnerability starts when an HTML page loads another HTML page in an iFrame. A .ogg file is loaded in the iFrame HTML page and then \nthe whole iFrame HTML page is replaced with a different .ogg file. This leads Chrome to crash due to heap corruption.\n","mistakes":"It is not entirely clear what the root cause of the vulnerability is. There is a comment in review 6598004 stating that a stream index is mysteriously becoming invalid. This leads me to think that there is some shared mutable data which is not being mutated in a thread-safe manner."},{"id":382,"cve":"CVE-2011-2834","project_name":"chromium","description":"A vulnerability where a memory address is freed twice, called a \"double free\". \n\nFound in libmxl2, the XML parsing library that Chromium is using.\n\nThis vulverability can allow attackers to cause a \"denial of service\" attack, where some set of users is no longer able to use the browser. It is not known what sequence of activities could lead to an exploit of this vulnerability.\n","mistakes":"The reason this vulnerability existed was a coding mistake. Objects were being freed twice, but in separate locations. This made it very hard to detect the double free vulnerability in the first place. The developers should have been extra cautious when freeing the objects and spent more time tracing through the code to identify the issue. A static analysis tool could have also been utilized to search for double free instances.\n\nAnother, perhaps better mitigation would have been to set the pointer to the object to NULL after freeing it to ensure that it was not freed twice.\n\nThe fix does not look proper. Error states were added to prevent the code from entering the code block that causes the double free. But, the fix doesn't remove the possibility of the double free. If an attacker was able to manipulate the state of the system and avoid entering the error state, the double free would still be possible.\n\nThe developers fixed multiple related double free issues within the same source code file. It would have been smart for them to check the rest of the file for any other double free vulnerabilities when they were fixing the first issue instead of fixing the issues one by one."},{"id":280,"cve":"CVE-2011-1305","project_name":"chromium","description":"This vulnerability affects only Linux and Mac OSX users. An attacker can\ncause a denial of service via certain aspects that use linked lists and\ndatabases. This is caused from a race conditions found in a WebKit patch\nthat eventually lead to crashes. Mutexes that were originally in place to\nprevent agianst race conditions were removed because they thought the WebKit\n code interacting was SQLite was single threaded and would not need to\n worry about race conditions.\n","mistakes":"The way this came about was using a faulty patch of WebKit interacting\nwith the rest of the code that interacts with sqlite. This could have been\navoided if there was a more thorough analysis of the patch before moving it\nin. Since the fix was to revert to how things were beforehand, this all\ncould have been avoided if there was a comprehensive test with the new patch\nbefore integrating it.\n"},{"id":1062,"cve":"CVE-2015-1228","project_name":"chromium","description":"There is an update counter method being called with a text updating \nmethod. The bug-causing method updates the counter, but does not set the node\nfor layout or reset. As a result, some stale text boxes may be left behind \nafter the program is complete. This causes variables to initialize incorrectly \n(or fail to initialize at all) on following sessions, causing \nthe program to crash when it tries to use the variable (denial-of-serivce).\nAttackers aware of this vulnerability could work to trigger the crash\nintentionally. A different text updating method that marks the node\nfor layout is used as a replacement, making sure all the right \nvalidations are made and no stale/uninitialized text boxes are left behind.\n","mistakes":"The mistake was a simple design mistake at the start of the project.\nThe team used a method that didn't clear the stale data of certain\ntext boxes. The mistake was probably due to not testing that area and\nproper unit testing would have found likely found it early on.\nThe mitigation, build and compilation, was used via a change of\nmethod once the vulnerability was found through fuzzer testing. \n\nNote that this may also have been an implementation error, as the\ninitial method they used is very similar to the fixing method\nexcept that the original method does not perform validation\nchecking. It is possible that the initial method used simply did\nnot do what was expected.\n"},{"id":43,"cve":"CVE-2009-3934","project_name":"chromium","description":"A function in the WebFrameLoaderClient allowed for remote attackers to cause a\ndenial of service from a page-local link. A page-local link is a link that\nredirects back to the same page when interacted with. This is directly related to an\n\"empty redirect chain\" which allows attackers to endlessly redirect urls. For\nthis vulnerability to be taken advantage of, the attackers abused the page-local\nlink which would redirect back to itself endlessly.\n","mistakes":"A coding mistake was at fault for the cause of this vulnerability. There was\na piece of logic \"ds-\u003ehasRedirectChain()\" that was always assumed to exist\nin the vcc. By not checking to see if the logic existed, it allowed attackers\nto take advantage of a denial of service vulnerability by redirectly urls\nwithout a limit.\n\nEssentially only a single line of code was missing to fix the vulnerability.\nBefore running through the logic, an if statement was required to make sure\nthat \"ds-\u003ehasRedirectChain()\"\" existed before continuing on with the logic.\n"},{"id":182,"cve":"CVE-2010-4487","project_name":"chromium","description":"This CVE affects OSX and Linux.\nAn attacker could create a page that would serve a response with a \n'Content-Disposition: attachment' for a file with an HTML extension. The \n'Content-Disposition: attachment' forces the download dialog to appear, and it \nauto-selects the attacker's malicious HTML file. If the user clicks the file name \nin the download dialog, the malicious HTML file loads and downloads a SWF file to \nthe user's downloads directory. 'setTimeout()' can then be used to delay the \nloading of the SWF file until after it's finished downloading (~5 seconds). Once \nthe SWF file is downloaded, the attacker loads the SWF file which is written to \ngrab the contents of /etc/passwd and displays the contents of the file to the \nscreen. Now that your sensitive information is written to the browser, it can be \neasily transmitted back via JavaScript.\n","mistakes":"I believe this mistake happened because the developers finally finished the download_exe.cc file, and forgot to fill out a complete blacklist for non-Windows operating systems.\n\nThere are two mitigations provided for this CWE.\nThe first is to use both a blacklist and a whitelist, but that wouldn't be a good idea for this scenario because you can't predict exactly which file extensions people want to pass in a 'Content-Disposition: attachment'.\nThe second is to not rely exclusively on blacklist validation. For this particular CVE, I believe a blacklist is just fine.\n\nThey did not use either of these mitigations. They only had to add more extensions to the file extensions blacklist in order to fix the vulnerability.\n"},{"id":160,"cve":"CVE-2010-4035","project_name":"chromium","description":"There was a bug in the autofill and translation features which could allow attackers\nto cause the application to crash remotely, therefore introducing a \ndenial of service vulnerability. This crash is caused by accessing a pointer\nafter it was freed. The reason this was possible is because of the way the chrome team\nwas using a scoped pointer for management of an 'infobar' delegate pointer. Scoped pointers\nhave automatic memory management, which seems to have cleaned up the pointer while it was\nstill in use.\n","mistakes":"This problem seems to be caused by a coding mistake. For both the subsystems\nthat the vulnerability existed in, the problem involved incorrect usage of \npointers. Low level languages where memory management has to be done manually\ncan be tricky, it would be shocking if no such errors ever occurred inside a\nproject as large as chrome. What's interesting about this bug is the fact that\nautomatically managed pointers (which are supposed to make things easier) actually\ncaused the bug to happen. Because of this, the team decided to do their own memory\nmanagement, which they could have more explicit control over.\n"},{"id":1233,"cve":"CVE-2016-1647","project_name":"chromium","description":"The navigation implementation in Google Chrome causes use-after-free vulnerability\nand allows remote attackers to cause denial of service, the bug allows\nunauthorized disclosure of information, allows unauthorized modification\nand allows disruption of service.\n","mistakes":"The mistakes that led to this vulnerability were coding and design mistakes. When a fullscreen\nwidget is created, a WebContentsImpl stores its routing id in fullscreen_widget_routing_id_.\nWCI assumes that this widget belongs to the process of the current main frame:\nGetRenderManager()-\u003ecurrent_host()-\u003eGetProcess(), which it normally does. A compromised\nrenderer can swap the process of the main frame, while keeping the fullscreen widget alive.\nNormally, the fullscreen widget would be deleted as the renderer navigates, but there\nis an exception. If the navigation was within the page, then the fullscreen is kept alive.\nThis happens for example when only the url fragment changes.  In such case, renderer sets\nFrameHostMsg_DidCommitProvisionalLoad_Params::was_within_same_page = true and the\nbrowser mostly trusts that, even if the the navigation wasn't within page and the\nprocess was swapped. If the renderer swaps the process and sets was_within_same_page = true,\nthe fullscreen_widget_routing_id_ will end up pointing to a wrong widget in the new process.\nIf the renderer now closes fullscreen, this wrong widget is deleted. It is deleted manually\nin RenderWidgetHostImpl::Destroy(), because fullscreen widgets aren't owned by a smart pointer.\nNormal widgets are owned by a scoped_ptr render_widget_host_ in RenderViewHostImpl though.\nIf such a widget is manually deleted by an attacker, the scoped_ptr in RVHI ends up holding a\ndangling pointer.\n"},{"id":322,"cve":"CVE-2011-1813","project_name":"chromium","description":"A piece of data is created on the heap, and there are multiple pointers which can point to this data. While the browser is used, JavaScript allows certain parts of the webpage to be adopted by others. In this particular case, an iframe is being 'adopted', and the pointer that points to this iframe is not being adjusted. The pointer now points to an invalid piece of data which crashes the program.","mistakes":"The developers should have written better comments so that maintainers and other developers can catch where pointers are pointing to, and be able to tell when a pointer is left dangling. It's quite difficult when one is writing C++ code of this complexity, especially in the case where pointers are being passed around as a result of JavaScript code. I have a feeling Valgrind, or another internal test should be able to look for data on the heap that has pointers to it, and should check for when that data is freed if there are any pointers that could be in danger of growing stale. Also it seems like there was a test that might have been enabled at some point that ended up catching the crash, perhaps disabled in another commit before the VCC and not reenabled until after, although I couldn't find out which commit did so."},{"id":411,"cve":"CVE-2011-2864","project_name":"chromium","description":"The vulnerability was Google Chrome before 14.0.835.163 in the way the \nthird-party software Harfbuzz handles Tibetan characters. \n\nHarfBuzz is a software development library for text shaping, which is the process\nof converting Unicode text to glyph indices and positions.\n\nThe implementation didn't handle the case when the character is out of the Tibetan\ncharacters table's bound. At best, this causes a crash. At worst, this kind of \nvulnerability can lead to arbitrary read or write operations to be performed on\nunauthorized memory locations as it is a \"buffer overflow\".\n\nThis is possible in a Cross-Site Scripting (XSS) scenario. An attacker may be able \nto execute arbitrary code or unspecified vectors, alter the intended control flow, \nread sensitive information, or cause the system to crash.\n","mistakes":"The coding mistake that was made in a third party software that led to index out\nof bound error.\n\nThe coding mistake was made in a piece of third party software that led to an \nindex out of bound error. This approach is important because it is hard to \ninvestigate and manually debug third-party codebases for memory corruption errors."},{"id":894,"cve":"CVE-2013-6643","project_name":"chromium","description":"Improper Authentification handling in Google Chrome's signin popup. The\nvulnerability allowed remote attackers to send a malicious URL to a victim and\ninsert his/her account to the victim's Google Chrome to sync the victim's\nprivate data without the victim's knowledge. The attacker could close an\nuntrusted signin confirm dialog which would sync the user's data.\n\nThe fix for this vulnerability is to cancel the signin when the untrusted\nsignin confirm dialog is closed without the user clicking 'ok got it'.\n","mistakes":"The vulnerability here was a simple oversight on what to do when the\nuntrusted signin confirm dialog is closed without clicking 'ok got it'.\nOriginally continued the signin as if 'ok got it' was pressed'\nThe fix was to abort the signin if the untrusted signing confirm dialog\nwas closed without clicking 'ok got it'.\n"},{"id":1343,"cve":"CVE-2016-5166","project_name":"chromium","description":"Using the 'save page' feature that saves the web-page and web \nresources also saves locally uploaded files to that page.  \n","mistakes":"This seems to have been a case where at the start this wasn't a vulnerability but as other \ntechnology got layered on top of it like chrome extensions and web-workers it became a\npotential vulnerability from using this newer technology to exploit older ideas.\nIt started out as just a normal feature but later on in the programs life, due to expanding functionality \nit became a vulnerability later in time and would probably now be considered a design mistake. \n"},{"id":1211,"cve":"CVE-2016-1625","project_name":"chromium","description":"Due to a lack of checking against intended target web addresses, malicious \nextensions are capable of changing where suggested links brought users when \nclicked on. This allows extensions to navigate users to malicious websites, \nor run Flash programs on the host device. Remote attackers could then use \nthis to grab any file from the host device.\n","mistakes":"This vulnerability arose from the new functionality added to the NTP,\nwhere Chromium provides the user their most-visited sites and some suggested\nones, without checking that the target of the link was the same as the link itself.\nUltimately, this was a design mistake, because the developers never\nthought that such an attack would be possible, and while no exploit of this\nbug was ever created, it could have had huge consequences if it ever was.\nAdditionally, between when the vulnerability was introduced and its fix,\nthe subsystem was moved around, allowing the bug to hide longer than normal.\n"},{"id":152,"cve":"CVE-2010-3415","project_name":"chromium","description":"The Geolocation module was causing memory corruption to occur\ndue to it being able to write to a location outside the intended boudaries\ngiven.\n","mistakes":"A few design mistakes lead to this vulnerability happening. The issue was storing an object\nin an inccorect place, then when they were to be accessed they had old values. This\ncould be prevented by a simple code or design review.\"\n"},{"id":393,"cve":"CVE-2011-2845","project_name":"chromium","description":"An attacker can use this vulnerability to spoof the value in the URL bar. This means the victim could be rerouted to a different website, but still see their intended address in their URL bar.  This only occurred when navigating to a different area of the same page, known as a page fragment.","mistakes":"The mistake here was that there wasn't proper communication between the NavigationController and the Renderer.  Since the NavigationController needs to communicate with the HistoryController to figure out where to go when the user presses the back button, this allowed time for a race condition to form that confused the NavigationController into allowing stale entries."},{"id":1226,"cve":"CVE-2016-1640","project_name":"chromium","description":"When a chrome user tries to install an extension from a website, that\nwebsite could redirect to another website and still show the extension installation\ndialogue started from previous website.\nFor example, a crafted website could show a link to install an official\nextension from some service say Google, and when user clicks on it, the chrome\nwill take you to the Google support page and will be prompted with an extension\ninstallation dialogue initiated by the crafted website. The presented extension\ncould be a fake extension intended to be an attack. The user would think it's official\none given that user is on the official support website. The dialog doesn't show\nthe origin, so it gives even more credibility to the attack.\nPoor design decisions led to this vulnerability. This vulnerability would not have occurred in the first place\nif they had thought about showing the origin of the install dialog and considered killing the dialog when redirected to different website.\n","mistakes":"I believe this vulnerability has to do with design and requirements mistakes.\nIf requirements had mentioned that this behavior shouldn't have been allowed, the code\ncould have been implemented that way. However, I can understand it's impossible\nto think about all the scenarios on requirements. So, that's why if proper design\ndecisions were made regarding how to handle such scenario when user navigates to different\npage or when user is redirected to different page.\nBased on bug report, it seems like they had made better design decision for next version of Chrome.\nThis vulnerability needed medium-level security attention because the install dialog\ndidn't show the origin and users could be tricked into installing malicious extensions. So, the initial fix seemed like a hack,\nwhere they were simply trying to mitigate this problem for now. Second fix improved the previous fix however.\nThe final solution for this was to redesign the architecture of how the dialog is shown. A comment on the bug report indicated that\nthey were planning to redesign the dialog, so looks like they knew the proper mitigation for this problem.\n"},{"id":1254,"cve":"CVE-2016-1668","project_name":"chromium","description":"The custom layout web framework that chromium (Blink) creates a global proxy\nobjects which changes its type during runtime. When it changes, it\nbypasses Same Origin Policy (allows one web page to access data/resources from\nanother webpage as long as they have the same origin), which can allow\nmalicious attackers to run arbitrary JavaScript code to access private\nresources.\n","mistakes":"This vulnerability occured when the original creator of Iterable.h had a\nsimple coding mistake, didn't fully understand software engineering\nsecurity, or didn't fully understand how to work and code with v8 objects.\nIt was a line of code that got the job done but came with security\nimplications if used correctly by a malicious attacker.\n\nThe lesson learned from this vulnerability is fully know and understand\nthe objects that you're working with, and to have defense in depth.\n"},{"id":1023,"cve":"CVE-2014-7935","project_name":"chromium","description":"The tts_message_filter.cc file in versions of google chrome before 40.0.2214.91 had a vulnerability that would\ntry to use memory immediately after it had been freed. This would allow attackers to\nuse the text to speech utterances to crash a user's current tab in google chrome and possibly\nexecute other attacks such as executing remote code.\n","mistakes":"After looking at the fix in the code, this is obviously a coding mistake. It is a coding mistake\nbecause they used the weak_ptr class to prevent a UAF, but the weak_ptr class was the part of the code\nthat was allowing the use after free vulnerability to occur. If the team had done more thorough\ntesting with their unit tests and their automation tests, I believe that they would have found this\nvulnerability a lot sooner. Looking at the possible mitigations for the CWE and the fix for the code,\nthey didn't change their code language or set their pointers to null after being freed. The second one\ncan be excused though because it uses a complex data structure.\n"},{"id":492,"cve":"CVE-2011-3092","project_name":"chromium","description":"The vulnerability was in Google's Javascript Engine, *V8*, in the way they\nhandled regular expressions (\"regexes\").\n\nThe implementation, which was in Javascript but called native C code, didn't\nhandle \"capture overrides\" properly. This resulted in data be written to\nmemory that it was not intended for (an \"invalid write\"). At best, this causes\na crash. At worst, this kind of vulnerability can lead to arbitrary code\nexecution as it is a \"buffer overflow\".\n\nThe way that this could be exploited would be if an attacker had access to\nwriting Javascript. This is possible in a Cross-Site Scripting (XSS) scenario,\nor if someone simply went to an attacker's page with Javascript that exploited\nthis vulnerability.\n","mistakes":"The coding mistake that was made was essentially an integer overflow that\nled to miscalculating memory buffers. The mistake was not in the underlying\nnative code, rather, it was misusing the C API. So the fix was actually in\nthe Javascript implementation of regexp.\n\nThe vulnerability was introduced over two commits, but really by one person\nwho was working on trying to fix this boundary condition. He wasn't\nworking on a vulnerability per se, but they were working on a boundary\ncondition and still missed this one condition.\n\nFor this part of V8, a lot of decisions have been made about changing what\nis handled natively and what is handled in Javascript itself. Navigating\nwhat exactly are the responsibilities of native code versus the built-in\nJavascript libraries is going to be the key to preventing vulnerabilities\nhere.\n"},{"id":131,"cve":"CVE-2010-3117","project_name":"chromium","description":"Chrome crashes on shutdown due to the notification UI manager not being closed early enough.","mistakes":"The issue ultimately stems from not having kept track of the lifespans of an object's dependencies when modifying the object's own lifespan. Additionally, the impact of the issue was enhanced by it providing a potential sandbox escape for an attacker, which didn't need to be the case.\n"},{"id":1284,"cve":"CVE-2016-1698","project_name":"chromium","description":"The function that allows an extention to create a custom type,\ncreateCustomType, doesn't actually validate the module type. \nSince the type isn't ever validated, there's the risk of \nloading in arbitrary modules and disclosing sensitive \ninformation to the attacker because the definition of the module\nwas not handled properly.\n","mistakes":"There was a big design mistake in allowing the use of multiple types \nwithout validating what types are actually safe when initializing. \nOther parts of the code depend on the setup to work exactly as intended,\nand, without this validation, other parts of the code won't work in\nthe way that they should. While this fix is hard-coded, the addition\nof a whitelist is a huge step in the right direction. There could be\na better way to implement this whitelist rather than a hard-code \nwithin the type creation, however, although keeping that data\nsecure is very important.\n"},{"id":1043,"cve":"CVE-2015-1209","project_name":"chromium","description":"A crash can be forced from crafted java script that can be exploitable. The\ncrash occurs in Chromium's underlying c++ code when freed data is accidentally\nread. The JavaScript causes this crash by adding an element to the DOM,\naltering certain fields, removing it from the DOM, and then trying to\naccess or modify certain fields after the element has been removed. This last\nstep can occur in the process of removing it from the DOM without any additional\njavascript code written by a user depending on the previous steps. In other\nwords, a html file uses javascript to dynamically add an elelement to itself,\nremove it, and then continues to modify it. Once it is removed and\nyou try to access an old element, Chromium will access memory that has\nalready been freed using a bad pointer. This will trigger Chromium's\nAddressSanitizer which will then stop Chromium before something even worse\nhappens. AddressSanitizer may not have always caught the error and arbitrary\ncode execution was possible.\n","mistakes":"The mistake was not considering all of the possibilities. It was first and foremost, a design  and requirement mistake,\nbut also a coding mistake since it was designed with the possibility of freed memory being accessed.\nAdditionally, this vulnerability touched two different people through its lifecycle. One committed the original bug \nand another person fixed the bug after 11 years. The fix did not set the freed element to null, but \nthe added checks did satisfy the mitigations mentioned in the CWE.\n"},{"id":1055,"cve":"CVE-2015-1221","project_name":"chromium","description":"The vulnerability found in Google's Blink Engine allows attackers to remotely\nimpact service by referring to finalized objects using the misordering of\ndatabase thread shutdown operations. This could lead to denial of service or\nother unspecified impacts.\n","mistakes":"This vulnerability was the result a small coding mistake that create a\nlarge security impact. The fix was very simple, involving just adding a new\nfunction and function call to terminate a thread.\n"},{"id":1058,"cve":"CVE-2015-1224","project_name":"chromium","description":"An image decoder does not ensure that alpha-plane dimensions are identical to image dimensions. This allows a remote attacker to cause a denial of service attack through an out-of-bounds read.\n","mistakes":"This vulnerability was a bit of a miscommunication and design mistake. Initially, they did have support for video streams with alpha buffers larger than the image buffer, but the library changed a year after the first implementation and introduced this vulnerability. They didn't account for that and this vulnerability was introduced.\n\nThe code written to copy video data from the buffer assumed that the image and alpha plane had the same dimensions and stride (buffer width). According to the video format, the dimensions must be the same, so the writer of the code assumed valid input without doing a check. When a video plane's dimensions differed from the alpha plane, the stride was also different. The code to copy the alpha plane used the stride from the video plane, so the incorrect amount of data was read, causing the overflow. Interestingly, the strides of the video and alpha planes can differ even if they have the same dimensions. This means that a buffer reading issue may occur even with a valid VP8 video. The reviewers of the bug noticed this issue, and it was fixed along with the dimension check.\n\nTo check for malformed VP8 data, they added a check that threw an error if the alpha plane dimensions were different than the image plane. This fix adds input validation, which is the primary mitigation listed on the CWE-125 page.\n"},{"id":191,"cve":"CVE-2010-4575","project_name":"chromium","description":"A program extension created with malicious intent can close windows if installed by another user. This is\nconsidered a Denial-Of-Service and may cause an application to crash if the user completes a specific set of tasks in a\ncertain order.\nIn the case of Chromium, the user could install an extension that serves they believe serves another purpose,\nbut is meant to exploit this vulnerability.\n","mistakes":"It looks like it was simply a coding mistake that was made.\n"},{"id":1068,"cve":"CVE-2015-1234","project_name":"chromium","description":"This vulnerability was a consequence of how the GPU and the native client application\ninteract with each other. Essentially, they communicate using threads and shared\nmemory to send commands and receive return values. The problem was in a specific\nblock of code that accessed a specific resource in untrusted shared memory.\n\nThere was a race condition where multiple threads were trying to access and/or\nmodify the size of a shared resource, so if the timing between the threads was\nnot perfect, it would be possible to access this resource, validate it, and then\nlater modify it to cause a buffer overflow, which means that an attacker could\npotentially execute their own piece of code. So while there is a buffer overlow\nissue here, it is mostly the race condition that allows for this vulnerability.\n","mistakes":"I feel that this vulnerability was more of a design mistake, followed by maintainability\nissues. There is quite a bit of reliance on untrusted shared memory here because of the\nway that the different processes communicate with each other, and this is part of the\narchitecture for this application, which means it is very difficult to change. This\nreliance, combined with the complexity that comes naturally with concurrent processes,\nexposes the application to a myriad of issues that may be very difficult to identify.\n\nMoreover, there were multiple code design flaws that overlooked the atomicity of certain\noperations in the code. In other words, by looking at the VCC and comparing it with the\nfix, it seemed like the original code was using the \"easiest\" path to retrieve data in\nshared memory, even when these operations were not atomic and introduced the possibility\nof race conditions. And since this code had been present for years before the fix, it\npropagated to other parts of the system. In fact, there was even some discussion in the\nbug report about volatile memory in other parts of the code that was not identified as such,\nso this vulnerability exposed other maintainability issues that required more time and effort\nfrom the developers.\n\nFinally, the fix seems to implement some proper ways to deal with the race condition issue,\nspecifically the use of volatile type modifiers in the code to indicate the use of untrusted\nshared memory. In addition, the fix also introduces a better use of atomic operations by avoiding\nhaving to calculate, access, or write to shared memory more times than is necessary.\n"},{"id":897,"cve":"CVE-2013-6646","project_name":"chromium","description":"The implementation of a database observer causes Chrome to crash due to an invalid\npointer error when multiple databases are opened in the observer at once due to a\nscript continuously reloading from the multiple shared worker methods (scripts)\ncreated by the multiple databases. Specifically, a variable is being passed into the\nobserver after the worker's thread has already ended. This opens up a User After Free\n(UAF) vulnerability, a type of memory corruption bug that, in this case, opens up the\npossibility for malicious users to cause a denial of service attack by shutting down\nthe worker processes related to the worker methods.\n","mistakes":"Although most crashes can be attributed to questionable coding practices,\nthis one was ultimately caused by what I believe to be a design mistake:\nallowing multiple shared worker events to occur simultaneously without\nunderstanding the potential problems that could present. The fact that not\none, but two issues came up involving UAF vulnerabilities regarding shared\nworkers showed they overlooked elements of their design. This is corroborated\nby the fact that one of the developers didn't realize that the bug was\noccurring at the process exit, causing them to think the priority of the bug\nshould have been lower than it realistically was. There's even a point where\na \"class of worker bugs\" is mentioned, implying it could have been even larger\nthan just these two issues.\nWith that said, the fix does seem to be proper as the developers have fixed\nthe core issue which was understanding when the proper point to kill a \nworker process was."},{"id":192,"cve":"CVE-2010-4576","project_name":"chromium","description":"Improper handling of certain code calls allow for a denial of service (DOS)\ntype vulnerability. In this case, the DOS vulnerability is caused by a null\npointer exception which could be triggered by using crafted JavaScript code\nthat creates a web worker.\n","mistakes":"This vulnerability was the result of a simple coding mistake. The writer\ndid not include a null check. This could be avoided by more thoroughly\nchecking the input. Code reviews could also help prevent simple coding\nmistakes like this.\n"},{"id":1326,"cve":"CVE-2016-5149","project_name":"chromium","description":"To understand this vulnerability it is important to understand what an iframe is.\nIn HTML pages, there is a tag called \"iframe\" that essentially loads a different\nweb page and embeds it in its \"parent\" page, which is the current HTML document.\nThese iframes can be used for a variety of things, like embedding media into a\nweb page or embedding applets into a document.\n\nThis vulnerability is related to iframes in that it allows attackers to exploit\nthe slow loading times of an iframe to run arbitrary content scripts in the iframe's\nparent page. More specifically, this vulnerability is only related to Chrome extensions.\nIf the source URL of an iframe is set to be \"chrome-extension:// URL\", the attacker\ncan inject javascript from the parent page before the frame has loaded and essentially\nspoof chrome extensions. For instance, one would be able to access chrome extension APIs,\nsteal authentication cookies, bypass security measures, and even send fake messages to\nother extensions under the name of a legitimate extension.\n","mistakes":"I think that the biggest issue that came up during this vulnerability's life span was,\nby far, how long it took to react to it. According to the bug report it took over\n6 months to resolve this bug, which is an unbelievable amount of time for a\nhigh-severity and high-priority bug like this one.\n\nThe fix involved some simple validation and some new tests, which may indicate an oversight in the\noriginal VCC, although this vulnerability would have been difficult to predict\nsince it relied on a race condition. However, it was a severe lack of communication\nthat lead to this vulnerability living as long as it did. There were long periods of time\nwhere there was little to no effort being put into resolving this bug, which exposed\nthis application to really dangerous spoofing attacks.\n"},{"id":248,"cve":"CVE-2011-1186","project_name":"chromium","description":"Chrome on Linux had a bug where if two calls to open the print dialog to choose a printer were made in parallel, it could crash.  \nIf a bunch of print commands were issued at the same time, they might be executed in parallel.  This was a potential DOS flaw.\n","mistakes":"This one was tough to call a mistake because it was highly unlikely to occur except during debug.  Printing almost never happens concurrently, and \nit was only occasionally reproducable anyway.  The mistake was assuming that the printing was always thread safe.  They chose not to fix the issue \nbecause it would have required more work than it was worth.  Instead, they just fixed the particular issue so that it would go back to looking like it worked.\n"},{"id":919,"cve":"CVE-2014-1700","project_name":"chromium","description":"This involves a use-after-free vulnerability in the modules/speech/SpeechSynthesis.cpp\nfile of Blink, a component of Google Chrome. This vulnerability allowed remote attackers\nto cause a denial of service using the utterance data structure contained in the module.\nAn utterance is a continuous piece of speech without pause. This is fitting since it is used\nin the speech module of the Blink project.\n","mistakes":"Utterances weren't properly being ended before starting another utterance.\nThis created a use-after-free vulnerability since the utterances could still\nbe accessed even after the memory was freed. Attackers were able to take\nadvantage of this to cause a denial of service attack.\n\nThe system was supposed to be asynchronous, so that only one utterance was\nbeing used at a time. However, the next utterance in the queue would\nsometimes be called before the previous one was removed from the queue. The\nfix for the mistake involved changing the logic, so that it was ensured that\nthe system would be asynchronous.\n"},{"id":922,"cve":"CVE-2014-1703","project_name":"chromium","description":"A piece of memory in the WebSocketDispatcherHost::SendOrDrop function was used after it was freed. This file primarily deals with the creation of web sockets between the server as well as sending and recieving messages. The function in question dealt specifically with sending the message.\nBy comprimising this function, it could have allowed remote attackers to control arguments of the DeleteWebSocketHost if the memory is reallocated.","mistakes":"The issue here is pretty clearly an issue with not allocating memory correctly. This is something\nthat could have been avoided by implementing proper unit testing. The issue only really would have\nbeen detected by a fuzzer, which is how it was found. However, it doesn't appear that any effort\nwas made to make sure that the issue would never happen again; That is, no new unit tests were created.\n"},{"id":800,"cve":"CVE-2013-2842","project_name":"chromium","description":"When a frame was removed from its parent frame, it could still be referenced.  This could lead to a use-after-free error.  \nIt could cause a DOS or potentially give an attacker the ability to interact with the user's computer by breaking out of the\nassigned memory buffers into other memory locations on the computer. \n","mistakes":"The mistake was that they freed a portion of memory that went along with a frame in the renderer, but they did not remove all references to it.  \nThe fix was to check the frame before it was used to make sure that it had not been freed yet.\n"},{"id":1117,"cve":"CVE-2015-1284","project_name":"chromium","description":"This vulnerability is caused by the blink functionality of Chrome not checking\nfor exceeding the maximum frame amount after the amount has been set. This allows\nan external attacker to create a denial of service attack by creating more than\n1024 frames which reads from memory after being freed.\n","mistakes":"The mistake that lead to this vulnerability was checking the value in the\ninput then storing the value in the input, instead of the other way around.\nThis allowed an attacker to create a script with more than 1024 frames which\nis more than the system allows for and would try and access memory after it\nhad been freed and crash. This creates a denial of service. This is a coding\nmistake which should be caught with code review. The fix looks proper because\nit adds a check with security consequences rather than just checking the input.\n\nThe potential mitigations for this CWE are to choose a language that provides\nautomatic memory management, which isn't really an option in this case. The\nother mitigation is to set pointers to NULL after freeing them, however, the\nfault that results from this is part of the vulnerability.\n"},{"id":1127,"cve":"CVE-2015-1295","project_name":"chromium","description":"When opening a PDF file into chromium, the client would pause for the few seconds and give a message. Upon hitting OK or escape, chromium would crash. This was due to the program not handling ICP correctly.","mistakes":"The vulnerability seemed to be caused by a lack of managing input. Because the file didnt' correctly handle nested ICP people were potentially able to cause crashes by printing out messages. The vulnerability alone was already causing issues alone just by a user loading up a specific file. In short, always make sure your design is able to handle any potential input it may recieve.\n"},{"id":813,"cve":"CVE-2013-2858","project_name":"chromium","description":"There is an vulnerability in versions of Google Chrome before 27.0.1453.110 where\nthe HTML5 implementation of audio would try to use memory immediately after\nit had been freed. This would allow attackers to crash a user's current tab of Google\nChrome.\n","mistakes":"I believe that this was a design mistake on the part of the team, after looking at the fix and the vcc and what was changed.\nIt seems as if the team never thought that someone would try to programatically change the audio source, so they had to redesign the client implementation of the web media player to\ninclude a mutex and other states to make sure that the memory is not being used immediately after it is freed.\n"},{"id":18,"cve":"CVE-2009-1414","project_name":"chromium","description":"Google Chrome 2.0.x allows for global objects to persist across page transitions, allowing for easier Univeral XSS attacks. Launching Chrome with a URI doesn't overwrite gobal variables on asynchronous load of pages\n","mistakes":"Coding mistakes in conjunction with code rot resulted in improper argument parsing allowing for code injection. The use of URIs for launching Chrome required a URI parser that allowed for misuse of Chrome though the lauching of unspecified pages by an outside script. Due to this unintended access the use of Chrome URIs was deprecated and removed in the fix\n"},{"id":1140,"cve":"CVE-2015-1361","project_name":"chromium","description":"This vulnerability was in Chromium's third party tools for image decoding.\nIt consisted of an uninitialized variable being utilized in a constructor\nand was found automatically by a \"fuzzer\", a static code analysis tool\nthat analyzed the code and identified the issue.\n\nIn a general sense this vulnerability can lead to things like crashes when\ntrying to utilize a segment of code that calls upon the unitialized value.\nHowever, in this case the uninitialized value was initialized in the\nconstructor of the class it was being used in making this functionally\nan optional variable in its usage. There was literally no impact in\noperations the only thing is that any static analysis tool would have been\nunhappy.\n","mistakes":"This vulnerability is simply a coding mistake and a very simple one at\nthat. Any static code analysis tool should have picked it up and I assume\nthe only reason it was not fixed for so long is because it literally had no\neffect. The uninitialized value was initialized in the constructor of the\ngiven class making this functionally an optional variable in its usage.\nThere is literally no impact in operations the only thing is that any fuzzing\ntool will pick this up and be unhappy. The developer of the fix even says its\nsimply to prevent tools from picking on it in his comment \"initialize m_hasAlpha\nto some value before calling the operator lest any tools complain about using\nan uninitialized value\". There are no mitigations beyond pay attention when\ncoding and be sure to initialize all variables.\n"},{"id":212,"cve":"CVE-2011-0485","project_name":"chromium","description":"Speech data input not properly handled. When unspecificed speech data is processed with speech input disabled,\narbitrary code can be executed, creating pointers to freed memory, aka stale pointers. Attempts to use stale pointers\ncan crash the system, and cause unexpected behavior.\n","mistakes":"The mistake here was not handling the case when a feature was disabled or not intended to function, and accepting\nany input when at least part of the input can be expected to be finite. Part of the solution was to whitelist a portion of the input,\nas recommended as a mitigation strategy.\n"},{"id":9,"cve":"CVE-2008-6998","project_name":"chromium","description":"Google chrome had a problem when a user typed in more than 128 chars in the url, \nthen hovered over the url. The url preview should show up but the backend array \nthat held the url typed in would overflow and shut the system down. It could also \nlead to users getting a pointer to the current method. Then telling the code to go \nsomewhere the attacker's code is planted and run arbitrary code after the system crashes. \n","mistakes":"This was both a design and coding mistake. I think this was a design mistake because they \nhad other overflow problems that followed with the commit of the url overflow problem. So \nthey were missing a crucial check of array size in their code. Which means they were overlooking \nthe problem entirely. This could also fall into the category of coding mistakes because nit pick\nerrors don't really belong in the design phase.\n\nSome extra fixes they should add are making sure the user inputs are always checked with white \nand black lists. This will solve problems before they even come up. Solving the problem as they \nshow up when the system is released is much harder to spot all the errors. Implement the checks \nand input validations as they were programming. \n"},{"id":216,"cve":"CVE-2011-0779","project_name":"chromium","description":"Google Chrome does not properly handle a missing key in an extension, which\nallows remote attackers to cause a denial of service (application crash) via\na crafted extension.  When an extension is packaged, the extension is assigned\na unique key pair. The extension's ID is based on a hash of the public key.\nThe private key is used to sign each version of the extension and must be secured\nfrom public access.  A variable that gets initialized in the extension unpacking\nservice is sized based off of the extention's header signature size, so if a hacker\nremoved the signature (by providing an empty key), it would get initialized to zero\nand cause a crash of the system since it was unexpected, leading to a denial of service.\nBasically, the bug was introduced in the process of refactoring the code to pull the\nlogic for unpacking extensions out of a service that was too complex, and the writer of\nthe new file to handle the new logic forgot to check to make sure that a variable being\ninitialized would not be initialized to 0 bytes.\n","mistakes":"There were many other tests being performed in the code around the header size, a\ntest to check if the header was size zero was never included however.  As far\nas I could tell the author of the code was refactoring a large portion of the\nsystem.  What they could have done better was to not assume user provided\ncontent was not any range of unpredictable values (like 0) (the header is\nattached to an extension which can be developed by users).  However, because\nother checks were in place in the code to check the header size, I think that\nthis edge case should have been considered by the team too.  Especially when\ninitializing a variables size, some checks should always be if the size is based\non some kind of user driven input.  If the size is driven on user based input,\ncould the user find a way to provide a huge value (overflowing a buffer), or\ncould the user provide a negative value, or even a zero value.  The team should\nhave checked all three use cases rather than just the max size case.\n"},{"id":1165,"cve":"CVE-2015-6765","project_name":"chromium","description":"An attacker could have the url that is being accessed\nto be deleted hence causing the browser to crash. If a user is accessing\na url/link, in this case, it would crash due to the same. This is caused by an error in storing\nentries and fetchers allows attacker to overload the pending list of entries and crash the browser,\nwhile running fetcher allows for UaF (user after free). This vulnerability is also known as the browser\ncrashing bug.For example, referencing memory (say a link) after it has been freed (deleted/destroyed)\nwould cause the browser to crash.\n","mistakes":"This seems to be another one of those mistakes that developer forget to have a complete\ntest plan on. I would say more of a design mistake with a mix of requirements and coding.\nThis is a critical vulnerability and the developer should have been more aware of these\ncases when thinking about the tests plan and the design of the system. This can lead to\nsome serious issues.\n"},{"id":969,"cve":"CVE-2014-3166","project_name":"chromium","description":"Provided with this vulnerability, attackers would be able to leverage multiple\ndomains to access sensitive information. Pooling with multiple domains allows\nan attacker to bypass Public Key Pinning (PKP) on sites. By bypassing PKP on\nsites this opens up an information disclosure vulnerability. Examples given \nshow that it was possible for a malicious actor to pretend to be any website \nby exploiting this vulnerability. For example, the reporter provides a \nscreenshot, demonstrating that www.twitter.com was displaying their own\ncontent rather than the real twitter site.\n","mistakes":"The main mistake that lead to this vulnerability appears to be an oversight\nin a check to allow invalid certificates to become pooling candidates. There\nare two levels at which this mistake could have likely taken place. Firstly,\nthere these checks, it seems, had been thought about before, but nonetheless\noverlooked. Poor documentation of risks/requirements at the team management\nlevel could be to blame here. And secondly, at the coding level if the\ndevelopers had had this issue in mind, they would have likely accounted for\nit when it came up, before.\n\nThe fix for this vulnerability follows the CWE potential mitigation. That is\nto say, in separating/centralizing the checks that is separation of\nprivilege. However, this isnt exactly directly significant to this specific\nvulnerability.\n"},{"id":972,"cve":"CVE-2014-3169","project_name":"chromium","description":"A piece of data in core/dom/ContainerNode.cpp, which is used in Chromes blink web engine, \ncould allow remote attackers to cause a denial of service under certain conditions \nas well as have other effects by messing with script execution before the node removal. This\nfile is used as a part of Blink's Domain Object Model, which incorperates the brower's logic when\nstoring amd displaying HTML/CSS.\n\nThe team never really seemed to pinpoint the actual issue here. They only pinpointed the\nsolution it seems. That is, they never were able to reproduce the actual bug.\n","mistakes":"As I said above, its hard to discern what actually caused the issue since they never really pinpointed where the actual bug was. This was a simple coding mistake though, one that likely could have been avoided with proper unit testing. However, it did provide a useful enough error message that it was able to be fixed.\nI think the biggest issue here would be that it seems like this bug was identified beforehand, but was not inserted into the proper workflow to get it fixed and so it never was. This bug could have potentially never been found had the fix been submitted as separate issue when it was originally found."},{"id":179,"cve":"CVE-2010-4484","project_name":"chromium","description":"There is an improper closure of WebSQL databases\n(a web page API for storing data in databases that can be queried using a variant of SQL.)\nin incognito mode which allows the attacker to write\na script that opens the databases well over the quota limit thus causing a denial of service.\n\nAn exanple script would look like this:\n\u003cscript\u003e\n    function runTest() {\n        try {\n            var db = openDatabase('OverQuotaOpen', '', '', 10000000);\n        } catch (err) {\n        }\n    }\n  \u003c/script\u003e\n  \u003cbody onload=\"runTest()\"\u003e\n\nThe fix for this was to simply close HTML tables in incognito mode once finished. The original issue in the code\nwas that the author was actually negating the line of code for closing databases.\n","mistakes":"The mistake was not severe but it did lead to crashing the chrome browser in incognito. The mistake was\nprimarily a coding mistake by forgetting to take off a negation applied to closing an HTML database after use.\nThe fix was very simple and the vulnerability was mitigated by freeing up the memory. In this case the freeing\nwas more so \"closing\" the database after it was called. The issue was more of a human error by including a\nnegation where there was not one needed.\n"},{"id":1183,"cve":"CVE-2015-6784","project_name":"chromium","description":"Chrome offers a feature that allows you to download web pages to your local\nmachine, and later open those webpage files off of your local machine. When you\ndownload a webpage to do this, chrome adds a comment at the top to show the\nurl that the page was downloaded from. This url is not escaped when it is\nadded to the document, therefore an attacker can construct a url that contains\ncode that can modify the page or exfiltrate data from the page.\n","mistakes":"The major mistake made is that input was accepted from a user and added in\nto a document without being sanitized. It is important to think about what\ntypes of input could cause problems and sanitize for those. Always consider\nabuse and misuse cases when you are dealing with inputs that are coming from\noutside of the boundary of trust of the application.\n"},{"id":183,"cve":"CVE-2010-4488","project_name":"chromium","description":"This bug involves an unhandled case in which the user is behind a proxy and the\npage they are requesting returns a 407 error (proxy authentication required).\nChrome did not handle this situation, causing the app to crash. Exploitation of\nthis could ultimately cause a denial of service on the chrome app.\n","mistakes":"This could be a coding or design error, there was obviously no\nsystem designed for handling this case. However, when coding this, the developer\ndid not see the possibility of failure and all it took to fix this was an if condition\nto test whether the connection behind a proxy succeeded. The fix does adhere to the\nCWE mitigations and the fix does appears to be correct. However, in more recent\nversions of the file, the original fix is not present. Handling this scenario\nis still present, just in a differnt form, this makes it seem that the original fix\nwas not as rock-solid as it should have been.\n"},{"id":986,"cve":"CVE-2014-3190","project_name":"chromium","description":"A use-after-free vulnerability present in the currentTarget function on Event objects with the core/events subsystem in Google Chrome allowed remote attackers to cause Chrome to crash or have unspecificed other impacts via Javascript code that would access the source of this vulnerability. An attacker would be able to construct vectors and infect Chrome user's browsers remotely via download of a simple javascript program from a visited website. The result would be a Denial of Service attack, preventing the user from accessing any functionality in Chrome.","mistakes":"The coding mistake that was made was essentially returning a raw pointer to memory, rather than a reference.\nUsing the raw pointer to access the corresponding object after that memory had been freed resulted in a\nmemory violation and application crash. This mistake could have been avoided by having a stronger sense of awareness\nfor the existing functionality of the subsystem being worked in. Simply knowing that the value being returned was a raw\npointer to memory could have inspired a more defensive programming approach.\n\nThere seemed to be a bit of an issue in terms of team communication. The original author of the code that\ncontained the vulnerability was still on the team at the time of the commit, but seemed reluctant to admit\nthat the vulnerability that was reported could be a cause of their code. A different team member took\nover the bug fix after a supervisor had asserted that someone needed to claim responsibility for the bug fix.\nThe supervisor seemed irritated that a major security vulnerability took over a month to fix after being\nfirst reported.\n"},{"id":987,"cve":"CVE-2014-3191","project_name":"chromium","description":"An object called RenderLayerScrollableArea called into method updateWidgetPositions, which\nperformed various layout and style updates to render.\nDuring this process, an object called RenderLayer was destroyed; this object was the parent of the RenderLayerScrollableArea\nand another object (ScrollAnimator).  After the layout and style updates finished, the code\nattempted to have the now destroyed RenderLayerScrollableArea object call a method \n(updateCompositionLayersAfterScroll), causing a memory error since the render tree had been destroyed.  Exploitation of this\nvulnerability may have resulted in DoS due to program failure.\n","mistakes":"Based on the discussions between the developers in the bug reports, it sounds like this\nvulnerability was not considered initially because it occurred so far down the call stack.  The\nfailure to consider what might happen if the render tree is able to destroy itself from the inside\nout was probably a design failure; consideration of misuse/abuse cases may have helped catch this\nvulnerability earlier.\n\nThe initial fix for this vulnerability (in the first bug 322891) was insufficient, as the developers\nsimply added an assert to attempt to catch the use-after-free.  In the notes on that bug, it seems\nthe developers intended to improve this solution in the future, but did not get to it until this\nvulnerability occurred a year later.  The new fix moved the call causing the destruction of the object\nin the use-after-free, which was more appropriate.\n"},{"id":391,"cve":"CVE-2011-2843","project_name":"chromium","description":"Chrome wasn't handling media buffers correctly. The media buffer was reading out of bound values. \nAttackers were able to cause denial of service through vectors. The avcodec_open\nmethod read past the allocated memory. This was fixed by over allocating the source buffers. This fix\nwould cater for the chunked nature of the get_bits() function. Developers acknowledge\nthis as an ugly solution but was necessary for the function.\n","mistakes":"A design and coding mistake resulted in this problem. If they accounted for the size of FFPmeg videos \nthen they could have predicted the possibility of a buffer overflow. In order to prevent\nthis vulnerability they could've done a detailed review of the FFPMeg data. Such review\nwould forsee a possible buffer overflow.\n"},{"id":1295,"cve":"CVE-2016-1709","project_name":"chromium","description":"Attackers could cause a Heap-based buffer overflow in sfntly. sfntly is a program that lets users create and edit custom text fonts. The buffer overflow could be used for denial of service attacks.","mistakes":"A very basic coding mistake caused this vulnerability.\n\nThe 'Get' function did not check if the index was within the array bounds.\n\nOther functions check if the index was in array bounds\nbut the developers forgot to add the check to the 'Get' function\n\nThis caused the Buffer Overflow errors in the sfntly subsystem.\n\nThis vulnerability has been in the sfntly subsystem since its first release, but\nit looks like the developers had bigger bugs to fix and new features to add\n"},{"id":1349,"cve":"CVE-2016-5174","project_name":"chromium","description":"On a browser window, toggle requests go unprocessed which allows attackers (remote sites) to create unsuppressed popups causing a DOS (Denial of Service) by spamming the browser and causing it to crash. Fullscreen mode would also get stuck and you are unable to leave it.","mistakes":"The origin of this vulnerability is the lack of input validation from the remote target site. In certain conditions, the remote site was able to push popups on to the user's browser, and have them open without asking for user's consent. This, lack of input was due to improper handling of a particular use case in that Flash objects were not filtered for popups and therefore they opened forcibly. By doing this, the user is let vulernable to DOS attack (by spamming the host browser) and redirects to malicious sites. This is likely due to missing security requirements of \"Flash\" popup handling or the following of yagni principle. The fix, follows the mitigations by CWE. However, I noticed that the fix is only partial. It has resolved the issue of the fullscreen being stuck but popups remain unhandled, which leads me to believe that proper mitigations were not followed and the fix is not proper.\n"},{"id":1220,"cve":"CVE-2016-1634","project_name":"chromium","description":"A JavaScript script creates an input element inside a form element and adds them to the DOM (web page),\nthen forces a style recalculation and removes the input from the form element. Due to the\nsynchronous order of execution that should have been asynchronous, it would cause a use-after-free\nerror. This occurs becausehere a memory address that has been freed is attempted to be accessed, because the style\nrecalculation and element removal are executed in the wrong order.\n\nThis vulernability exists in the third party WebKit source.\n","mistakes":"There seems to be a design/code mistake in the processing of the DOM operations.\nOoperations that should be handled in the correct asynchronous order were handled\nsynchronously which allowed for operations to occur in an invalid order that caused the\nuse-after-free error. The mitigations offered on the use-after-free CWE suggest using a\nlanguage that offers automatic memory management. For WebKit, performance is key so the use\nof C++ makes sense, whereas using a language that manages memory automatically would\nhinder performance too much. Therefore, it's not a valid mitigation or one that the WebKit team\npractices. The second mitigation suggests setting pointers to NULL after freeing them.\nBased on the results of the vulnerability's exploit case, it seems that this was not being\npracticed in the code. I was not able to find a concrete example in the code\ndue to its complexity.\n"},{"id":1307,"cve":"CVE-2016-5130","project_name":"chromium","description":"A third party dependency doesn't properly handle the forward behavior in their\nbrowser (\"-\u003e\"). This vulnerability gave attackers the ability to hijack the\nbutton, and send users to a link they didn't retreat from using the back\narrow (\"\u003c-\").\n\nThis was an interesting problem because in a way, the spoofing vulnerability\nleads to a denial of service, because whatever chrome is supposed to forward\nto, it is not. The website it is supposed to navigate to is not reachable\nthrough that method, or you can forward to a page that you didn't previously\nvisit.\n","mistakes":"The mistake was simply that they used a third party dependancy that had a\nbug that could lead to spoofing from falsifying the forward button. The\nmistake occured because the developers didn't have an understanding thorough\nenough to know the consequences of using the Blink package. I would consider\nit to be a design/coding mistake.\n\nThe mitigation provided was for the design/architecture section; the\nmitigation is to carefully address permissions for users of the system. It\nseems that the approach of chromium's solution is to more carefully manage\nthe behavior of the forward arrow itself, by resetting it, and clearing\nchildren when appropriate.\n"},{"id":1257,"cve":"CVE-2016-1671","project_name":"chromium","description":"Google Chrome on Android mishandles / (slash) and \\ (backslash) characters,\nwhich allows attackers to conduct directory traversal attacks via using a file\ncontaining URLs.\n","mistakes":"To begin with, it was a coding mistake where the developer did not check for\nspecific escape characters (i.e. slash and backslash). The fix was pretty\nstraightforward in the escape.cc file.\n\nThe vulenrability was introduced when some new logical checks were being\nimplemented. The developer mishandled / (slash) and \\ (backslash) characters.\n"},{"id":190,"cve":"CVE-2010-4574","project_name":"chromium","description":"The pickle function in google chrome and chrome OS perormed pointer arithmetic\nimproperly on maliciously crafted pickle data.  This allowed an attacker to \nmodify some system files without control of what they were modifying or execute \na denial of service attack.\n","mistakes":"Coding mistakes.  The issue that caused this is easily overlooked in the\ndifference between 32 and 64 bit systems.  there was a hardcoded offset \nfor pointers that worked in 32 bit systems however tis offsetwas larger\nin 64 bit systems.\n"},{"id":406,"cve":"CVE-2011-2858","project_name":"chromium","description":"The vulnerability was in a function called HandleDrawArrays inside the gpu \nsubsystem, which handles rendering. The function HandleDrawArrays was not handling \nproperly triangular arrays. Triangular array is where the length of each row is one \nmore than the last. The problem was caused by not properly handling conversion between\ntypes that can only hold positive integers (unsigned) to types where the integers can be \nboth positive or negative (signed). This caused the function to access values in the arrays \nthat was not there, which is an out-of-bounds read on the array. This caused an error that\nprevented services from running.\n","mistakes":"The vulnerability was caused by an improper conversion from unsigned to signed. This \nresulted in an out-of-bounds read on the array that was given, which gave an error and \nled to the code crashing. \n\nFirst, I noticed the class the vulnerability was in is massive. They started migrating classes that were inside the \nclass to outside classes. Additionally, I also noticed that one person worked a lot on features that was related to \nthis class and ultimately caused the vulnerability. There was unit tests, but it did not catch this vulnerability. \nTherefore, having better tests might have caught this bug. \n\nThey mitigated the vulnerability by updating some functions and casting the values inputted to ints.\n"},{"id":1131,"cve":"CVE-2015-1299","project_name":"chromium","description":"There was an issue with timers being removed and the reference to the timer being used.\nTimers were set up so that they lived in a heap. The problem with this is there\nwas logic that ended up freeing/removing a timer, due to a bad conditional. This conditional\nattempted to compare an 80-bit integer with a 64-bit integer. This would cause\nthe program to update the heap and make a duplicate timer. Eventually, the timer would\nbe deleted but the 'duplicate' (which is a pointer to the original) would be used.\n\nThe fix was a complete overhaul of the timer file. Remove all references of a heap\nto use a more reliable scheduler.\n","mistakes":"The vulnerability was a complex issue that never really led to a defined solution. It\nstarted with the fact they made the decision to create a heap and use that for a scheduler.\nThis is an issue because it was not needed and added a good amount of complexity which makes\nsecurity more difficult. In addition, it was in a relatively unpopular area with only a few people\nbeing familiar with the section. This allowed for the bug to exist for quite sometime after it was first found.\nThe next issue was the fact there were no unit tests until AFTER the solution was found. This allowed\nfor plenty of findable mistakes to pass through (as many as three). Lastly the way they came about a solution\nwas very problematic. It looked like from the git history they did not properly test their solution in the\nsystem. as a whole. so it led to four reverts. This could stem from the fact that instead of investigating\nfor the specific solution, they just wiped the entire subsystem.\n"},{"id":47,"cve":"CVE-2010-0644","project_name":"chromium","description":"In Google Chrome when a SOCKS 5 proxy server is configured, DNS queries should\nbe forwarded through a SOCKS 5 proxy. In this specific version, DNS queries\nwere performed from the local network instead. This could allow for remote DNS\nservers to obtain sensitive information about the identity of the client user\nvia requets logging.\n","mistakes":"When a user sets up a proxy like SOCKS 5, they expect to send all their data through\nthat secure line. Google Chrome didn't configure itself correctly to use it by default\nresulting in users believing they set it up, but in reality they were still sending their\nip to the DNS servers.\n"},{"id":1217,"cve":"CVE-2016-1631","project_name":"chromium","description":"The vulnerability was in Google's Flash Player module, *Pepper*, in the way the\nFlash Message Modal (basically windowless pop-ups) handled nested modals.\n\nThe implementation did not suspend script callbacks or resource loads inside\nthe nested modal box. As a result, cross-origin documents could be loaded from\nan arbitrary Javascript execution point. This vulnerability bypasses the Same\nOrigin Policy and could be used to cause denial of service, loss of sensitive \ninformation, and execution of arbitrary code.\n","mistakes":"The vulnerability was essentially a design mistake that gave nested modals\nthe privledge to bypass the Same Origin Policy. It is interesting that the\ntwo methods used to mitigate this vulnerability were in the repository for \nsix years before it was discovered. \n\nIt's possible that there was a similar vulnerability that was found in the \npast. It's also possible that similar functionality was implemented in a different\nsystem by a developer who may have had more knowledge or awareness of security.\n\nIt appears that trust boundaries were drawn, but not around all of the components\nthat may cross it. Proper analysis of the architecture is really the only mitigation\nagainst this kind of vulnerability. Since this vulnerability was found by someone\noutside the Chromium team, it is unclear if this has been done.\n\nThe lesson to be learned here is that discovery of a vulnerability such as this warrents\nan audit of existing subsystems that may also be susceptible the same vulnerability. This could \nbe done with a fuzzer or by manual inspection of the code and design.\n"},{"id":1020,"cve":"CVE-2014-7932","project_name":"chromium","description":"This vulnerability refers to an attacker that attempts to access memory after it has been freed. \nThis could cause the program to crash or could allow for full remote code execution capabilities. In\nthe case of this vulnerability consequences such as denial of service or pending updates of detached \nelements could happen. This vulnerability is found in the Element::detach function in core/dom/Element.cpp \nin the DOM implementation in Blink which is found in Google Chrome versions before Google Chrome version 40.0.2214.91.\n","mistakes":"The main mistake that lead to the vulnerability was trying to update an\nelement that was trying to detach and free its memory.\nI believe it was mainly a design mistake in the code itself. This is because\nan element is scheduled for an update while being detached. The code just needed to \nbe moved for the element to update after the element was detached. The fix was simple it\njust wasn't dealt with for quite a bit of time after it was discovered.\n"},{"id":55,"cve":"CVE-2010-0656","project_name":"chromium","description":"Webkit, if given a false directory in the URL section, will show a page that displays \ndirectories on the server in response to the XMLHttpRequest for a file that's actually a directory. \nBased upon the XHR requests to chrome browser. This allows the attacker to scope out the server's\nfile system leading to other exploits.\n","mistakes":"The origin of the bug is not really a commit or code error but a structural issue. Other browsers\nsuch as Safari got away with not allowing local directory access by denying any file directory access \nfrom URLs. \"The patch for this was added to WebKit (webkitgtk 1.2.0 contains this change), but the \nproblem depends on browser's ability to generate local directory listings.\" (Tomas Hoger). This fix was\nan implementaion of a mitigation rather than fully blocking a security risk. It was mitigated rather than \nblocked so that the availability or usability was not removed in the directory listing sense.\n"},{"id":1022,"cve":"CVE-2014-7934","project_name":"chromium","description":"A user was able to crash Chrome by executing a complex series of JavaScript \ncommands. This crash was caused by a used-after-free issue. By accessing memory \nno longer available, the program crashed and generated a sensitive crash dump.  \n","mistakes":"This vulnerability was simply a rare abuse case that broke an assertion in the style \nrendering of WebKit. This vulnerability appears to have been present as far back as \nwhen Google forked the WebKit repository from Apple. When blamed, the original code's \nlast author was an Apple engineer, at least 5 years before this bug was identified.\n\nThere was not much in terms of design or coding mistakes that were made. This vulnerability \nwas an extreme edge case, however, the Google engineers appeared to have some issues finding \nthe correct patch for this. Some commits were made, but were then later reverted because \nthey either did not fully solve the problem, or they broke more features.\n"},{"id":1105,"cve":"CVE-2015-1272","project_name":"chromium","description":"Heap use after memory freed in Chrome content renderer and GPU. The vulnerability\nallows remote attackers to deny service to the victim and can possibly allow\nunintended code execution.\n","mistakes":"The vulnerability here was an oversight in terms of properly freeing up \nmemory. The fix was to modify the way a GPU channel was being destroyed by \nverifying it is always on the main thread and to properly handle channel's \nNULL state.\n"},{"id":875,"cve":"CVE-2013-6622","project_name":"chromium","description":"The vulnerability was a \"use-after-free\" bug in the fork of WebKit used by\nChrome. The engine provides the ability to move elements between documents,\nand frees the memory used by the element in the first document before moving\nthe element to the second document. It was found that, with a certain timing,\nthe freed memory used by the element in the first document could be loaded\nafter it was destroyed, creating a potential denial of service.\n\nTo fix this vulnerability, tweaks were made to how Chrome tracks the load\ndelay. Rather than checking if the old document is present when the original\nload delay occurs, the method was changed to make checks between the old\ndocument and the current document mutually exclusive. In addition, if the old\ndocument is present, the load delay of the document is increased to ensure\nthat the memory cannot be loaded back into the old document. The load delay in\nthe old document is decremented now that the element in the old document is\nguaranteed to be destroyed.\n","mistakes":"The vulnerability appears to be the result of an oversight on the part of\nboth the VCC's contributor and the reviewer. Because the commit touched so\nmany files when unifying the two methods, its complexity made it hard to\ntrack smaller errors. If the commit were instead split up between separate\nfiles, this vulnerability might not have fallen through the cracks.\n\nThat is not to say they would have found the vulnerability. The\nuse-after-free vulnerability occurs because a load event can be sent to the\nold document after the element is destroyed; that would be difficult to find\nfrom the code alone. The developer would have benefited from documenting the\nprocess using comments, like the person who fixed the vulnerability would\neventually do. If they had documented the sequence of events, it is probable\nthe vulnerability would never have made it to the initial review.\n"},{"id":1354,"cve":"CVE-2016-7395","project_name":"chromium","description":"Part of Google's 2D graphic library, Skia, does not properly validate return\nvalues of a method call. This allows attackers to craft graphics data and \ncause a denial of service or have other impacts. \n","mistakes":"The main mistake the developer made in the VCC was forgetting to validate\ninput. They were most likely thinking of the expected use case and what is\nlikely to happen within the system, which is a mistake that many developers\nmake.\nIn the comments on the bug, one of the developers suggested an\nalternate fix that would deal with the uninitialized variable (the problem\nthat the fuzzer was testing for) but would not have validated the return value\n(which is where the actual bug was). Another developer pointed out that since\nthey could figure out what the actual bug was, it was worth fixing the larger\nbug. \n"},{"id":1045,"cve":"CVE-2015-1211","project_name":"chromium","description":"Privilege escalation using File System API to store worker script.\nThis should be only allowed for HTTPS or HTTP request.\n","mistakes":"Not specifying the element to trigger the Service Workers caused this\nprivilege exploit. Service Worker should not allow any other API to interact\nother than HTTPS or HTTP. This violation the least privilege principle.\n"},{"id":1408,"cve":"CVE-2017-5038","project_name":"chromium","description":"Some view based and other related javascript objects were able to inherit from\na global prototype. Such related objects include view implementations and\ncontainers. With these objects able to inherit prototypes from global javascript,\nthis could allow for arbitrary user code to be attached to these vulnerable objects.\nIf code is attached, it could be executed causing many problems.\n","mistakes":"This was a design mistake. The system was not compartmentalized to safe areas\nwhere the Guestview would be trusted with everything available to access. The\nGuestview was allowed to cross these boundaries and potentially bring malicous\ncode with it.\n"},{"id":1320,"cve":"CVE-2016-5143","project_name":"chromium","description":"There is a potential access control vulnerability in the DevTools subsystem\nof Google Chrome. The subsystem allows for a hostname and other parameters\nto be passed in by the user. The system does not sanitize the parameters\nproperly, which creates an opening for an attacker to supply their own\nhostname and parameters by passing in a specially crafted URL.\n","mistakes":"The main coding mistake here was the attempted fix of the original path traversal\nvulnerability. Sanitizing input by removing all \"../\" was a good first step, but\nwhen input becomes more complicated, the fix falls apart.\n\nI believe this vulnerability could have been avoided using unit tests. There are no unit\ntests specifically for the Runtime file, which is a concern. Sending in a complex input\nin a unit test would have shown the developer that their sanitization algorithm\nmay not be as robust as intended.\n"},{"id":281,"cve":"CVE-2011-1413","project_name":"chromium","description":"(Linux Only) A malicious user could remotely construct a relatively long string.\nUpon creating the string, the user could then use it with the javascript alert \nfunction, or use it with an input that could be displayed in an alert. As a result, \nthe display server could crash and lock up the open chrome windows on the target device, \nrequiring a reboot (Denial of Service).\n","mistakes":"The coding mistake that was made was essentially an unmanaged javascript alert\nthat was allowing remote users to create large inputs to be displayed in the alert, \ncausing both the browser and x-server itself to crash unexpectedly.\n\nWhen the vulnerability was introduced, it looks as if the boundary case of a long input\nbeing used in alerts was not being covered, allowing this vulnerability to expose itself.\n\nThe chromium team is in adherance to the mitigations documented on the CWE page for \nthis vulnerability fix. The inputs being used in javascript alerts is now being checked\nfor length, thus working around the previous crashes.\n\nFor this part of the UI, dealing with alert window width and sanitizing/validating\ninputs being used in the alerts is necessary in order to keep the linux x-server working\nas intended\n"},{"id":1208,"cve":"CVE-2016-1622","project_name":"chromium","description":"Remote attackers could bypass the Same-Origin Policy via a maliciously\ncrafted extension since the Extensions subsystem in Google Chrome didn't\nprevent use of a method to override intended extension behavior.\nThe Same-Origin policy states that web browser scripts can access data in a\nsecond web page, but only if they have the same origin. Bypassing the\nSame-Origin policy means that data confidentiality or integrity could be lost.\n","mistakes":"The CWE ID for this vulnerability is 346, and is titled Origin Validation\nError. This vulnerability was caused due to not enforcing the Same-Origin\npolicy. In order to prevent these types of vulnerabilities, a potential\nmitigation would be to separate privileges. Following the principle of\nleast privilege during the design/coding process would've fixed this issue.\nIn order to ensure this issue doesn't occur again, make sure that the\nsource is checked, and that malicious websites cannot be loaded. Preventing\nOrigin Validation Errors by testing the origin will lead to a safer system,\nand prevent attackers from gaining access to undesired functionality.\n"},{"id":1011,"cve":"CVE-2014-7923","project_name":"chromium","description":"For the Regular Expressions package used within Chromium (International Components for Unicode),\nopcodes are represented by a 32-bit Integer. The first 8 bits represent the type of opcode.\nThe remaining 24 bits represent optional parameters. \n\nOne parameter of the URX_LBN_CONT opcode requires the max length of a lookbehind regex match.\nWhen this pattern is eventually assigned to a variable, it's range was not checked. Therefore,\nif it's value was large enough, it could overflow the parameter bits and change the opcode\ntype.\n\nThis would potentially allow an attacker to execute machine code.\n","mistakes":"This vulnerability seems to be an issue of maintainability. The configuration file \nwas not updated as needed and other issues were able to be exploited from the ICU regexp engine used.\n"},{"id":773,"cve":"CVE-2013-0907","project_name":"chromium","description":"This vulnerability involves a race condition that occurs before Google Chrome versions 25.0.1364.152.\nThe vulnerability allows for attackers to remotely cause a denial of service to the system and other\npossible threats relating to threads/asynchronous threading. The race condition involves the\nVideoRendererBase object being \"destroyed\" in the main thread function. The interleaving of VideoRendererBase::Stop() with\noutstanding asynchronous calls to a VideoDecoder would result in continuing to execute code (i.e.,\nstarting up a thread without intending to) on a stopped VideoRendererBase. The most common manifestation of\nthe bug was crashing in ThreadMain() because the VideoRendererBase was being destroyed.\n\nA type of attack could happen because of the race condition allows for a temporary\naccess of shared resources where the shared resource can be modified by another code sequence\nthat is operating concurrently. This could allow an attacker to simiply modify the resource and/or\nmodify things on the page and create pop ups for the user to click and share private information,\nor cause a denial of services and could crash a chrome tab that involves a video on the page.\n","mistakes":"The main mistake made that led to this vulnerability was not using proper\nthreading practices and it caused some threads to run over each other. There wasn't\nmuch unit testing for threading and it was later detected by the crash.\nIn the future it would be recommended for maintainability\nfactors to include more unit testing on such topics like threading that are very precise and can\nhappne very easily. Overall seems like a oversight with threading was their main issue.\n"},{"id":1012,"cve":"CVE-2014-7924","project_name":"chromium","description":"The vulnerability occured when more than one cursor tries to access the same\nBLOB (Binary Large Object) in the IndexedDB, resulting in a\nheap-use-after-free error. This error occurs when a program attempts to access\ndata from a location in memory that has already been freed.\n\nThis could lead to multiple harmful exploits, include the execution of\narbitrary code or corruption of stored data.\n","mistakes":"The biggest coding mistake that was made with this vulnerability was that\nthe code never checked for duplicate pointers, or whether locations on the\nheap or in the IndexedDB were freed of their allocated memory or not.\n\nThe fix that was implemented works by limiting heap access to only one\nthread rather than two and synchronizing the mapping once memory was freed\non the heap.\n"},{"id":221,"cve":"CVE-2011-0784","project_name":"chromium","description":"This issue spawns from an audio render issue where a logic check was not being performed where an audio item was not being verified to already exist inside of a value it was being added to. This issues specifically when playing the game Z-type and crashed at one in four sound effects due to a timing issues with multiple sounds playing at once.","mistakes":"The biggest issue with the program was coding issues. Obviously when a project is implemented over multiple years, issues can appear, but the main concern here was a failure to check input and confirm it was as expected. In addition, it took a while to actually discover what was causing the issues as it was very hard to reproduce. The fix they implemented is small, but seems to prevent this issues from occuring, as the Reddit thread and the Chromium thread have not been modified in some time."},{"id":1112,"cve":"CVE-2015-1279","project_name":"chromium","description":"An integer overflow vulnerability was found in the PDF Reader process that allows\nattackers to use large height and stride values that caused memory corruption issues (memory modification). Attempting to expand an image\nto a certain size resulted in a integer overflow.\n","mistakes":"The mistakes seemed to stem largely from coding mistakes. It isn't clear but there\nwas a lot of bugs fixed inside of one large commit which is possibly because they rebased\nit into that commit. There were multiple fixes and even reverts of the intial fix which points\nto the fact that the code maybe was not tested to the degree that it could have been. The input\nfor the image maniplation affected both 64 bit and 32 bit platforms which was especially\ndangerous because it allowed for the modification of memory and the overflow vulnerabilities.\n"},{"id":574,"cve":"CVE-2011-3960","project_name":"chromium","description":"Google Chrome doesn't decode audio data properly, allowing remote hackers to cause a denial-of-service using unspecified attack paths.","mistakes":"The mistake is the fault of a lack of testing.  As the issue comes with the version of ffmpeg they were using, they should've checked if there any such issues with this particular version of ffmpeg when incorporating it with chromium through the use of thorough testing."},{"id":1114,"cve":"CVE-2015-1281","project_name":"chromium","description":"Some Chromium extensions such as Adblock Pro executed JavaScript that would break CSP (Content Security Policy) checks. Attackers are then able to load any image that they would like, and possibly use the image's request to access the user's sensitive data.","mistakes":"This is a classic case of a bug fix causing another bug, and therefore the best way to avoid situations like this is to make sure everything is properly and regularaly tested. Even though there were test in general relating to this code, there were not tests that specifically honed in on the cause of this issue, which allowed it to become a problem. Engineers may have felt rushed to fix the original bug which could have caused them to not fully consider the implications of their fix."},{"id":997,"cve":"CVE-2014-3201","project_name":"chromium","description":"core/rendering/compositing/RenderLayerCompositor.cpp in Blink,\nas used in Google Chrome before 38.0.2125.102 on Android,\ndoes not properly handle a certain IFRAME overflow condition,\nwhich allows remote attackers to spoof content via a crafted web site that interferes with the scrollbar.\n\nThis CVE allowed applications in an iframe to modify the scrollbar via css,\nallowing the iframe to spoof content on the website outside of it's actual frame.\n","mistakes":"This vulnerability came about not because of any direct mistakes per say,\nrather the fact that the iframe was able to modify the scrollbar, and use\nthat to spoof content. While this was fixed by bounding the frames overflow,\nit likely could have been fixed somewhere else.\n"},{"id":830,"cve":"CVE-2013-2875","project_name":"chromium","description":"A method in the code is changed to clear all following text boxes whenever\nit is called, and this happens whenever any underlying strings change.\nBefore the fix, the method only cleared a specific text box and did not\naccount for any following text boxes that may have references to the \ninitial one. The attackers could use uncleared text boxes to cause\ndenial-of-service attacks by attempting to read text (or other data)\nfrom the first text box which no longer exists, resulting in a \nprogram crash.\n","mistakes":"This was a design mistake (or implementation error) that would have most \nlikely been found and resolved with running proper unit tests at the time \nwhen the project was started. The memory problem is related to the language \nused to a point, as it would not have occured in other languages like Java \nand Python that have better memory allocation built in. The CWE entry does \nnot list mitigations for this error, but ensuring that it's not possible to \nwrite beyond memory in any part of the program is a solid start.\n"},{"id":1061,"cve":"CVE-2015-1227","project_name":"chromium","description":"The function for dragging an image reuslts in an improper initialization that\ncould result in unallocated memory that is then accessed. This is turn causes\na failed image decoding that remote attackers can trigger. While the\nimpact of that is unspecified the default orientation for the image cannot be\nused.\n","mistakes":"This vulnerability came from a design flaw. In this situation, the allocation of memory depended on image orientation. The if clause did seem to account for if the allocation failed. However, the state of the object allocating memory resulted in improper initialization. They should have made sure that the specific function didn't depend on that case."},{"id":1297,"cve":"CVE-2016-1711","project_name":"chromium","description":"Google's fork of WebKit, Blink, implements a loading mechanism for web frames\nthat doesn't properly prevent navigating through a frame while detaching an\nobject that helps load content and other documents into the frame.\n\nWhat specifically happens is this: starting a document load in the middle of\ndetaching a loader object will cause a new loader object to be cleared\nprematurely. If an attacker is both clever and quick enough, they can set up\ntheir own loader object and use it to load a malicious webpage, completely\nbypassing Chrome's \"same-origin policy\", which normally prevents webpages from\naccessing data from webpages that don't originate from the same place.\n","mistakes":"The main mistake made in this vulnerability was more or less a resource\nmanagement issue combined with a mistake in logic. First, detaching a\ndocument loader was not handled correctly, leading to some functionality\nremaining in the system without the normal protections against exploits.\nSecond, some of the necessary operations for detaching the document loader\neither weren't occurring at all or weren't occurring where they needed to.\nAll of this combined to make for a serious problem in the code base. It was\nalso clearly a complex issue to resolve, as it took two separate bug reports\n(and consequently two CVE entries) before the vulnerability was properly\nfixed.\n"},{"id":384,"cve":"CVE-2011-2836","project_name":"chromium","description":"Malicious websites would use the windows media player plugin to run malicious code.\nThis is because you would not be required to manually allow it to run via an infobar (popdown bar)\n","mistakes":"They knew that the windows media player plugin was a backdoor for a while, and didn't solve it.\nThe bug was open for over a month before someone took ownership and started to fix it.\nIt seems that no one took ownership of the bug because the people who new more about what a fix should be were very busy on other projects.\n"},{"id":429,"cve":"CVE-2011-3024","project_name":"chromium","description":"Some versions of Google Chrome causes there to be an empty client certificiate\ndue to an unvalidated null value. This certificate is used by the Chrome \nbrowser to make authenticated requests to the server. Attackers can take \nadvantage of the empty certificiate to bypass the hostname check for a \ncertificiate and cause a denial of service or other issues. \n","mistakes":"The mistake that was made was not inserting null checks throught the process. If one variable is passed in as null, it causes another variable to be null, which causes an empty certificate. A recommended Implementation mitigation from CWE is to consider all potentially relevant input possibilities, including empty input. The fix used this mitigation."},{"id":802,"cve":"CVE-2013-2844","project_name":"chromium","description":"Use after free vulnerability occurs when the CSS renderer attempts to use\nthe same pointer after freed causes chrome to crash. An attacker can use\nstyle resolution as vulnerability access to cause an unspecific impact.\nThis is done by placing a CSS file on the server and wait for a client to\nfall in the bait. As a consequence, memory might be accessed by something\nthat is not supposed to happen or data on Chrome might be lost. Another cause\nto the vulnerability could be a denial of service to make Chrome unavailable.\n","mistakes":"I believe it was the coding mistake because the person did not think of checking the pointer to ensure it is not freed before using it. So, it is essential to think about all cases what the pointer will do during the process even if it becomes complex. When the code becomes complex, try to apply some practices such as check if the pointer is valid or not rather than figure out all cases for the pointer."},{"id":1089,"cve":"CVE-2015-1256","project_name":"chromium","description":"A remote attacker can craft an SVG file that exploits chromium's shadow tree (a way of hiding the creation of complicated web elements).\nThe shadow tree will begin the rendering of SMIL animations, during which the SVG adds more SMIL animations to be rendered.\nSMIL animations should not be added during rendering, as it causes an infinite rendering loop that crashes your browser.\nThis is, at the very least, a denial-of-service attack and has even worse potential.\n","mistakes":"In my opinion, this vulnerability came to be because the developers that were implementing 'SVGUseElement.cpp' (the file with the vulnerability) thought they had finished writing the file.\nThey wrote all the functions necessary for this file, but simply forgot to call a particular function ('isDisallowedElement(target)') in every place it was needed.\nThey called it in 6 out of the 7 places necessary, so this vulnerability was fixed very quickly by adding an ' || isDisallowedElement(target)' to an if statement.\n\nThere are 2 mitigations for this CWE.\nThe first is choosing a language that provides automatic memory management, which is not a choice as this is written in C++.\nThe second is setting pointers to NULL once they're freed. However, this would also not apply as the malicious SVG file exhausts chromium's allowed RAM to crash it.\n\nThe fix they made is proper, which is just blacklisting which elements can be rendered (preventing special elements that reproduce themselves from being rendered)\n"},{"id":795,"cve":"CVE-2013-2837","project_name":"chromium","description":"The scalable vector graphics (SVG) library that is used failed to properly\nhandle the deletion of \"RareData\", which would sometimes accidentally delete \nmore SVG data than intended since it was modifying the data it was iterating \nover. This would cause the program to hang.\n","mistakes":"The vulnerability was due to improperly deleting data. The fix made sure \nthat the data deletion was handled correctly. The fix isn't the most efficient\nchange, but it is effective in guaranteeing that the program doesn't \ncrash or hang."},{"id":992,"cve":"CVE-2014-3196","project_name":"chromium","description":"Shared memory resources in Windows have a property known as a Discretionary\nAccess Control List, or DACL, which keeps track of who or what is authorized\nto access them, how they can be accessed, and so on. Typically, these\nresources are also given a name when instantiated. If this is not the case,\nthen Windows automatically assigns the resource a null DACL, which means there\nare no authorization controls attributed to this resource, and thus there are\nno limits to how they can be accessed, or who can access them.\n\nWindows implementations of Google Chrome occasionally use unnamed shared\nmemory resources, meaning they are susceptible to this problem. Specifically,\nthe shared memory resource is not properly restricted to \"read-only\", meaning\na clever enough attacker can bypass protection mechanisms in Windows and\nChrome's \"sandbox\" (a mechanism used to isolate potentially dangerous\nprograms) or otherwise adversely modify resources in Chrome, leading to a slew\nof unintended problems.\n","mistakes":"The main mistake made was related to an implicit security requirement\nimposed by how Windows handles objects in memory. Because some of the shared\nmemory resources were anonymous, Windows would not make them securable, and\nthus they were vulnerable to an elevation of privilege attack as described\nin the CVE entry. To prevent this, these resources had to be named.\n\nIt is clear that the initial developers were either not aware of this\nproperty in Windows, or didn't think it would pose an issue, as the problems\npresent in the code went largely unaddressed for several years.\n"},{"id":234,"cve":"CVE-2011-1113","project_name":"chromium","description":"Chrome uses a byte stream deserializer called a pickler. The pickler has a function that reads\ninformation about the header and byte stream size to read. The function was not checking the size of the header\nbefore reading the payload infomation and this could lead to a buffer overflow scenario\nif someone sent a header of the wrong size\n","mistakes":"This was a very simple mistake that developers make all the time. The original developer assumed all input to\nthis class would be good and no validation/sanitation was required. In any instance where memory is directly being\naffected, buffer sizes must always be checked and anything larger than the maximum buffer size must be\ndisallowed\n"},{"id":407,"cve":"CVE-2011-2859","project_name":"chromium","description":"This vulnerability allowed extensions to be downloaded to the chrome\nbrowser without the user's consent.  By using Man in the Middle attacks, attackers\ncould use http redirects to make a victim land on their page and automatically\ninstall a browser extension.  This browser extension allowed the attacker to \nelevate their own permissions and the permissions of other extensions on the \nvictim's system.  This resulted in unlimited priviledges.\n","mistakes":"I would say that this would be a design/requirements mistake because the paths\nthat extensions could be downloaded from included too many possibilities.  The \nformer controls they had in place were moved to the gallery urls instead.  It\nallowed extensions to be installed from pretty much anywhere once the http \nredirect was successful.  "},{"id":1052,"cve":"CVE-2015-1218","project_name":"chromium","description":"Moving a script element to a new document with the same context\ndocument removes the script completely. When moving the script to a document\nwith different context the script is in the context document, not the non-\ncontext document. This allows attackers to cause a denial of service or event\nhave other unspecified impacts that move a SCRIPT element to different\ndocuments to affect the integrity of the system.\n","mistakes":"This vulnerability was the result of a maintainability mistake. The scripts\nloaded properly on new context documents until the vcc was pushed. That also\nmeans a coding mistake was made at the point. Unfortunately, the cloudfuzz\ncouldn't detect the issue for a while.\n"},{"id":1292,"cve":"CVE-2016-1706","project_name":"chromium","description":"This vulnerability resulted from the improper implementation of PPAPI, which is\na plugin management API for Adobe Flash Player.  \nPlugins have a broker process with two methods for handling messages.\nBrokerProcessDispatcher handles BrowserOperations messages managing browser functions\nsuch as locally stored Flash cookies and camera/mic permissions.\nBrokerDispatcher handles only ConnectToPlugin messages which manage inter-process-communication \ndata for the plugin.\nConnectToPlugin messages are treated as untrusted and are sanitized and validated, but BrowserOperations\nmessages are not.  BrowserOperations messages are intended for use by the browser's settings\nUI, while ConnectToPlugin messages should be sent on behalf plugins.  The Flash renderer \nis able to send both types of messages on behalf of plugins, meaning a compromised renderer\ncan submit unsanitized data and access powerful BrowserOperations functions. The primary danger\nis that several BrowserOperations message variants include an absolute file system path\nas an argument with no validation, allowing access to local files by the renderer.  An exploit \ncould have the capability to write or overwrite local files.  The reporting user described \na potential exploit for OS-X where vulnerability is used to mount a remote file system on the\ntarget computer.\n","mistakes":"The relevant code appears to have been written by a single developer and had not\nbeen modified in almost two years when the vulnerability was found.  The presence of\nthis vulnerability appears to be a simple ovesight among largely robust code, given \nit lasted so long without requiring modification.  While both the original code and\nthe fix do not appear to use unit testing, I believe the issue is sufficiently \ncomplex that it would not have been feasible to detect it through all but the most \nextensive unit testing.  A 'defense in depth' approach would have been useful in this\ncase, which would involve sanitizing and validating all received messages from the \nFlash renderer rather than just those expected to be vulnerable.\n"},{"id":882,"cve":"CVE-2013-6629","project_name":"chromium","description":"An image segment reading function for JPEG files didn't check if the chunks of data comprising an image were being repeated, possibly allowing images to be stolen across domains and maybe even non-image memory.","mistakes":"The mistake was not ensuring data leakage wasn't possible when data was accessed- processing image data in chunks should ensure the same data isn't being processed twice, and that the remaining data isn't leaking. The mitigations enforce that the data is all processed and the tests appear sufficient."},{"id":926,"cve":"CVE-2014-1714","project_name":"chromium","description":"This was used as part of an exploit that potentially allowed for\ncode execution outside of a sandbox environment in Windows. A method that wrote\nobjects to the clipboard did not validate or sanitize the format of objects that\nare passed to it and instead wrote them directly to the clipboard. This had the\npotential to cause issues with Inter-Process Communication (IPC), as malformed\nobjects could be read by an IPC handler and may cause a denial of service.\n","mistakes":"This vulnerability is a case of missing code, and not incorrect code. The\nfunction of copying to the clipboard worked perfectly, but only during an\nabuse case did it malfunction.\n\nIt takes a lot of domain knowledge on the functionality of this clipboard\nwrite function and the ways that the clipboard data is used by the\napplication (or other applications) over IPC to realize the possibilities\nof malformed data an the consequences of not sanitizing it.\n\nThis is potentially an issue that arose because of a lack of tests. If tests\nwere involved, there would be thought of possible failure cases of the method\ninstead of just the ideal case.\n"},{"id":304,"cve":"CVE-2011-1465","project_name":"chromium","description":"Response bodies for a certain type of HTTP stream are not drained. The stream\nis left idle, which causes the system to crash without a user-visible error message.\n\nThis vulnerability exists because the system did not close that type of HTTP stream\nand it went unnoticed for a long period because the problem arose only rarely.\n","mistakes":"The core reason for this vulnerability was improper design, a result of \npoor analysis. If the functionality being added was properly analyzed, \nthe team working on it would have prevented the vulnerability in the first place.\n\nThe person who created the fix was not certain that it was proper, but there have\nnot been related problems since, so it was likely correct.\n"},{"id":227,"cve":"CVE-2011-1059","project_name":"chromium","description":"A vulnerability that allows remote attackers the ability to cause a denial of service by enticing a user to resubmit a form.  If a user filled out a form, went back in their browser, and then forward again, it would result in a crash.","mistakes":"This was a simple case of trying to access memory that has been freed. It only took about 12 days to discover the bug, but it took about 10 days to reproduce it because it happens on a rare boundary condition. Every developer makes memory management mistakes like this once in a while.  Most vulnerability scanners can identify use-after-free vulnerabilties, so one of these tools should be used when committing new code."},{"id":1041,"cve":"CVE-2014-9689","project_name":"chromium","description":"Chrome for mobile exposes the device's accelerometer and gyroscope data to all websites\non iOS and Andriod. Due to the precise nature of these instruments, with extremely accurate\nmeasurements it is theoretically possible for attackers to monitor keystrokes (through the\ntaps on the screen), track users (through movement), and even obtain low frequency speech\nsignals (through the vibrations in the phone). Current technology in mobile devices\ndo not allow for such precise measurements yet.\n","mistakes":"The mistake they made was not realising the types of vulnerabilities created by giving anyone access\nto a user's extremely percise gyroscope and accelerometer. When that level of precision is obtained\nin everyday mobile devices, it should be a permission that the user can give.\n"},{"id":803,"cve":"CVE-2013-2845","project_name":"chromium","description":"A heap-use-after-free vulnerability in the Web Audio implementation of Google \nChrome, for playing audio through the Chrome web-browser, allows remote attackers \nto cause a denial of service or possibly have unspecified other impact. This kind of \ndenial of service is caused by memory corruption. \n\nThe fix for this vulnerability is to ensure that variables are not used once they\nare free-d or released. Also pointers should be passed by reference. \n","mistakes":"The developers did not know that that the buffer was being used after it was freed. \nI did not see any checks in place to ensure that the buffer was being cleared properly. \nIt looks like there was a design mistake with OwnPtr, and then a design decision to \nchange OwnPtr to RefPtr, and recreate the corresponding functions required. \n\nSeems like the fix was not very simple. It took the creation of new RefPtr functions, \nreplacing many OwnPtr with RefPtr in many files, and realizing that some functions\nreturned the AudioBus after it has been free-d.\n"},{"id":342,"cve":"CVE-2011-2361","project_name":"chromium","description":"Dialog box for Basic Auth can be used to mislead a user into giving up their credentials. This is done by using a domain that intends to mislead the user into believing the authentication request is coming from a trusted source.\nThe fix is to specify both the domain and realm string, while also making sure that these strings are clearly labelled to the user.","mistakes":"The vulnerability here was an oversight of design. The devs did not\nanticipate malicious domains being used to abusing their dialog box. After\nrealizing the possibility of such an attack, it was quickly rectified.\n"},{"id":1125,"cve":"CVE-2015-1293","project_name":"chromium","description":"A vulnerability in a DOM implementation in web browser engine lead to remote attackers bypassing \nthe Same Origin Policy through the use of forged security credentials.\n","mistakes":"This vulnerability arose from an oversight by a developer. Their implementation was not \nsecure by default which provided an easy means for potential attackers to exploit the system.\nThis vulnerability was unnoticed during code reviews, even though it was relatively \nobvious in hindsight. The developer who was responsible for creating the vulnerability, and\nfor implementing a resolution for it was focused on patching other vulnerabilities around the\ntime of the fix. However, the developer spent a large amount of time implementing efficiency\nimprovements before the fix was committed. This means that, had it not been found by an external\nuser, it would have likely made it deep into production.\n"},{"id":525,"cve":"CVE-2011-3880","project_name":"chromium","description":"Google Chrome before 15.0.874.102 does not neutralize an invalid character (\\0) in HTTP headers which can lead to many opportunities for XSS and CRSF by attackers. After receiving and interpreting a request message, a server responds with an HTTP response message. \\0 character inside a headerline is being interpreted as a terminator. But \\00 can also work An attacker can bypass web application filters like this -\n$location = str_replace(\"\\r\",\"\",$location); $location = str_replace(\"\\n\",\"\",$location);\n?location=/private-data.html%00Access-Control-Allow-Origin:%20attacker.com","mistakes":"This was a coding issue with how a chromium server properly whitelists user data inserted into headers. The current fix, ensures that chrome neutralizes the invalid character (\\0) in HTTP headers.for XSS and CRSF by attackers"},{"id":119,"cve":"CVE-2010-2898","project_name":"chromium","description":"When Chrome looks up the MIME type for a long filename, the underlying library crashes.\nThis can be accessed through Javascript, meaning that in a malicious scripting situation (e.g. XSS),\nan attacker would potentially be able to construct an exploit that corrupts memory. Memory corruption vulnerabilities can lead to arbitrary code execution and other bad things.\n\nFor this vulnerability, no such exploit was ever written, but the possibility was there.\n\nThe way that they fixed it was to (a) simply limit the filename lengths, and (b) work with the third party library to handle long filenames.\n","mistakes":"The main mistake made with this vulnerability was in not testing the third-party library thoroughly.\nThey did not assume that filenames could be given abritrary lengths in Javascript, and therefore they ended up with a crash.\nSimple unit testing with diabolical tests (e.g. super-long filenames) and distrusting inputs would have prevented this issue.\n"},{"id":527,"cve":"CVE-2011-3882","project_name":"chromium","description":"Use-after-free vulnerability allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to media buffers. These impacts may include overwriting data or pushing confidential data to the output.","mistakes":"Based on the code this looks like a case of accidental buffer overflow that occurs under load testing. So while a denial of service was possible due to poor memory management, it would be hard to blame the programmer. The only real way to avoid this is cultivating safe memory allocating practices.\nThe fix properly mitigates this by locking resources via threading so that the freed memory can't be used before it is re-allocated by the program."},{"id":877,"cve":"CVE-2013-6624","project_name":"chromium","description":"Google Chrome was susceptible to a use after free vulnerability. This involves\naccessing a pointer after it was freed. This can lead to a variety of things, from\na segmentation fault to the execution of arbitrary code. To leverage this vulnerability\nan attacker would need to have an idea of where the use after free is taking place. Then,\nthe attacker may be able to hijack the \"freed\" pointer and use it to execute their own code.\nIn the case of this code an attacker may be able to alter the rendering of the DOM (Document Object Model) AKA the page, seeing as this\ncode refers to the id attribute of an HTML tag.\n","mistakes":"The vulnerability was introduced early on in the code and seemed to be a long time\ncoming judging by the commit message \"Exposed a lifetime issue with strings for id attributes.\nWe simply need to use AtomicString.\" It seems as though people were aware of the issue\nbut either could not figure out a good solution or didn't have the time. In additon the fixed seemed\nto be very simple leading me to beleive that people just didn't have the time to fix it. If anything this was\na design mistake that could have been caught earlier.\n"},{"id":139,"cve":"CVE-2010-3250","project_name":"chromium","description":"A vulnerability allows remote attackers access to a private list of functional plug-ins \nadded to the application by the user.\n","mistakes":"This looks like a classic example of software that had a minor vulnerability\nmost likely because the developers not wanting to put the time into fixing it.\nSome evidence: The VCC was made the day before Christmas (near the end of the \nwest-coast workday). The vulnerability was fixed by the first commit a contributor\nmade to the system. This is highly evident that it was some minor but annoying \nwork given to a new hire. The fix required a new development to be made, as well\nas minor other changes in different areas of the subsystem. The vulnerability\nexisted within the system for just under 2 years.\n"},{"id":140,"cve":"CVE-2010-3251","project_name":"chromium","description":"The WebSockets implementation in Google Chrome allowed attackers to \ncause a NULL pointer dereference resulting in a crash. WebSocket is a protocol \nused for real time communication between client and server without the need for \nthe client to continuously send requests. When the WebSocket connection was closed while \nthe host was being resolved the null pointer dereference would occur.\n","mistakes":"The function in question did not have a check for a null pointer and had \nbeen present in the source code since the file was first created (almost a year before).\nIt seems that there wasn't automated testing used for that specific error which, according to\nthe CWE page, does exist. Judging by the response when the issue was reported, it does not appear\nto be a very severe issue which may justify the lack of automated unit tests. Additionally \nthis problem could definitely have been addressed during design.\n"},{"id":945,"cve":"CVE-2014-1733","project_name":"chromium","description":"The bug was in Chromium's Sandbox in the way they detected and merge two blocks of code via PointerCompare and\nTailMerge.\n\nWhen executing a compare and a merge, the code does not properly account for the \"next\" pointer (the\nnext lines of code to execute after the blocks have finished executing) if the two blocks are not JMP (jump) or RET\n(return) instructions.\n\nThis creates an edge case where two blocks of code could be identical except that their 'next' pointer is\ndifferent, but the two blocks get merged anyways. This merge can introduce a cycle into the program and\ncan cause crashes during compilation. Worst case scenario, this can lead to illegal system calls via an attached\nBPF program.\n","mistakes":"The biggest mistake made in causing this vulnerability is that the developer in question did not think of all the\nedge cases. As the developer did not think that they would need to compare the 'next' blocks of code to be\nexecuted, it created this edge case where the code allowed an illegal merge because it did not look deeply enough.\nI would argue that this is a coding mistake, although this could have been caught at multiple levels. Better\nrequirements, testing, or design would have potentially caught this issue, but it ultimately fell through to the\ndeveloper to ensure that the case was accounted for, which they failed to do.\n"},{"id":1034,"cve":"CVE-2014-7946","project_name":"chromium","description":"Chromium's rendering engine, Blink, had a vulnerability where the rendering of\nthe table on a webpage would skip captions in certain situations. When a table\nis rendered, it would render all the table sections if they are needed but the\nrendering engine did not account for table captions being a part of the table\nlayout. Therefore, it would read past the defined size of an array. This\nallowed remote attackers to cause a denial of service attack where they\ncould corrupt sensitive information, cause a crash, or code execution.\n","mistakes":"The fix for this vulnerability appears to be a temporary workaround\nthat does not fully address the root problem of the vulnerability. Instead,\nit is meant to resolve the crash rather than fully address the issue\nwith rendering the table properly. It appears that when the vulnerability\nwas introduced, the author did not account for table captions which needed\nto be laid out when a table is rendered. This could have been found earlier\nif there were unit tests that tested tables with captions.\n"},{"id":748,"cve":"CVE-2013-0881","project_name":"chromium","description":"Google Chrome allowed remote attackers to cause a denial of service \n(incorrect read operation) via crafted data in the Matroska container format.\nThis is because of the manipulation with an unknown input when calling the function\nmatroska_parse_laces which in turn led to out-of-bounds reading in the memory.\nMore specifically, this caused a Heap buffer overflow.\nMatroska Multimedia Container is a file format that is able to hold unlimited \nnumbers of video, audio, picture, or subtitle tracks all in one file. \n","mistakes":"The mistake that led to this vulnerability was the developers not checking the outputs of all the file formats\nthat they were decoding. In the instance of this vulnerability, the developers allowed remote attackers to\ncause a DOS due to carefully crafted data in a Matroska container format. The developer had not checked a function\nthat related to matroska, more specifically matroska_parse_laces(), that moved a pointer in the file forward but did\nnot subtract the size of the file which caused an out-of-bounds read.\nThis could have been easily prevented had the developers checked all use cases for the formats they support and made sure \nthat the file's outputs were accounted for if they do support media formats such as matroska. Also the developers noted that\nthe vulnerability was old and dated back three months prior to this. The unit tests should have been more robust and the requirements\nshould have been more fleshed out so that all use cases were covered. \n"},{"id":1145,"cve":"CVE-2015-3334","project_name":"chromium","description":"The vulnerability was in the way website permissions were being displayed to\nthe user.\n\nMicrophone and Camera permissions were implemented in a way that they had to\nbe requested individually by a website, but were displayed as a single \n'MEDIA' permission in the Page Info dialogue. In cases where the two \npermissions did not have the same value, the UI instead showed the default\nvalue, often something unhelpful like \"Ask by default\".\n\nThis meant that a user had no way of knowing which media devices, if any, a\nwebsite had access to.\n","mistakes":"The code that introduced this vulnerability contained no mistakes, but \nrather, was based upon a mistake in the UI Design for the relevant feature.\n\nFrom the discussion on the original bug report for this vulnerability, it\nseems there was significant confusion about what information, exactly, the\nuser needed to be privy to, in regards to 'Media' permissions, and,\nultimately, a choice was made that allowed this ambiguity into the UI. \n\nThis choice was reconsidered with the filing of the bug report, and was\nfound to have been mistaken.\n"},{"id":1147,"cve":"CVE-2015-3336","project_name":"chromium","description":"If the url consistted of 'file://' then the browser would not ask the user if they are going to allow or deny for fullscreen and mouse lock. This problem allowed remote attackers to cause denial of service since the user didn't not have the chance to not allow the page the access.","mistakes":"The mistake was associated to them do a inverse check, by allowing the client be not notiified by default and an if statement managing when they should be notified. This is problematic and was not fixed still. They assumed with file:// that it would be user code which in turn means the user most likely knows what they want, however it is possible that another program loaded up the file and brough chrome to the directory which use this vulnerabliity."},{"id":953,"cve":"CVE-2014-1744","project_name":"chromium","description":"Integer overflow in the audio component occurs when a remote attacker sends an\noverflow value to cause a denial of service or a large shared-memory allocation.\nAn attacker can send an audio file with an integer overflow value to cause a\nsegment fault then the attacker can add input at the end of the audio file\nto modify memory. Alternatively, the attacker desire to crash the chrome, this\ncan be done by with the audio file alone. All these happen in the buffer value\nin the audio component; this means the vulnerability is a buffer overflow.\n","mistakes":"Whoever was tasked with the cyclic buffer change has since left chromium. They appeared to be either an intern or a new employee given the comments. They were tasked with a decently large change and there was much pushback to the approach that dominated the conversation in the code review instead of noting the lack of tests or looking for issues."},{"id":1224,"cve":"CVE-2016-1638","project_name":"chromium","description":"Remote attackers can bypass access restrictions by using platform Web APIs, i.e editing the underlying\nhtml dom for the extension or editing load js scripts, via Google Chrome Apps.\n","mistakes":"I think what mostly contributed to this vulnerability was coding mistakes. While the developers did try to fulfill the requirement of preventing restricted access via Chrome apps, there were still cases that they missed. I believe more misuse and/or abuse cases would have helped them in this situation, as they would have noticed that there was another way to bypass their restrictions."},{"id":339,"cve":"CVE-2011-2358","project_name":"chromium","description":"All extensions completed installation without first prompting the user with a ui to confirm \ninstallation completion. This could lead to the user downloading malicious extensions without \nrealizing it if they clicked on a fake download link or something similar. Malicous \nchanges to a user's system could occur because of this without the user's knowledge.\n","mistakes":"I think this problem was brought about by a requirements issue. \nIt seems no one thought of the impact of downloading extensions without prompt until a similar \nssue happened  on Android that was very damaging. The fix was very straight forward and makes \nsense. Adding a prompt for free extensions ensures that the user at least understands that \nthey are downloading something. Not showing the confirmation for paid extensions also makes \nsense as the user will have to put in their payment info, ensuring that they understand \nthat they are buying and downloading something.\n"},{"id":578,"cve":"CVE-2011-3964","project_name":"chromium","description":"The drag and drop feature within Google chrome was not properly \nimplemented. To be specific, it is the action of dragging a url to the url bar.\nThis allowed spoofing of legitimate urls through javascript when a link was \ndragged into the address bar. \n","mistakes":"The mistakes that were made was that after stripping the javascript schema, having to \nnot navigate to the link allowed for social engineering to take place and spoofing of \nwebsites to occur. It was more of a design mistake as the use case of dragging and dropping\na link to url address bar was not carried out fully to the end. You would expect the browser\nto navigate to the link and not stop. \n\nBased on the CWE entry for this vulnerability, they are not exactly carrying out an architecture\nand design mitigation of warning the user that they are leaving the page if there is javascript ran \nbehind the scenes. But they are sanitizing the javascript and navigating to the url to prevent spoofing \nof the real website.\n"},{"id":966,"cve":"CVE-2014-3161","project_name":"chromium","description":"\nWhen playing video from \u003cvideo\u003e tag, chromium on android uses a native media player. But once the video url is sent to the media player, Chromium has no longer control, and that opens up attackers to bypass Same Orgin policies. \n\nUnder the Same Origin Policy a web browser allows scripts in one webpage access data of another webpage, but only if both web pages have the same origin. But, if the policy is bypased, it allows outside sources access data of a particular website. \n\nFor example, the attack would go something like this:\n    1. User is logged in on myvideos.com, and visits evil.com, which had a \u003cvideo\u003e tag\n    2. User plays a video on evil.com, evil.com handles the request from the browser and serves a response.\n    3. Then, the browser sends the url of evil.com to the native video player to play the video. Now the browser has lost control of the interaction.\n    4. After that, evil.com recieves the request redirects the video to myvideos.com, allowing it to play cross-origin videos from myvideos.com that it should not have access to under the Same Origin Policy.  \n","mistakes":"I believe that this should be thought of as a design mistake. This is because\nit is part of the design of the product to securely handle browser requests at \nevery level, from the browser, to the actual native Android videoplayer. The \ncurrent fix at this time fixed the issue by always treating media urls as cross-origin.\nThis is not proper because although the approach did resolve the issue, it still \nsacrificed functionality by not trusting any URL to be same origin. \n"},{"id":1166,"cve":"CVE-2015-6766","project_name":"chromium","description":"The AppCache destructer calls the function OnDestructionImminent() on \nappcache_update_job.cc to notify any pending cache update jobs. While \nthis is happening, the new_master_entry_url_ of the host is expected to \nstay the same. But, this variable is susceptible to change with with a compromised \nrenderer, causing the browser to crash. \n","mistakes":"The mistake that led to the vulnerability seemed to be mainly a design mistake, \nand also a testing mistake. This is because there should have been a test case\nthat made sure the browser checks whether the new_master_entry_url_ of the host \nwas changing while the browser was finishing up cache update jobs before the cache \nwas deleted.  \n"},{"id":1167,"cve":"CVE-2015-6767","project_name":"chromium","description":"In the AppCache implemetation in Google Chrome before 47.0.2526.73, there is a vulnerability in \ncontent/browser/appcache/appcache_dispatcher_host.cc named use-after-free \nwhich means referencing memory after it has been freed can cause a program to crash, use \nunexpected values, or execute code. In this scenario, the memory in question is allocated to \nanother pointer validly at some point after it has been freed. The original pointer to \nthe freed memory is used again and points to somewhere within the new allocation. As\nthe data is changed, it corrupts the validly used memory; this induces undefined behavior in\nthe process. Therefore, this vulnerability allows remote attackers to cause a denial of service by \nleveraging incorrect pointer with certain callbacks.\n","mistakes":"I think this is the coding mistakes that a developer may forget about a host \ncan have a pending callback with a raw pointer to the dispatcher. If the \ndispatcher dies, it deletes all of its hosts, so that any pending callbacks are \ndeleted. But there is an exception, hosts can be transferred from an old backend \nto a new one, which doesn't clear any pending callbacks. Such a case leads to a \nUaF in the browser process if the old backend is deleted before a callback fires. \nAfter examining the mitigations I think ths is proper fix for it\n"},{"id":1172,"cve":"CVE-2015-6772","project_name":"chromium","description":"The previous implementation of DOM in the subsystem Blink (Chrome's rendering \nengine) did not protect URL navigation while a document was being detached, \nallowing attackers to attack internal plugins with JavaScript by attaching\na false document.\n","mistakes":"In my opinion, there were no mistakes. The vcc itself was a fix, originally,\nthat fixed the same vulnerability; making sure that while detaching a document,\nan attacker can't attach another document to that frame. The problem arose\nfrom where the fix was installed; it was installed in NavigationScheduler.cpp,\nand regression made that fix moot. The new fix was simply moving the old fix from\nNavigationScheduler.cpp to LocalFrame.h.\n"},{"id":1175,"cve":"CVE-2015-6775","project_name":"chromium","description":"A static method which doesn't use signatures could allow a remote \nattacker to cause denial of service or possibly access secure \ninformation by creating a \"fake\" object and passing it to this \nstatic method. \n","mistakes":"The Chromuim team's inital commit contained a bug. This snippit of code went\nthrough multiple code reviews and tests yet still manages to exist in the \nsystem. The code was noted as confusing several times in the commits and yet \nnothing was not to simplify the code or separate it out into multiple files \nfor easier readability. Complex code tends to hide vulnerabilities such as \nthis one and needs to be carefully reviewed before sent to production.\n"},{"id":450,"cve":"CVE-2011-3049","project_name":"chromium","description":"Web requests are made all the time by browsers looking to retrieve content,\npost content, and the like. In this case the API in question allows developers\nto view these requests to take analytics, block the requests, or modify them. This is\nproblematic in the case that a web extension goes rogue. This api allows rogue\nextensions to block incoming requests. Specifically, it allows a rogue extension\nto block a request calling for the blacklist of web extensions (which could include\nitself).\n","mistakes":"Overall in my opinion there was not enough code review that went into the VCC's merging.\nWhile it is difficult to think of such cases, further analysis might have revealed\nthe possibility of blocking important connections through a rogue extension. Furthermore, there seemed to be alot\nof misunderstanding dealing with how the updates to the blacklist were handled. Looking at the bug\ncomments, there was a good amount of debate about how the updating of the extensions was\ninitially planned to be a system call (meaning not using the profile) but ended up using the\nweb request. In retrospect, if they had followed through with the initial design choice, the\nvulnerability would have been avoided.\n"},{"id":743,"cve":"CVE-2013-0841","project_name":"chromium","description":"In the content-blocking funtionality of Google Chrome, there is a\nvulnerability where an array index is not checked. Content blocking\nis important to protect the user from unsafe scripts. \n\nThis vulnerability could potentially allow remote attackers to cause a denial\nof service (DoS). It could also cause the disclosure of information and\nunauthorized modification of data. This array is responsible for logging the\ntype of content settings accessed.\n\nThe fix for this vulnerability is to prevent the array index from going lower\nthan zero or higher than the size of the array.\n","mistakes":"This vulnerability was introduced during the implementation phase of development.\nI believe this vulnerability was the result of a coding mistake, but it could be\nthe result of a design mistake as well. Due to the relatively simple nature of\nthis vulnerability I believe that it could have simply been a mistake done by the\nprogrammer. Not properly checking array indexing is something can be easily\nforgotten. If input validation was not part of the design, then this is a design\nmistake as well. In order to prevent this vulnerability going forward, it must be \nremembered that array indexes should always be validated before use. The chromium\nshould also consider improving their unit testing plan. Array indexing is a\nvulnerability that can usually be caught during unit testing.\n"},{"id":575,"cve":"CVE-2011-3961","project_name":"chromium","description":"Race condition in Google Chrome allows remote attackers to execute arbitrary\ncode via vectors that triggers a crash of the utility process.\n\nThere seemed to be 4 clents that could have lead to the crash of the utility process;\nIndexedDB, WebstoreInstallerHelper, the profile importer, and posix plugin loader.\n\nBefore the fix, it seemed the race condition was caused by the \"utility_process_host_\"\nvariable becoming NULL and then not being appropiately dealt with. Though I am uncertain, \nit seems once this variable was NULL, calls on it that required it to be defined would \nnot work, causing a bunch of calls to be thrown off. \n\nI am unsure how an attacker would cause the \"utility_process_host_\" to become NULL.\n","mistakes":"The coding mistake that was made was not locking certain sections of code\nthat multiple threads talked to. That what allowed a race condition to\nhappen. The fix was to see check to see if a specific variable existed,\nwhich I assumed was a thread. In this case though, it seems like if a thread\nalready existed, it would execute code. This either stops the previous\nthread from continuing, or it is stoping the new thread from taking over the\noriginal thread accessing the data.\n\nLooking further, the specific thread that was crashing was the main utility\nprocess for google chrome. It seems when certain variables were set to NULL, \nthen the process does not know how to handle it, and it either treats the\ncondition as a crash protocol, or crashed because it could handle the certain\nstatements as being NULL.\n"},{"id":1185,"cve":"CVE-2015-6786","project_name":"chromium","description":"The Content Security Policy (CSP) is used to prevent attacks such as\ncross-site scripting (XSS). It defines approved origins of content that\ncan be loaded on the site. When a policy of 'script-src *' was used in Chromium,\nit allowed content to be loaded that was explictly banned by the standard.\n","mistakes":"The mistake made was not fully supporting the standard. Some of the standard was implemented but a special case for wildcard sources was left out. The team seemed to be actively working on adding support for the standard at the time of the report, so the fix may have come later on its own. The fix may be related to incomplete planning. When the bug was reported, the first comment was asking if someone else had already fixed it, assuming they were working on it. The other person responded that they never worked on it. This may indicate the work was not fully planned before implementation and they were informally assigning large parts of the standard to different people, leading to a missed detail in the implementation."},{"id":1187,"cve":"CVE-2015-6788","project_name":"chromium","description":"Some handler functions were improperly implemented. This allowed for attackers to cause a denial of service or utilize potential type confusion.\nThey could shut down the browser by using this type confustion through trying to access values that wern't expected.\nThe fix used a new method to grab data in a more safe and hidden fashion\n","mistakes":"The major mistake made that lead to this vulnerability was a slight trust in\nthe input received either from the user or from another system. Sometimes\nwhen designing an application we're under the assumption that some input can\nbe trusted. But if there is an issue down the chain, it can lead all the way to\nwhat otherwise might have been trusted.\nThe code of the fix has not changed much at all since it was put in 2015 to today,\nthat would lead me to believe that the fix was indeed proper.\n"},{"id":1247,"cve":"CVE-2016-1661","project_name":"chromium","description":"Blink, a web framework previously used in Chrome did not ensure\ncontent in frames passed a check for the same render process along with a Same\nOrigin Policy check, meaning the objects' source were the same. The Same Origin\nPolicy is defined as a combination of the URL scheme, the host name, and port\nnumber for the same origin. This allowed attackers to cause a denial of service attack\nor other impacts using a fake website and frame content.\n","mistakes":"The mistakes that led to this vulnerability were mainly design mistakes.\nThe authors of the code assumed frames that passed the SecurityOrigins\ncanAccess method had to be local frames. This does not hold true for\nframes that occur as a result of renderer initiated navigation, since\neach frame has the same origin but see the other frame as a remote frame.\nThis allowed content in frames to have external rendering processes which\ndid not have to pass the same level of security checks.\nIt appears the fix attempts to implement the third potential midigation of\nchecking the frame's ancestors to ensure it is a local frame.\n\nThe fix looks pretty good for a problem that not many people know about.\n"},{"id":754,"cve":"CVE-2013-0887","project_name":"chromium","description":"The developer-tools process in Google Chrome before 25.0.1364.97 on Windows and Linux,\nand before 25.0.1364.99 on Mac OS X, does not properly restrict privileges during\ninteraction with a connected server, which has unspecified impact and attack vectors.\n\nThis allowed the developer-tools process to access the web ui bindings, which\nit did not neeed access to. This opened up numerous attack vectors, although\nwas easily resolved by simply removing the bindings to the web ui\n","mistakes":"This bug was caused by the devtools process allowing access to the web UI bindings,\nwhich was not necessary. It is likely it came about from planning ahead during devtools development,\nwith the assumption that the web UI bindings would be needed.\nIt is clear that the binding was in fact not needed, as the fix was quick and involved simply removing the binding.\n"},{"id":1195,"cve":"CVE-2015-8480","project_name":"chromium","description":"The function that creates a video frame pool, the memory structure for video media frames, \ndoes not zero initalize the memory for a video-frame data structure. \nLarge unitialized sections of memory can contain sensitive information and cannot be relied on. \nOut-of-bounds memory access also allows for a denial of service attack and or read/write access. \n","mistakes":"The issue here comes down to coding mistakes. They neglected to zero initialize the video frame. \nWhen the problem was being addressed there was a lot of ambiguity about interaction with a \nvideo library *ffmpeg* being used at the time. The team did not seem to have a clear answer \non how the library would interact with their code for awhile. The originator assumed sending the memory \nwithout zero-initializing it would be safe - as they speculated that the library could handle it. \n"},{"id":326,"cve":"CVE-2011-1817","project_name":"chromium","description":"There are two vulnerabilities in Google Chrome before 12.0.742.91 in the way they implement history deletion.\n\nThe first vulnerability was because of the implementation not removing\nold event observers properly, which leads to observers looking for the event \nthat has already been deleted. Specifically, when a user try to clear browsing data,\nan event and its observer will be created to handle deleting browser data. However, \nif the process is somehow discrupted (ex. user cancels clearing browsing data), \nthe event will delete itself, while its observer does not. When the browser is reloaded, \nthe stale observer will try to listen to a non-existing event, which then will make the \nbrowser crashes.\n\nThe second vulnerability was not stated to directly cause the bug, but was a bad\ncoding implementation. The removing browser data event calls some methods on a wrong thread,\nwhich certainly could make the browser stall or crashed. \n\nThe way that this could be exploited would be an attacker somehow disrupts the history deleting\nprocess while it is ocurring. Then users will intuitively reload the page to restart the process,\nand the browser will crash.\n","mistakes":"It was a coding mistake where the developer deleted the event without thinking\nabout its living observers. \n\nAlthought the fix was simple, finding this bug in the first place was not easy. \nNoone thought about the situation where the deleting user's browsing data process\nis interupted. \n"},{"id":1216,"cve":"CVE-2016-1630","project_name":"chromium","description":"This refers to the ContainerNode::parserRemoveChild function in\nWebKit/Source/core/dom/ContainerNode.cpp in Blink, as used in Google Chrome\nbefore 49.0.2623.75, which mishandles Widget updates. Taken from Chromium's\nDevelopers page: 'At the root of a View hierarchy is a Widget, which is a\nnative window. The native window receives messages from Windows, converts\nthem into something the View hierarchy can understand, and then passes them\nto the RootView.'\n\nThe mishandling of Widget updates results in an easier medium for remote\nhackers to bypass the Same-Origin Policy, allowing them access to data in\na second web page.\n\nNormally, an origin webpage and a second/destination webpage must have the\nsame combination of URI scheme, port number, and host name, if data in the\nsecond webpage is to be accessible by the origin webpage.\n","mistakes":"This vulnerability was a combination of coding and design mistakes. Widget\nupdates were improperly handled, causing a delay that could facilitate the\nmanipulation of the DOM tree. The solution was simply to implement a method\nthat would effectively run the updates to prevent the acquisition of resources\nfrom an external actor. Multiple fixes combined when targeting the prevention\nof unauthorized DOM tree manipulation, as the initial fix did not account for\nthe update issue with widgets.\n"},{"id":1325,"cve":"CVE-2016-5148","project_name":"chromium","description":"A vulnerability found in an older version of chrome made widgets vulnerable to\nXSS attacks through \"widget updates\". Attackers could inject custom html files via\nvectors into widget updates.\n","mistakes":"I'd say that this is no fault of the developers or of their design. As a\nprofessional developer, you will always have to deal with other peoples code.\nIt doesn't make sense to spend the time and write 100% of the project when\nthere is a plugin or library that will do it for you. Purchasing COTS software\nis almost always a good idea financially and sometimes the only way to create\na reasonable project timeline. However, I do believe the onus is on the developers\nusing third party plugins to have a healthy distrust of those plugins and design\nthe system with that in mind.\n"},{"id":61,"cve":"CVE-2010-0662","project_name":"chromium","description":"The memory for a struct is allocated based on a value provided by an untrusted\nsource elsewhere in the code. This is dangerous because the source may not\nhave the correct value for the amount of memory needed, and the resulting\nBitmap that is initialized will not have the correct amount of memory\nallocated. This could lead to two attacks. The first is a denial of service by\ncausing an integer overflow. The second is being able to read potentially\nsensitive data from the extra allocated data.\n\nThe fix is to recalculate the amount of memory the bitmap will require instead\nof trusting the input.\n","mistakes":"The issue here was caused by a design mistake when developing\nthe function. A parameter was made available in the struct passed in so\nthe developer believed there was not a need to recalculate it. The value was\nbeing set by an untrusted input elsewhere in the code. As such the value\nshould have been calculated by a trusted source.\n"},{"id":906,"cve":"CVE-2013-6658","project_name":"chromium","description":"The vulnerability occurs when Javascript executes multiple triggers for a\nlayout refresh (an attempt to re-render the page at hand). It\nintermittently fails to handle those multiple triggers and causes\na \"use-after-free\" vulnerability as a triggered component attempts\nto use another one that has been destroyed (memory freed) by another\ncomponent caused by the Javascript code which causes a crash (DOS).\n","mistakes":"I believe that this vulenrability could have been avoided if mitigations against use-after-free were followed.\nIt seems that between the VCC and fix, it was noted by a review that this area in particular was a high risk\narea that may induce such a vulnerability. However, no action was taken to mitigate the issue. the\nvulnerability originated due to a lack of risk mitigation in this high risk area as well as no proper\nunit tests in place despite this being a system critical component.\n"},{"id":907,"cve":"CVE-2013-6659","project_name":"chromium","description":"SSL certificates are used by hosts so that connecting browsers know how to\nencrypt messages and that the host can be trusted. When a new session is\nstarted, such as logging in or out of a site, SSL must be renegotiated, or\nreverified and encrypted.\n\nWhen renegotiating with a host, SSL certificates would be reverified, but not\nchecked against the previous certificates to see if they match. This allows\nremote SSL servers to use a new certificate chains unexpected by the user.\nConsequently, this can lead to different information linked to the website\nbeing shown to the user, making the user believe a different company owns the\nsite.\n","mistakes":"This vulnerability exists due to an unforseen scenario where a server could\nrenegotiate a connection with a new, but still valid, SSL certificate.\nSince the second certificate is still valid, it would be accepted, but in\nreality each host should only have one certificate. Because the certificates\nwere verified both before and after renegotiation, and because it was likely\nassumed the host only had one certificate, this vulnerability went \nunnoticed. If this specific scenario was thought of when designing the \nchecks for certificates, it could have been avoided, but it is likely the\nengineers believed the validity checks would be sufficient.\n\nThe vulnerability was fixed entirely in the two commits to fix it. Other\nmitigations were already in place for validating certificates, but none\nwere in place for this particular vulnerability.\n\nThe two commits completely fix this vulnerability by checking the current\ncertification matches the old certification. Some comments throughout the\nsource suggest the functions were originally based on other browser\nprojects, and it is unclear if other browsers had a similar issue that was\npatched at other times.\n"},{"id":282,"cve":"CVE-2011-1434","project_name":"chromium","description":"Opening suitable pages sometimes causes Chrome to crash at various places on startup due to a lack of thread safety when handling MIME data.","mistakes":"A mixture of coding and design mistakes. \nSince thread saftey wasn't ensured while handling MIME data, \nif an attacker entered unknown vectors the system would crash. \n"},{"id":1319,"cve":"CVE-2016-5142","project_name":"chromium","description":"Due to poor handling of data buffers inside the cryptography API used in chrome\n(WebCrypto), attackers could remotely cause a denial of service via crafted javascript\ncode. This is caused by a use-after-free error on a pointer related to the buffers.\n","mistakes":"The mistake that led to this vulnerability was the fact that google assumed\nthere were no vulnerabilities inside the web crypto library that they used in\nchromium. Despite unit tests, there were vulnerabilities that went undiscovered\ninside webcrypto. The lesson to be learned here is that you can't necessarily\ntrust every external piece of software that your system depends on. Luckily, \nregression of this bug is unlikely to occur because more unit tests were created\nto test for the case that causes it.\n"},{"id":462,"cve":"CVE-2011-3061","project_name":"chromium","description":"The implementation of the code handling creating a socket connection to an\nintermediary, request-handling server recognizes that a certificate error\nexists but it appears to be ignored since it doesn't disconnect when the\nerror is caught. This could have allowed for a man-in-the-middle attack\nwhere one could spoof a server and potentially get sensitive information\nwith the created certificate.\n","mistakes":"The mistake could have came from a design mistake or an issue with requirements. The code was initially written to make sure to notice if a certificate mismatch is found. The mistake there was not disconnecting immediately. Why the code to disconnect wasn't written at first confuses me. It may be because of it not being stated in the requirements. It could also have made it through if it wasn't accounted for in unit testing. It could have even slipped through code reviews as well. The fix does look proper as it immediately does a disconnect."},{"id":1338,"cve":"CVE-2016-5161","project_name":"chromium","description":"In Google Chrome there was an issue with merging certain CSS styles together.\nTheir old implementation serialized the CSS property value and then reparsed \nit which didn't preserve the name of the custom property. In their test example \nthe CSS that was causing the issue was '--A:var(---B)' and 'float:var(--C)' \nwhen applied to two spans.  When these styles were merged it would create a \ncase where the system could end up reading memory that wasn't allocated which \ncould result in a segmentation fault, which could be a denial of service.\n","mistakes":"It was a design mistake. They failed to consider a certain type of input,\nwhich when entered had the potential to break their system. They should\nhave considered CSS properties with custom values when desiging the\nmerging functionality. They should have had people who are experts in CSS\nlooking over the code to make sure that their implementation conforms to\nthe standards, the stakes are high for a project like this and google\ndefinitely has the resources. They also could have written tests for all\nof the different types of CSS inputs to make sure the merging worked as\nexpected for a variety of inputs.\n"},{"id":1309,"cve":"CVE-2016-5132","project_name":"chromium","description":"This vulnerability allows insecure pages with an iframe to a secure page to intercept any communication between the secure page and the browser's Service worker. The service worker controls things like push notifications, background sync, period sync, and geofencing.","mistakes":"This appears to be a testing mistake. This vulnerability takes advantage of a very specific scenario that didn't seem to be accounted for in unit test."},{"id":1430,"cve":"CVE-2017-5065","project_name":"chromium","description":"Incorrect UI in Blink. Form input validation bubble doesn't go away on page\nreload.\n","mistakes":null},{"id":1017,"cve":"CVE-2014-7929","project_name":"chromium","description":"Use after free vulnerability occurs in moving a script from old document to\nnew document function. The function can cause a denial of service or an impact.\nWhen a user moves an old document to a new document, then Chrome will move the\nscript between the old document and the new document. Chrome did not check if\nthe script is allocated or not will cause a crash or an attacker can add input\nto overwrite memory.\n","mistakes":"The person who was working on adding the feature by moving a running script across\ndocuments did not check the use after free vulnerability case. It seems the original\ncode unit did not review all cases at the VCC. He/she did apply unit tests in the VCC\nfor some cases but not all. The VCC was focusing on moving pending async script loader\nto the new document introduced the use after free vulnerability with the document\npointer.\n"},{"id":1205,"cve":"CVE-2016-1618","project_name":"chromium","description":"This vulnerability pertains to pseudo-random number generation. More specifically,\nthe code in question uses a poor method of generating a random number, making it \nmore vulnerable to external attacks than say, a proper random number library.\n","mistakes":"This was a case of two developers not knowing that a previously widely understood\nto be secure library was no longer standards compliant and was being retired. \nThis might be classified as a Maintainability issue since we as developers cannot \ntrust libaries always. \n"},{"id":1174,"cve":"CVE-2015-6774","project_name":"chromium","description":"The vulnerability was found in one of the functions relating to loading time \nwithin the Chrome's renderer subsystem.\n\nModification of a pointer through javascript can give remote attackers the \nability to cause denial of service. Specifically, when the pointer used for \nreporting load times data is modified by javascript, the use of unexpected \nvalues can occur. To do so, a remote use would have to create specific content\nthat when loaded by the target system, will execute arbitrary code on the target \nuser's system.\n","mistakes":"The mistake made was assuming the type of the input before carrying out execution of\nthe variable. When working in a programming language that has the programmer handling memory,\nhaving explicitly written code prevents some of these vulnerablities. \n\nBased on the CWE entry, to mitigate such vulnerability, one should try to use a language that \nprovides automatic memory management. This was not done because execution should be optimal \nwhen it comes to speed and to do that, carrying out your own memory management gives more flexibility.\nFor the implementation fix, the programmer did set the pointer to null before carrying out further\nimplementation of the pointer. This would seem to be the proper fix to a problem such as this.\n"},{"id":956,"cve":"CVE-2014-1747","project_name":"chromium","description":"Certain file types embedded in an HTML page would be automatically downloaded with no user prompt and any javascript \ncode contained within the file would be executed.\n","mistakes":"The fix whitelists the acceptable location of the input, limiting MHTML documents from being loaded in any frame except the top.\nThe major mistake here is allowing files to be downloaded automatically, and enabling javascript code execution in areas where it is not necessary.\n"},{"id":542,"cve":"CVE-2011-3898","project_name":"chromium","description":"If users had a version of Java that was 7 or above, then applets were allowed to run without any confirmation from the user. This was due to the code only checking for Java versions below 7.","mistakes":"The choice that ultimately lead to this vulnerability was the choice to add an upperbound on the Java version when it was not necessary. This caused a real security issue when Java version 7 and above were released."},{"id":1025,"cve":"CVE-2014-7937","project_name":"chromium","description":"Multiple off-by-one errors in libavcodec/vorbisdec.c resulting for-loop over/under-execution.\nThe vorbisdec.c is a decodeder for vorbis data. Vorbis is an open-source project that\nproduces audio coding for lossy audio. These error allows for possible denial of\nservice attacks. Other vulnerabilities such as information disclosure and unauthorized\nmodification may also exist, with the crafting of vorbis data.\n","mistakes":"This error was cause by a simple coding mistake, an off-by-one error. Theses mistakes are bound to happen,\nthe only thing that can prevents error like this are extensive tests that include boundary and edge\ncases. The mitigation is very simple and does look proper. An off-by-one is quite easy to identify\nand correct. This was fixed according to the CWE, as the fix is making sure loops stay within range, when\nworking in languages like C.\n"},{"id":1261,"cve":"CVE-2016-1675","project_name":"chromium","description":"Prior to the fix for this vulnerability, remote attackers were able to bypass the\nSame Origin Policy by mishandling Document attachments during the FrameLoader and\nLocalFrame document attachment process. Essentially it allowed for an elevation of\nprivilege, creating issues with security within the software (Along with cross-site\nscripting vulnerabilities). This could allow for malicious code to be executed, or\ngive to the attacker privileges that could harm the rest of the system.\n","mistakes":"The general design flaw from this problem seems to have stemmed from an attachment\nfunctionality from an outlook process. It's strange that this was used all the way up\nto the time it was... and it's interesting to see how high coupling can really\naffect a software system over a long period of time. It sometimes makes sense to use\nolder functions to accomplish common tasks, but when it becomes so depricated that it's\njust getting in the way it needs to be removed.\n"},{"id":78,"cve":"CVE-2010-1504","project_name":"chromium","description":"This problem was found early on in chromes development and for good reason. If you passed an html \u003cscript\u003e tag to\nthe url when inputting a url in the url bar, it would directly place the script code into chromes internal html\ncode and it would exectute that script.\n\nFor example, for a website such as www.website.com/#\u003cscript\u003eblah\u003c/script\u003e it would execute the script appended to the\nend of the url due to the vunerability.\n","mistakes":"This was a design mistake that led to this bug. In this intial code, it was not taken into account that\na user may provide a bad link with html code directly in it. This bug is also so old, that it is likely that it\nwas unknown exactly what kinds of attacks were possible at the time. The fix for this was correct but not complete\nand later, a complete solution was added essentially making it impossible to use an XSS attack nowadays using the\nsame attack as before. The original developer also perhaps did not understand that the line of code\n\"url.InnerHtml = url\" would set the actual web pages executable html to whatever the\nuser inputs, which is of course bad.\n"},{"id":1322,"cve":"CVE-2016-5145","project_name":"chromium","description":"Blink, a rendering engine used by Chromium, allowed remote attackers to bypass the same-origin policy\nrestriction for images that was written in the JavaScript code. Same Origin Policy is a concept where\na web browser allows scripts in the first page to access data in the second page but only if they are\nfrom the same origin (URI scheme, host name, and port number). They are able to bypass the policy because\nBlink did not ensure the taint property is preserved after a structure-clone operation on an ImageBitmap\nobject derived from a cross-origin image. What this means is that Blink, after cloning of an ImageBitmap\nobject, did not keep the property that determined whether it would taint a canvas or not with cross-origin data\nwhich would prevent interactivity.\n","mistakes":"The primary mistake that was made here that led to this vulnerability was a result of an oversight in the implementation of a structure-cloning operation. Whoever wrote the original function to clone a bitmap forgot to include the taint peoperty that is important in realizing whether or not scripts in the first page could access data in the second page. They had overlooked the fact that the same origin policy was important and so when writing the bitmap code, they did not include checks that verified if the bitmap was from the same origin. This vulnerability should not prove to be a problem in the future because the code appears to have been fixed and reviewed carefully. There is now an added test case which will check to make sure this wouldn't happen again as well."},{"id":1279,"cve":"CVE-2016-1693","project_name":"chromium","description":"When downloading the CCT (Chrome Cleanup Tool) binary, HTTP was used.\nThis allowed an attacker to spoof the identity of the CCT. The consequence\nis that a man-in-the middle attacker would be able to send malicious executables\nto an HTTP session.\n","mistakes":"I am unable to view the Bug report that the VCC fixed so I am not sure if the author's\nusage of HTTP instead of HTTPS was a miscommunication across team members.\n\nIt could have been a lack of knowledge of what the difference between HTTP and HTTPS\nis and why HTTPS should have been used in this situation. If that is the case,\nthen I don't think it is really a coding mistake. The mistake would be that the domain\nand implications was not well understood by the developer. Although HTTPS itself doesn't\ncompletely against man-in-the middle attacks, what it does it encrypt the information sent\naccross a connection so that a third-person cannot intercept the data and view or modify it.\n\nGiven that the time between the VCC and the fix was over a year, and several\nchromium developers saw the code, it is a mistake that it is not automatically realized\nthat HTTP should not be used.\n"},{"id":963,"cve":"CVE-2014-3157","project_name":"chromium","description":"When decoding a video, a buffer is allocated for each frame to be decoded in\nto. However, if the buffer is not large enough to hold the decoded frame, a\nheap overflow occurs, which can allow data to be written where it should not.\n\nThis Heap-based buffer overflow inside the function to get a video buffer for \ndecoding allows remote attackers to cause a denial of service by causing the\nsystem to crash. An exploited to abuse this could be a malicious video file\nembedded on a web page.\n","mistakes":"The coding error was a buffer overflow, caused by not allocating enough \nspace for ffmpeg to use for decoding. This mistake was because the buffer\nprovided by chrome did not use the same calculations for allocating space\nas a buffer that would be provided by ffmpeg.\n\nThis vulnerability was caused by misunderstanding how ffmpeg allocates and\nhandles video buffers. The team changed the code so Chorme provides a\nbuffer for ffmpeg to use instead of letting ffmpeg allocate a buffer, but\nthey used a slightly different calculation to determine the size of the\nbuffer. \n\nThe solution implemented was to allocate the same ammount of space as\nffpeg would have for the buffer, ensuring that there was enough room to \nnot overflow the buffer.\n"},{"id":985,"cve":"CVE-2014-3189","project_name":"chromium","description":"An out of bounds read occurs when data is read past its intended boundries. In the\ncase of this particular vulnerability, a function responsible for copying an image to\nknown destination was able to preform an out of bounds read. This was allowed by\nnot checking that the size of the image you want to copy makes sense. This is done by\nchecking for negative x,y values and also making sure that size wise, it could be contained within\nthe data being passed in as the source data. Not having these checks \nin place allows either a buffer overflow to occur by reading and trying to store \na mass amount of unintended data, as well as has the possibiliy of producing\nsegmentation faults by reading outside the program's assigned memory which could lead to a denial of service.\nMost importantly, this vulnerability could be leveraged to allow leaks of sensitive information. Since\nyou are able to read outside intended boundaries, one could read around to try and find sensitive data contained\nwithin a particular processes assigned memory region.\n","mistakes":"The mistake that led to this vulnerability was not sufficiently testing the \npdf plugin source before introducing it into the chromium codebase. In terms\nof the plugin itself one could also say that this has the design mistake of \nnot implementing proper boundry checking of incoming parameters.\n"},{"id":1036,"cve":"CVE-2014-7948","project_name":"chromium","description":"Google Chrome caches pages despite having an SSL certificate error which allows man in the middle (MITM)\nattacks to spoof HTML pages via a certificate that the attacker can create. The MITM can intercept web pages\nand replace the site's page with a malicious one on a malicious server or site.\n\nThe fix for this vulnerability is to refuse to Application Cache responses with any SSL certificate errors. Basically to not\nignore SSL certificate errors unless they are flagged to do so.\n","mistakes":"I think that the vulenrability is interesting because it is difficult to find/test for. What made this vulnerability\nwas a design issue where the developers failed reject caching a page after ignoring SSL certificate errors. This also\nmay be a requirements issue where the devs know not to execute something after a non-trustworthy certificate but\nmay have overlooked it thus a non-google employee discovered it. We are human after all. The main thing for practitioners\nto learn from this vulnerability is to have your code/product properly handle errors and to never ignore any given errors\nthat can lead to a possible execution that you did not intend.\n\nAs for the mitigations, the team does properly check for SSL certificate errors\nand validates whether it is valid or not or has a tag that allows the certificate errors to be ignored.\n"},{"id":910,"cve":"CVE-2013-6663","project_name":"chromium","description":"The SVG implementation in Google's web engine *Blink* allows for the use of\nan object after it has been freed from memory. This was caused because\nresizing an SVG image could destroy the renderer which would cause a\n\"use after free\", crashing the engine.\n\nThe vulnerability could cause a denial of service but its impact is limited\nbeyond that due to the fact that there was only the resizing of the image\nbetween the free and its use which causes the crash.\n","mistakes":"The coding mistake that occurred was due to the fact that the original author\nof the function did not realize, or forgot, that resizing a container could\ndestroy the renderer and had misplaced his check for it. The same chromium\ndeveloper who originally wrote the method also added the fix and an additional\ntest case.\n\nThe vulnerability was a part of the initial creation of the function and\nthus there could have been a small design mistake which led to it. Being\nmore familiar with the SVG renderer likely could have prevented this mistake\nas it appeared to stem from a misunderstanding about the unintended\nside-effects resizing a container could have.\n\nThe Chromium team uses the Modern Code Review (MCR) process whose\neffectiveness has come under question in recent years. The original author\nof the VCC, pdr, has also only ever had one documented code review and it\nwas not for any code related to this vulnerability. These two factors may\nhave also contributed to the vulnerability going undetected.\n\nSource: http://ieeexplore.ieee.org/document/7781793/\n"},{"id":332,"cve":"CVE-2011-2345","project_name":"chromium","description":"This vulnerability is exploited based on improper handle of string\nin Application Programming Interface (API) which allows remote attackers to conduct\na denial of service attack based on out-of-bounds (CWE-125) read using unspecified vectors.\nFor example, without input validation and verification, an attacker can pass in an arbitrary\nmemory address to read sensitive data from the system or an arbitrary snippet of code \nto execute inside the application. In case of arbitrary code, attacker can cause\nsignificant harm to the system such as retrieving sensitive data, modifying \napplication's internal data or even affect other users.\n\nThe vulnerability was first introduced in the Netscape Plugin Application Programming\nInterface (NPAPI) of Google Chrome before version 12.0.742.112. When '\\' is passed to\nfunction in the NPAPI, the value is read in as an arbitrary memory address. When the \nmemory address read is outside of the address space that the computer gives to the \ncurrent process, it is an out-of-bounds read. Out-of-bounds read causes the process \nto crash and when there are enough crashes, system resources are unavigateailable to other user.\n","mistakes":"The mistake that led to this vulnerability was lack of defense in depth\nprinciple, the developer forgot to validate and verify inputs in API module\nwhich is used by everyone. Overall, it's a coding mistake. The original code\nbasically read in whatever string user passed in without validating it. As\na result, when user passed in an arbitrary memory address, the vulnerable\nfunction just returned to user data stored in that memory location. Should\nthe developer be more careful and validate the inputs, unsafe inputs can be\navoided.\n"},{"id":158,"cve":"CVE-2010-4033","project_name":"chromium","description":"Chrome does not verify that the user is the one submitting data when saving auto-complete data.\nIf Chrome stores the data automatically it can overflow what chrome is able to handle and crash the browser.\nAn attack targeting this vulnerability would be a malicous site continously filling and submitting a form to \noverflow the possible storage of auto-fill data and crashing the browser. A Google employee determined that in the matter\nof a few seconds a form doing that would be able to crash the browser.\n","mistakes":"This vulnerability appears to be an oversight in a potential line of attack which was then caught later on.\nThe infobar that originally designated form data as being saved no longer appered so the user would not know when data was being saved.\nBecause this infobar no longer existed, it was possible to fill/overfill the store of data malicously and crash the browser.\n"},{"id":1282,"cve":"CVE-2016-1696","project_name":"chromium","description":"Remote attackers could bypass the Same-Origin Policy via unspecified vectors\nsince the Extensions subsystem in Google Chrome didn't properly restrict\nbindings access.\nThe Same-Origin policy states that web browser scripts can access data in a\nsecond web page, but only if they have the same origin. Bypassing the\nSame-Origin policy means that data confidentiality or integrity could be lost.\n","mistakes":"The CWE ID for this vulnerability is 346, and is titled Origin Validation\nError. This vulnerability was caused due to not enforcing the Same-Origin\npolicy. Looking at the code review, we see that the developers had an\nin-depth discussion and recognizd that there were files not being used, and\nnew native handlers were made for the extensions. In order to prevent these\ntypes of vulnerabilities, a potential mitigation would be to separate\nprivileges. Following the principle of least privilege during the\ndesign/coding process would've fixed this issue. In order to ensure this\nissue doesn't occur again, the developers expanded their bindings access\nchecks. These checks will enforce the Same-Origin policy and make sure that\nthe source is checked, and that malicious websites cannot be loaded.\nPreventing Origin Validation Errors by testing the origin will lead to a\nsafer system, and prevent attackers from gaining access to undesired\nfunctionality. This vulnerability is very similar to CVE-2016-1622 in\nregards to the type of malicious actions that attackers can perform.\n"},{"id":869,"cve":"CVE-2013-2926","project_name":"chromium","description":"Use after Free vulnerability in the 'Indent' command of the rendering engine 'Blink'. The vulnerability could be used to cause user-assisted denial of service attacks.","mistakes":"This was a simple coding mistake that occurred when the 'Indent command' function was refactored.\nThe developers refactored the code to make it more readable.\nHowever, they accidentally made an incorrect assertion in one of the 'if' statements.\nThe original 'Indent command' made the correct assertion, so the developers made a simple coding mistake that was overlooked for a little bit.\nAn automated tester was able to find this incorrect assertion and bring it to the team's attention\nThe vulnerability was fixed when the team simply removed the incorrect assertion from the function."},{"id":745,"cve":"CVE-2013-0843","project_name":"chromium","description":"For Mac OS, the buffer size is too small when running the 96 kHz sampling\nrate, allowing remote attackers to cause a denial of service (DoS)\nattack. This, in turn, can cause memory corruption and have the application\ncrash as well as cause some other impact to a third party site that provides \nWebRTC audio, increasing the risk of sensitive information disclosure.\n","mistakes":"I believe that, since this vulnerability was due to not considering\nthe use of 96 kHz sampling rates for MacOSX, additional \ncases of increased rates (96 kHz, 192 kHz) should be included in the unit\ntesting scripts for all platforms to ensure that this type of vulnerability\nis not repeated. It's important to have good boundary testing in order to\ndetermine how your code works within and outside of your expected value of\nranges as it can cause other issues that the system may not be prepared for."},{"id":1329,"cve":"CVE-2016-5152","project_name":"chromium","description":"A function inside of OpenJPEG which is used by PDFium in Google Chrome\ndidn't prevent integer overflow giving attackers the ability to cause \ndenial of service with heap-based buffer overflow attacks.  This occured\nwhen an svg element was rendered in an iframe.\n\nA heap-based overflow attack could allow malicious users to access \nmemory they shouldn't and write data to those locations the program does\nnot expect at run-time.  In this situation the consequence of one of these attacks\nis that Chromium cannot handle the corrupted memory and will stop working which\nis an example of denial of service.\n","mistakes":"I believe design mistakes were made by the Chromium team.  By incorporating the open source OpenJPEG2000 project Chromium was exposed to vulnerabilities in that project.  Security doesn't seem to have been as big a concern to the developers of OpenJPEG as compared to Chromium.    It is likely that many other vulnerabilities have been found/exist as a result of the use of third-party software like OpenJPEG2000."},{"id":1179,"cve":"CVE-2015-6779","project_name":"chromium","description":"When a user opens a pdf file in the chrome pdf-viewer, and the pdf file has a link \nto a url, they can open this link in a new tab. This allows for the scheme restrictions\nof a pdf to be bypassed.  This is prohibited in HTML. This also should not even be\npossible in a pdf file.\n","mistakes":"I would say that this vulnerability was a culmination of design mistakes and \npotentially poor requirements.  I say this, because a vulerability like this\nshould not normally occur.  HTML prohibits this and PDF documents do not normally\nallow this behavior.  My guess is that some niche design decision was made that\nallowed for this behavior.  It is also fair to say that this design decision may\nhave been made due to poor requirements.\n"},{"id":901,"cve":"CVE-2013-6653","project_name":"chromium","description":"Certain aspects of how Google Chrome handles displaying web contents allows a\nremote attacker to generate a webpage that attempts to access the operating\nsystem's color chooser (think of the dialog that you can open in Windows Paint\nto select a color) in a conflicting manner.\n\nThis is essentially a concurrency bug that causes a race condition (i.e., two\nthreads/processes try to access the same resource at the same time) for an\ninstance of the color chooser. If more than one webpage accesses this color\nchooser, and that color chooser's memory resources are then freed, this leads\nto what is known as a \"use-after-free\" error. This only seems to cause Chrome\nto crash (an example of \"denial of service\"), though it has the potential to\ncause other serious issues.\n","mistakes":"The main mistake made throughout this vulnerability's history was essentially\na resource management issue - instantiation of the color chooser dialog was\nnot handled properly, and as a result a race condition could occur and cause\nthe browser to crash.\n\nThough not exactly what is recommended as a mitigation in CWE-416, the\ndevelopers used NULL to indicate failure if a color chooser dialog has\nalready been opened. At the very least, this prevents the same issue from\nhappening again.\n\nThe vulnerability was introduced by two developers across two commits,\nalthough there are no signs of miscommunication between the two of them.\nIt seems as though they were just attempting to address the same issue\nat different points in time, which led to the vulnerability.\n"},{"id":348,"cve":"CVE-2011-2785","project_name":"chromium","description":"There was an issue with the Extensions in Chromium that allowed attackers to cause various issues. This was caused by attackers abusing the fact that Extensions didn't validate URLs for home pages as the way they should. Attackers could use custom Extensions to do damage.","mistakes":"A lot of it had to do with poor sanitization of URLs are restricting privileges. This is more on the design side rather than requirements or communications. The fix looks like it might work but could have some work-arounds. The ending fix was to validate the homepage only if it was http or https."},{"id":1182,"cve":"CVE-2015-6782","project_name":"chromium","description":"In the The Document::open function in WebKit/Source/core/dom/Document.cpp in Google Chrome before 47.0.2526.73 has a improper input validation which The product does not validate or incorrectly validates input that can affect the control flow or data flow of a program. The page-dismissal event handling is compatible with modal-dialog blocking, which makes it easier for remote attackers to spoof Omnibox content via a crafted web site.","mistakes":"I think this is coding mistake that a developer accidently create a vulnerability \nthat makes it possible to display arbitrary content under the URL of the website \nthat the user is trying to access (from the attacker's page,through the omnibox). \nAfter examining the mitigations I think ths is proper fix for it\n"},{"id":1237,"cve":"CVE-2016-1651","project_name":"chromium","description":"This vulnerability causes an information leak or a denial of service\nduring the rendering of JPEG images in PDFs. It can be exploited by embedding\na specially crafted JPEG image which will read memory past the end of the\nallocated space, due to a mistake in the implementation of a type conversion\nfunction. The fix involves checking the size of the image prior to allocating\nmemory.\n","mistakes":"Parsing JPEGs is a relatively small portion of the PDFium application, and it\nseems like it's something that requires a specific skill set. Because of this,\nI believe the developers should have used a previously written and tested\nJPEG converter/parser, instead of trying to write their own.\n\nBesides that, it was clear that the JPEG parser was not unit tested until relatively\nlate in the project's existence, which was a mistake. It's a lot harder to detect\nbugs and vulnerabilities without unit tests.\n"},{"id":521,"cve":"CVE-2011-3876","project_name":"chromium","description":"File downloads with trailing whitspace characters at the end of the file name were not handled \nproperly. No download warning was given to users if they weren't explicitly downloading .exe \nfile. Users could download a .exe%25C2%25A0 file without warning trailing characters were \nstripped from the file name which may lead to a user downloading something like a .exe file \nwithout their knowledge.\n","mistakes":"It seems like this was a coding mistake that no one initially caught because it occurs in a\nvery specific circimstance that doesn't happen often. The developers probably did not \nrecognize this as an issue when they created the bug. The fix replaced whitespace in file \ndownload names with hyphens instead of wiping them out completely. This is a better \nsolution although it still gives the user to download an exe without warning. The user \nwould now have to manually alter the file name in this case in order to allow the file to \nact maliciously which is better than potentially converting a file to exe without warning.\n"},{"id":976,"cve":"CVE-2014-3173","project_name":"chromium","description":"WebGL (Web Graphics Library) does not ensure that clear calls interacted properly \nwith the state of a draw buffer. This could allow a denial of service attack by \nreading uninitialized memory, which causes weird states in the code.  Also, it leaked virtual \nRAM but it was only from sampled textures so this wasn't much of a concern.\n","mistakes":"This issue appeared to be a coding and logic mistake.  The potential problems\nthat were caused by the uninitialized buffer being called were not thought of\nin the initial implementation of the patch they created.  This caused a buffer\noverflow.  There was not much of an issue with leaking sensitive data however\nbecause it only accessed sampled textures, but there was a potential risk of a\ndenial of service attack do to unwanted states being caused by an exploit.\n\nTheir solution to this bug was not one of the possible mitigations on the CWE\npage, but still effective.  They just check the buffer to see if it is\nuninitialized before trying to clear it again.\n"},{"id":349,"cve":"CVE-2011-2786","project_name":"chromium","description":"\nThe pop-up screen for speech-input-bubble in google chrome can be moved out of the \nscreen. Google Chrome fails to ensure that the screen is shown on the product's screen. \nThis might make it easier for the remote attackers to make audio recordings via a crafted\nweb page containing an INPUT element. \n\nWeb page can start speech recognition whenever user clicks anything on web page. \nThe problem is that Chromium relies on a popup showing that recognition is started. \nThat popup can be moved to be outside the screen. With the use of this ability, the \nattacker could use this  as a platform for phising attacks. For instance, if the attacker \ncan cause the UI to display erroneous data, or to otherwise convince the user to \ndisplay information that appears to come from a trusted source, then the attacker\ncould trick the user into performing the wrong action. Hence, causing the source,\nthe original window - to be obscured or spoofed. \n","mistakes":"This really seems to be a mix of requirements and a design issue, the engineers \nclearly didn't think about enough cases and requirements on the ability of the \nspeech-input-bubble whether it could be dragged outside the window. The did not have \na complete test plan. The actual fix wasn't that complicated and involved just adding\nmore checks. "},{"id":1188,"cve":"CVE-2015-6789","project_name":"chromium","description":"Blink is an open source rendering engine used to visualize web content loaded by Chrome.\nThe affected code uses MutationObserver objects to monitor and log specific events.\nThe MutationObserver objects are stored using raw pointers, which cause use-after-free\nissues if the object is no longer at the expected location in memory when the pointer is\nreferenced.  Exploiting this vulnerability requires the creation and subsequent deletion\nof a MutationObserver object, which will result in denial-of-service when a crash is caused.\n","mistakes":"A developer removed support for specific heap memory testing, which was relevant \nas the vulnerability resulted in a heap related error when discovered.  Removal of\nthis support may have resulted in the six month discovery time for the vulnerability.\nThis issue may have been discovered with more robust unit testing, but only the developer\nwho implemented the fix added testing for the MutationObserver HashShet.  Improved testing\nand capability for testing could have lead to earlier discovery for this issue.\n"},{"id":927,"cve":"CVE-2014-1715","project_name":"chromium","description":"Path traversal vulnerability that can lead to creating a junction point (an\nalias to another directory) out of a valid directory within a sandboxed path\nto the root of the system partition, where critical files are kept.\n\nA valid directory within a sandboxed path can be explained as follows:\n\nImagine if the program is running in a directory called 'safe'. This directory\nis a valid directory for the user to access files in. This directory is\nwithin the sandboxed path (e.g. usr/program/safe). Anything outside this sandboxed\npath is considered unsafe and therefore an invalid directory.\n","mistakes":"Ultimately, this vunerability was the direct cause of a coding mistake,\nhowever, the coding mistake is very obscure and could easily be overlooked\nby someone either inexperienced with the nitty-gritty specifics of file\nsystems, or by someone who may be aware but just wasn't super vigilant of\nthis particular issue.\n\nProper mitigations such as making sure we're still in the sandbox directory\nwere taken, however this vulnerability simply went a step beyond such a simple\nmitigation.\n\nIt should also be noted that the VCC was by a single person adding \u003e900 lines\nof a code, which is definitely error prone.\n\nI think this really goes to show you that mitigations are far from perfect.\nI'd say based off of what we've done in class and what we've seen about\nmitigations regarding path traversal, those steps were taken. But even with\nthose steps, the vulnerability in this case is still disastrous.\n\nSomething as niche as this most likely would require outside sources, such as\na security expert, or in this case -- a competition, to clearly identify the\nvulnerability and handle the mitiagtion properly.\n"},{"id":881,"cve":"CVE-2013-6628","project_name":"chromium","description":"Google Chrome was not checking that the servers digital certificate, which exists as \npart of the SSL authorization process, is the same during renegotiation of the client socket as it was \nbefore the renegotiation. Renegotiation is a way to adjust the the parameters of the SSL \nhandshake without needing to make a new SSL session. This means that remote web servers could \ninterfere with trust relationships of a session.\n\nAn example attack of this would involve starting a renegotiation during the authentication between \nthe server and client, changing the certificate sent by the server so that it gets authenticated by the client.\n","mistakes":"This was either a design mistake or a coding mistake but I am leaning more towards design mistake. \nAt some point they know that renegotiation of sockets happens, and they know that there is a certificate proving \nwhat you were before renegotiation. No one had considered(at a design point) that during renegotiation the certificate \ncould be changed. And up until the point that renegotiation got handled in the code, no one included any cases for if \nit had or added code saying it could not.\n"},{"id":213,"cve":"CVE-2011-0776","project_name":"chromium","description":"On Mac, Chrome's sandbox can be escaped to obtain information about local files.","mistakes":"The issue ultimately derived from Mac allowing calling stat() on arbitrary paths when that isn't expected. This required Chromium to adjust its access to that call. The issue also could have been avoided if Mac's interface to the stat() system call was in line with user expectations."},{"id":496,"cve":"CVE-2011-3096","project_name":"chromium","description":"There was a vulnerability on Linux machines that would allow remote hackers to\ncause a denial of service attack through use-after-free of a particular error\nin the GTK implementation of the omnibox, a web browser address bar that also\nacts as a search engine. GTK is a toolkit used for creating graphical user\ninterfaces.\n","mistakes":"After sifting through all of the commits and posts about the vulnerability,\nI would have to say that this mistake came from a misunderstanding of how\nGTK handles object removal. Unfortunately, the programmer was under the\nimpression that GTK would handle closing the signal listeners for them.\nBecause of this misunderstanding of a third party dependency, the\nvulnerability slipped into the code. I would have expected there to be a\ntest to see if you could still call the signals even after destroying the\nobject, but there was no such tests.\n"},{"id":1238,"cve":"CVE-2016-1652","project_name":"chromium","description":"Cross-site scripting (XSS) vulnerability in the ModuleSystem::RequireForJsInner\nfunction in extensions/renderer/module_system.cc in the Extensions subsystem\nin Google Chrome before 50.0.2661.75. This allows remote attackers to inject\narbitrary web script or HTML via a crafted web site, aka \"Universal XSS (UXSS).\"\nShould an attacker inject their own scripts, they will be able to spread malicious\ncode to various end user's. The attacker could compromise a user's browser data\nand even alter the content of an HTML page.\n","mistakes":"The mistake leading to this vulnerability, was simply rooted within a\nprivacy issue regarding getters and setters. These were modified to deal\nwith private properties instead of regular properties. These was done to\nmake interception harder from the outside. By privatizing properties, they\nbecome less accessible to attackers, helping to eliminate the acquistion of\ndata that should not be publicly transmitted. The mistake was truly a simple\ncoding mistake that was corrected in conjunction with additional files as support.\nIt was fixed within a matter of days, which attests to the fact that not much\nneeded to change to mitigate the vulnerability.\n"},{"id":1243,"cve":"CVE-2016-1657","project_name":"chromium","description":"The method to force focus on the address bar to allow a user to overwrite the\ncontents of the address bar would misbehave when a user, or site, uses a method \nto generate a blank page. The method would append the new url onto the existing \nblank page url. This would allow the page url to appear as a different page, \nallowing an attacker to spoof a site to gather information from an unsuspecting \nuser.\n","mistakes":"The vulnerability was due to trusting users. They were allowed to append to \nthe url on an about:blank page to essentially spoof a website.\n\nThe fix prevents the address bar from being focused and appended to if the\nabout:blank page wasn't created as the startup page. This prevents an attacker\nfrom creating an about:blank page and appending to the url. This fix should \nbe permanent."},{"id":751,"cve":"CVE-2013-0884","project_name":"chromium","description":"Initially, the code allowed the specific urls to run Native client applications until special privileges were added. With special privileges being added, the code is to be removed because granting special privileges to HTTP URLs isn't a good idea. HTTPS and public keys are to be forced for this subdomain.","mistakes":"The only mistake that occurred was designing the system. They didn't think\nabout the subdomain that was added in the fix for 8 months until special\nprivileges were granted to users.\n"},{"id":1242,"cve":"CVE-2016-1656","project_name":"chromium","description":"The download manager did not check the file name to make sure that an attacker\ncan't download a file to an unwanted directory outside of the Chrome folder for\ndownloads. This vulnerability occurs when a user downloads a file from a website\nand the website change the file's name with a relative path cause Chrome to\nput the file in a wrong directory with the http request.\n","mistakes":"The team did apply the filename sanitizer; however, it was not part of the\nhttp request content disposition sanitization. What we can learn from this\nis when working with a download manager, you have to make sure the manager\nsanitize the filename and the file path from the http content disposition.\nI would say this is part of requirement mistake because the download manager\nis a critical part of the browser task and people use the download manager\ndaily makes the manager a security risk.\n"},{"id":1346,"cve":"CVE-2016-5171","project_name":"chromium","description":"WebKit/Source/bindings/templates/interface.cpp allows for constructor calls to be\nused, when that constuctor shouldn't be allowed. If able to get a constructor to\nmake one of these illegal calls, it can cause the particalar system to crash or \nstop working, causing a denial of service.\n","mistakes":"What seemed to lead to this vulnerability not being found was using their \nown testing class and methods instead of incorperating already created \ntesting options. This is seen at the final commit of this code, where all \nof the custom testing methods mode were deleted.\n\nThis was created by one person (for the most part), and I think this person\neither did not know about testing packages out there, or did not want to\nuse them. I think this shows that using packages or reliable code from\nothers is ok to do in the right situation. This would have saved a lot of\ntime and effort if it was done right away.\n\nI wasn't unable to really figure out what was going on, but it seemed to be \na very simple fix to get this vulnerability fixed. When defining the local\nV8 template variable, they made a funciton value without specifing the parameter,\n\"V8ObjectConstructor::isValidConstructorMode\". Maybe an extra parameter was added\nin later to allow for specific constructors to have their specific functions, but\nit is very unclear from the code that I saw.\n"},{"id":1365,"cve":"CVE-2017-15394","project_name":"chromium","description":"Embargoed. URL spoofing in extensions UI.\n","mistakes":null},{"id":1101,"cve":"CVE-2015-1268","project_name":"chromium","description":"A Document Object Model wrapper could be returned with an incorrect scope, allowing the remote attacker to bypass the Same Origin Policy. This policy limits scripts from a webpage to only access information on a second webpage with the same protocol, domain, and host.","mistakes":"This vulnerability's VCCs were made over the course of 8 months, by two people, one of which will be the patcher of the vulnerability. This tells me that there could have been a design mistake that led to passing in a type that was not intended to be there, or was intended to be there and the consequences weren't understood. If it was not a design mistake, I'd suspect that it was a lack of knowledge about the effects of the type being passed in."},{"id":1091,"cve":"CVE-2015-1258","project_name":"chromium","description":"A specific webm file was able to crash Chromium when opened in a tab. The webm caused a\nnegative size parameter error in a Chromium dependency, libvpx. From what I can understand\nfrom the technical solution discussion on the issue report, this negative size parameter caused\na buffer overflow.\n","mistakes":"On the libvpx side, it's likely that there are some coding mistakes allowing such a vulernability to exist\nor communication mistakes in not making the importance of the size limit flag not obvious enough. On the\nChromium team's side, I would say that they were not thorough enough in their research of libvpx and the\nflags available to them when building it to be used within Chromium, as their omission of the size limit\nallowed for this vulnerability. Since this is a very niche vulnerability mainly caused by configuration\nissues of a third party dependency, the mitigations for the CWE are not particularly relevant or useful.\n"},{"id":954,"cve":"CVE-2014-1745","project_name":"chromium","description":"This was a vulnerability in the SVG implementation of Blink, Chrome's\nrendering engine, that allowed for a denial of service attack.\n\nA change was made to enhance the performance of the implementation, and allow\nthe browser to selectively update font rules of a page, rather than having\nto reload the entire FontSelector when things are changed. The vulnerability\nwas caused by the removal method, wherein not all references to a removed\nelement were cleared, even after said element's memory was freed. \n\nThe program would still attempt to use these elements, and would either crash\nor have unspecified behavior. \n","mistakes":"After analyzing the bug report and comments that followed, as well as the\ndiscussion on the VCC, it seems clear that this vulnerability was a simple\ncoding mistake.\n\nThe author of the VCC simply overlooked a reference in a major enhancement\nto the renderer, and fixed it after the vulnerability was reported. \n"},{"id":24,"cve":"CVE-2009-2060","project_name":"chromium","description":"The Vulnerability was in authentication. A false positive or improper\nchecking has been done on the validity of the identity of someone. The HTTP\nHost header was used in responses from a proxy server.  When a certain\nresponse was given, someone passing the response along was able to change\nthe content. This man-in-the-middle attack can occur relatively undetected.\n","mistakes":"The main root cause of this was oversight when testing scenarios that could\nhappen but were never accounted for. The way it was caught was by observing\nthe result from one specific input. It is often difficult to have catch for\nevery situation when developing.\n"},{"id":1180,"cve":"CVE-2015-6780","project_name":"chromium","description":"This vulnerability allows for remote actors to cause denial of service or \nother damage to chrome. The issue is a use-after-free vulnerability and exists \nin the Infobars version of Google Chrome. Use-after-free refers to memory that \nhas been allocated, used, and then freed, but is then able to be used again \n(where it is not supposed to be). Infobars are displayed below the url bar when \nthere is related information that is important to inform the user about. In \nthis case a malicious actor could abuse freed memory through the chrome InfoBar \nto [tear] down the whole browser.\n","mistakes":"This vulnerability was caused by a mistake made at the code level.\nUltimately the developers never reset a pointer that attackers would have\nbeen able to leverage to cause denial of service in chrome. After this\npointer was freed, attackers would be able to use the memory address to\nbring down the service.\n"},{"id":397,"cve":"CVE-2011-2849","project_name":"chromium","description":"The webSockets implementation in Chromium had a vulnerability due to the\nreferencing of a NULL pointer. When a browser tab was closed it would make\nthe current web socket null, however, if the tab still had stacked sending jobs\n(SendPending) it would attempt to reference the NULL socket pointer resulting\nin the browser crashing. This vulnerability could have been used to cause a\ndenial of service attack.\n","mistakes":"The coding mistake was an edge case in which closing a tab would destroy\nthe websocket but the WebSocketJob would continue sending multiple sending\njobs. This resulted in the use of a NULL pointer which could cause a denial\nof service.\n\nThis mistake came about as a result of three commits from two individuals.\nThe first of these commits added the majority of the code which had this\nvulnerability and the vulnerability was likely due to the developer not\nthinking about this edge case. Since he didn't anticipate the issue, the\nother individual working on the code didn't notice it, and the automated\nunit tests didn't catch it, the bug slipped through. In the future more\nvigorous test likely could have caught the bug. Being more familiar with the\nuse and intricacies of using websockets would aid in preventing the mistake.\n\nThe Chromium team uses the Modern Code Review (MCR) process whose\neffectiveness has come under question in recent years. Both of the original\nauthors of the VCCs have many code reviews during the time between when the\nbug was introduced and was fixed, some of which were on the code base\ncontaining the vulnerability. This again brings into question either the\neffectiveness of MCR or the effectiveness of the reviewers.\n\nSource: http://ieeexplore.ieee.org/document/7781793/\n"},{"id":1234,"cve":"CVE-2016-1648","project_name":"chromium","description":"The vulnerability occured in Google Chrome's Extensions, specifically in the GetLoadTimes function of renderer/loadtimes_extension_bindings.cc.\nAn attempt to access memory was made after the memory was freed, causing a use-after-free vulnerability. Attackers can use this to crash the system and cause denial of service problems, or use the memory access to perform some action in memory not defined by the system. By using a technique like Cross-Site Scripting (XSS), attackers can write their own javascript and have it run by the system.","mistakes":"From my research, I would mark this vulnerability as the result of a big design change at one time that allowed a simple but big mistake to slide through. The file was being almost enirely rewritten to improve performance and update the techniques used, so it was likely for something like this to happen.\nThe fix changed a lot of code in the file, but if you look at the changes, the overall flow of the code didn't really change. The design was modified to check for a failed set instead of relying on a successful set, as well as nulling the incoming arguement automatically instead of doing it only if the frame, data_source, or document_state failed to be retrieved. From most of the angles you look at it, it seems like just a design mistake from the performance update.\nThe takeaway from this is to remember the basics as you are designing a bigger chunk of code because a few small mistakes can chain together and cause a bigger vulnerability."},{"id":908,"cve":"CVE-2013-6660","project_name":"chromium","description":"Extra information can be gathered by wesites about where you are uploading a file from which can be a data leak.\nThe extra information that can be gathered is the location of the file on the local filesystem which is information a website does not have a need for.\nThe information is available becuase when a file is dropped into Chrome it fills in the URL data (attribute of the object) with the local file path.\n","mistakes":"It looks like this vulnerability could have been prevented if the team developing the drag and drop functionanlity kept information leaks in mind a little more.\n"},{"id":1376,"cve":"CVE-2017-15405","project_name":"chromium","description":"Symlink traversal in cryptohomed that allows a persistence established by malicious code\nwith a race condition. Cryptohomed is able to execute commands as root. This is a execution\nwith elevated privileges example.\n","mistakes":"In my opinion this was a coding and design mistake. The race condition and symlink vulnerability was not just a coding mistake because it involved path traversal and therefore would have been difficult to pinpoint in just code. Avoiding a symlink by using a value from a config file or using a string in the code could have prevented this vulnerability."},{"id":1029,"cve":"CVE-2014-7941","project_name":"chromium","description":"One of the functions in the applications uses an int data type for a certain value that can get particularly large.  Since int variables have a smaller maximum value the variable was going over the max and looping back to the negative values.  Having negative values could cause a denial of service.","mistakes":"This vulnerability was caused by a coding mistake. The developers did\nnot fully think through what data would be stored in this variable.\nFrom this bug, you can see how useful fuzzers can be. Two different\nfuzzers were able to find this bug, which shows that it is not\nsuper difficult to make a useful fuzzer.\n"},{"id":1093,"cve":"CVE-2015-1260","project_name":"chromium","description":"Attackers can execute arbitrary JavaScript code upon completion of a\ngetUserMedia request. The Object in question was destroyed within the \nsubroutine it was being called in, allowing the memory to be accessed after it has \nbeen freed.\n","mistakes":"The mistake for this vulnerability was made when an engineer decided to \nremove the default case of the switch as well as move a critical function \ncall that is executed when none of the cases match. While this function was \nmoved, the function itself was not changed and thereby the Object was \ndeleted from memory but then accessed again in certain use cases.\n"},{"id":1206,"cve":"CVE-2016-1619","project_name":"chromium","description":"A PDF file containing a malformed JP2 image can cause an out-of-bounds read \nin the openjpeg library. Remote attackers are able to cause a denial of servie \n(out-of-bounds read) via a created PDF document. The error occures when the \n{PDF is being parsed and an JP2 image is found and rendered.\n","mistakes":"Codex code is very complex and is generally created and then left alone. \nSoftware engineers don't want to have to continuously look how a PDF is rendered\nand prefer to just assume it works as intended and leave it alone. This may be \nproblamatic for changing systems. This vulnerability could have led to a denial \nof service attack by crashing the server. Software engineers must be wary of what libraries \nthey are using and protect their system from outside vulnerabilities.\n"},{"id":283,"cve":"CVE-2011-1435","project_name":"chromium","description":"The implementation of permissions for browser extensions was not properly secured.\nPlugins utilizing the file system could use this error to access files outside of their designated\nsandbox. This allowed an attacker to access any files on a user's system using malicious code\ninserted into a browser extension, assuming some knowledge of the user's file structure. They were\nable to access these files at the same level of permissions as they would have in their sandbox,\ni.e. read and write permissions.\n","mistakes":"I feel that there was a design mistake made to lead to this vulnerability.\nThe design decision to allow for unrestricted access to the file system with \na lower level permission led to this vulnerability. It seems that it was an\noversight not to disallow file access outside of a plugin's sandbox.\n"},{"id":320,"cve":"CVE-2011-1811","project_name":"chromium","description":"Having a large number of forms on a webpage would cause the browser to crash.\n","mistakes":"The original programmers did not think about the extreme cases of their code.\nThey didn't put a obvious limit on chrome form autofills. They did for the fix, around 1000.\nThe fix is common sense and should have been in the code originally,\nmaking the fix pretty trivial and obvious.\n"},{"id":321,"cve":"CVE-2011-1812","project_name":"chromium","description":"Chrome before 12.0.742.91 allows remote attackers to bypass intended access\nrestictions through certain extensions. The tabs permissions defined in the\nmanifest file of Chrome extensions could be bypassed if a webpage was spoofed.\n","mistakes":"I think that this vulnerability was introduced because all edge cases weren't thought of. The conversation between developers discussing the vuln shows that the scenario is a very specific issue that exists within permissions of extentions."},{"id":323,"cve":"CVE-2011-1814","project_name":"chromium","description":"","mistakes":null},{"id":324,"cve":"CVE-2011-1815","project_name":"chromium","description":"","mistakes":null},{"id":325,"cve":"CVE-2011-1816","project_name":"chromium","description":"","mistakes":null},{"id":455,"cve":"CVE-2011-3054","project_name":"chromium","description":"","mistakes":null},{"id":456,"cve":"CVE-2011-3055","project_name":"chromium","description":"","mistakes":null},{"id":327,"cve":"CVE-2011-1818","project_name":"chromium","description":"","mistakes":null},{"id":328,"cve":"CVE-2011-1819","project_name":"chromium","description":"","mistakes":null},{"id":329,"cve":"CVE-2011-2075","project_name":"chromium","description":"","mistakes":null},{"id":330,"cve":"CVE-2011-2332","project_name":"chromium","description":"Universal Cross Site Scripting exploit possible when abusing window.execScript.","mistakes":null},{"id":331,"cve":"CVE-2011-2342","project_name":"chromium","description":"","mistakes":null},{"id":333,"cve":"CVE-2011-2346","project_name":"chromium","description":"","mistakes":null},{"id":334,"cve":"CVE-2011-2347","project_name":"chromium","description":"","mistakes":null},{"id":335,"cve":"CVE-2011-2348","project_name":"chromium","description":"","mistakes":null},{"id":336,"cve":"CVE-2011-2349","project_name":"chromium","description":"","mistakes":null},{"id":337,"cve":"CVE-2011-2350","project_name":"chromium","description":"","mistakes":null},{"id":338,"cve":"CVE-2011-2351","project_name":"chromium","description":"","mistakes":null},{"id":340,"cve":"CVE-2011-2359","project_name":"chromium","description":"","mistakes":null},{"id":341,"cve":"CVE-2011-2360","project_name":"chromium","description":"","mistakes":null},{"id":343,"cve":"CVE-2011-2599","project_name":"chromium","description":"","mistakes":null},{"id":344,"cve":"CVE-2011-2761","project_name":"chromium","description":"","mistakes":null},{"id":345,"cve":"CVE-2011-2782","project_name":"chromium","description":"The drag-and-drop implementation in Google Chrome on Linux does not properly\nenforce permissions for files. This allows attackers to create a file link on their \nwebsite (e.x. \u003ca href=\"file:///etc/passwd\"\u003e) and if the user drags this link onto something\nlike a file upload, and it will upload the file from the users device.\n","mistakes":"This vulnerability was clearly a design flaw as the developers, from the conversation on the bug, clearly did not anticipate drag-and-drop not working properly when a URL linking to a file was dragged in as opposed to the file itself."},{"id":347,"cve":"CVE-2011-2784","project_name":"chromium","description":"","mistakes":null},{"id":457,"cve":"CVE-2011-3056","project_name":"chromium","description":"","mistakes":null},{"id":458,"cve":"CVE-2011-3057","project_name":"chromium","description":"","mistakes":null},{"id":459,"cve":"CVE-2011-3058","project_name":"chromium","description":"","mistakes":null},{"id":350,"cve":"CVE-2011-2787","project_name":"chromium","description":"Failing to lock and unlock the GPU allows for reentrancy issues allowing\nremote attackers to execute a denial of service attack, crashing the application\nusing unspecified vectors.\n","mistakes":"This would likely best fit into a design flaw because it was likely an overlooked\nedge case of concurrent operation on the GPU. This was likely overlooked by the\ncode review and QA as a result of a missing vector when looking for potential flaws\n"},{"id":351,"cve":"CVE-2011-2788","project_name":"chromium","description":"","mistakes":null},{"id":352,"cve":"CVE-2011-2789","project_name":"chromium","description":"","mistakes":null},{"id":353,"cve":"CVE-2011-2790","project_name":"chromium","description":"","mistakes":null},{"id":354,"cve":"CVE-2011-2791","project_name":"chromium","description":"","mistakes":null},{"id":355,"cve":"CVE-2011-2792","project_name":"chromium","description":"","mistakes":null},{"id":356,"cve":"CVE-2011-2793","project_name":"chromium","description":"","mistakes":null},{"id":357,"cve":"CVE-2011-2794","project_name":"chromium","description":"","mistakes":null},{"id":358,"cve":"CVE-2011-2795","project_name":"chromium","description":"","mistakes":null},{"id":359,"cve":"CVE-2011-2796","project_name":"chromium","description":"","mistakes":null},{"id":360,"cve":"CVE-2011-2797","project_name":"chromium","description":"","mistakes":null},{"id":361,"cve":"CVE-2011-2798","project_name":"chromium","description":"","mistakes":null},{"id":362,"cve":"CVE-2011-2799","project_name":"chromium","description":"","mistakes":null},{"id":363,"cve":"CVE-2011-2800","project_name":"chromium","description":"","mistakes":null},{"id":364,"cve":"CVE-2011-2801","project_name":"chromium","description":"","mistakes":null},{"id":365,"cve":"CVE-2011-2802","project_name":"chromium","description":"","mistakes":null},{"id":366,"cve":"CVE-2011-2803","project_name":"chromium","description":"","mistakes":null},{"id":367,"cve":"CVE-2011-2804","project_name":"chromium","description":"","mistakes":null},{"id":368,"cve":"CVE-2011-2805","project_name":"chromium","description":"","mistakes":null},{"id":369,"cve":"CVE-2011-2806","project_name":"chromium","description":"","mistakes":null},{"id":370,"cve":"CVE-2011-2818","project_name":"chromium","description":"","mistakes":null},{"id":371,"cve":"CVE-2011-2819","project_name":"chromium","description":"","mistakes":null},{"id":372,"cve":"CVE-2011-2821","project_name":"chromium","description":"Google was using the libxml2 library for Chrome. The way they were using the\nlibrary allowed attackers to cause a double free by entering certain types\nof code in a query. A double free can result in memory being changed that\nyou did not anticipate, which can result in a Denial of Service attack.\nAdditionally the memory that was freed twice can also cause malloc to get\ncalled on it twice, resulting in a pointer being returned to the same\nlocation in memory for two different malloc calls. This could also allow for\na buffer overflow attack.\n","mistakes":"This vulnerability was introduced because of the use of the libxml\nlibrary. We all use libraries to make our work easier, but have to\nremember that those libraries can introduce as many vulnerabilities\nas our own code does.\nLooking at the changes to the lxml library this looks to be a coding\nmistake where it was assumed some data structures could never be\nmodified. This turned out to be incorrect.\n"},{"id":373,"cve":"CVE-2011-2822","project_name":"chromium","description":"","mistakes":null},{"id":374,"cve":"CVE-2011-2823","project_name":"chromium","description":"","mistakes":null},{"id":375,"cve":"CVE-2011-2824","project_name":"chromium","description":"","mistakes":null},{"id":376,"cve":"CVE-2011-2825","project_name":"chromium","description":"","mistakes":null},{"id":377,"cve":"CVE-2011-2826","project_name":"chromium","description":"","mistakes":null},{"id":378,"cve":"CVE-2011-2827","project_name":"chromium","description":"","mistakes":null},{"id":379,"cve":"CVE-2011-2828","project_name":"chromium","description":"","mistakes":null},{"id":380,"cve":"CVE-2011-2829","project_name":"chromium","description":"","mistakes":null},{"id":381,"cve":"CVE-2011-2830","project_name":"chromium","description":"","mistakes":null},{"id":383,"cve":"CVE-2011-2835","project_name":"chromium","description":"The cache has a race condition when being used by the X507 certificate. It was a very difficult problem,\nas it would probably need some significant changes to one or more of the already existing APIs in use.\n","mistakes":"I believe that the main mistake was improper knowledge of the systems. By using\na raw certificate, it caused race conditions that in the end were easily mitigated.\nThe use of os specific wrappers around the certificates was not an obvious solution, but\nan elegant one. \n"},{"id":385,"cve":"CVE-2011-2837","project_name":"chromium","description":"Google Chrome had a Linux specific bug based in compiler options. The compiler\nwas not configured to use the PIC (Position Independent Code) and PIE\n(Position Independent Executable). Since the code wasn't being compiled as \nexpected, the attack surface was unpredictable.\n\nThe most plausible security attack here could have been related to denial of\nservice on certain machines due to compilitation related crashes. Because there is\nmemory positioning involved with the vulnerability, information disclosure could\nalso be an issue in the case of an overflow.\n\nThe chrome team's conversation didn't seem very concerned with the details of\npossible attacks here, and the security severity of the bug was low. Security-wise\nthis seemed like a \"better safe than sorry\" situation.\n","mistakes":"This seems to be a vulnerability that was caused by overlooking some of the\nfiner detail of the compiler configuration. By missing the proper compiler\nflags, unpredictable behavior was introduced into the system. The CWE-684 is\nsimply that Code does not function due to published specifications, which is\na bit vague. The mitigation suggested is also brief: make sure the Code adheres\nto the specifications. It appears that the Google team did that once they found\nthe issue. It's hard to tell if the ultimate cause of the vulnerability was an\noutright design mistake or just a coding mistake when creating the configuration\nfile, but improved communication of the proper settings for specific platforms\nwould have definitely helped the team.\n"},{"id":386,"cve":"CVE-2011-2838","project_name":"chromium","description":"","mistakes":null},{"id":387,"cve":"CVE-2011-2839","project_name":"chromium","description":"","mistakes":null},{"id":460,"cve":"CVE-2011-3059","project_name":"chromium","description":"","mistakes":null},{"id":461,"cve":"CVE-2011-3060","project_name":"chromium","description":"","mistakes":null},{"id":469,"cve":"CVE-2011-3068","project_name":"chromium","description":"","mistakes":null},{"id":389,"cve":"CVE-2011-2841","project_name":"chromium","description":"","mistakes":null},{"id":390,"cve":"CVE-2011-2842","project_name":"chromium","description":"","mistakes":null},{"id":392,"cve":"CVE-2011-2844","project_name":"chromium","description":"","mistakes":null},{"id":394,"cve":"CVE-2011-2846","project_name":"chromium","description":"","mistakes":null},{"id":395,"cve":"CVE-2011-2847","project_name":"chromium","description":"","mistakes":null},{"id":399,"cve":"CVE-2011-2851","project_name":"chromium","description":"Video conversion and transformations were not being properly handled, which\ncould allow remote attackers to cause a denial of service.\n\nThis vulnerability was the result of accessing an array at x-1 when x == 0.\n","mistakes":"This was a coding mistake made by overlooking possible bad inputs. When\nthe main functions of the file were added, the author failed to recognize\nthat certain inputs could break their code. The fix was implemmented in a\nsingle line which terminated the function if the problem inputs were entered.\n"},{"id":400,"cve":"CVE-2011-2852","project_name":"chromium","description":"","mistakes":null},{"id":401,"cve":"CVE-2011-2853","project_name":"chromium","description":"","mistakes":null},{"id":402,"cve":"CVE-2011-2854","project_name":"chromium","description":"","mistakes":null},{"id":403,"cve":"CVE-2011-2855","project_name":"chromium","description":"","mistakes":null},{"id":404,"cve":"CVE-2011-2856","project_name":"chromium","description":"","mistakes":null},{"id":405,"cve":"CVE-2011-2857","project_name":"chromium","description":"","mistakes":null},{"id":408,"cve":"CVE-2011-2860","project_name":"chromium","description":"","mistakes":null},{"id":409,"cve":"CVE-2011-2861","project_name":"chromium","description":"","mistakes":null},{"id":410,"cve":"CVE-2011-2862","project_name":"chromium","description":"","mistakes":null},{"id":412,"cve":"CVE-2011-2874","project_name":"chromium","description":"","mistakes":null},{"id":413,"cve":"CVE-2011-2875","project_name":"chromium","description":"","mistakes":null},{"id":414,"cve":"CVE-2011-2876","project_name":"chromium","description":"","mistakes":null},{"id":415,"cve":"CVE-2011-2877","project_name":"chromium","description":"","mistakes":null},{"id":416,"cve":"CVE-2011-2878","project_name":"chromium","description":"","mistakes":null},{"id":417,"cve":"CVE-2011-2879","project_name":"chromium","description":"","mistakes":null},{"id":418,"cve":"CVE-2011-2880","project_name":"chromium","description":"","mistakes":null},{"id":419,"cve":"CVE-2011-2881","project_name":"chromium","description":"","mistakes":null},{"id":420,"cve":"CVE-2011-3015","project_name":"chromium","description":"","mistakes":null},{"id":421,"cve":"CVE-2011-3016","project_name":"chromium","description":"","mistakes":null},{"id":422,"cve":"CVE-2011-3017","project_name":"chromium","description":"","mistakes":null},{"id":423,"cve":"CVE-2011-3018","project_name":"chromium","description":"","mistakes":null},{"id":424,"cve":"CVE-2011-3019","project_name":"chromium","description":"","mistakes":null},{"id":425,"cve":"CVE-2011-3020","project_name":"chromium","description":"","mistakes":null},{"id":426,"cve":"CVE-2011-3021","project_name":"chromium","description":"","mistakes":null},{"id":427,"cve":"CVE-2011-3022","project_name":"chromium","description":"Javascript used by Chrome to translate web pages is downloaded over HTTP. This script is executed in the context of the web page to be translated.\ntranslate/translate_manager.cc in Google Chrome before 17.0.963.56 and 19.x before 19.0.1036.7 uses an HTTP session to exchange data for translation, which allows remote attackers to obtain sensitive information by sniffing the network.","mistakes":"A small coding mistake was made in that a page's url could contain javasript\nthat could be potentially executed. In general, it is important to sanitize\nurls whenever they are being obtained, because regardless of who is providing them,\nurls still could contain malicious content.\n"},{"id":428,"cve":"CVE-2011-3023","project_name":"chromium","description":"","mistakes":null},{"id":430,"cve":"CVE-2011-3025","project_name":"chromium","description":"","mistakes":null},{"id":431,"cve":"CVE-2011-3026","project_name":"chromium","description":"When a function is called to expand the size of a PNG (within Google Chrome),\nthe value associated with the size of the PNG can be as large as requested\n(meaning there is no size limitation). The reason it can be so arbitrarily\nlarge is because in the process of inflating a compressed image holds the need\nto \"throw away\" chunks of data if (when they are decompressed) have an output\narguement of 0. Due to this vulnerability, malicious users can exploit this\nand create a value for the data that when expanded is greater than the type\nvalue (png_size_t) can hold causing an overflow. This obviously leads to\nmemory allocation issues and heap-buffer-overflow. It is a possible entry\npoint for malicious attackers to implement a DoS or possibly have unspecified\nother impact(s) by tampering with integers via truncation.\n","mistakes":"Overlooking input due to face value of the input being an image as opposed to some data that is taken in as strings or characters. It was a fairly complex vulnerability to even catch. but a relatively simple fix."},{"id":432,"cve":"CVE-2011-3027","project_name":"chromium","description":"","mistakes":null},{"id":433,"cve":"CVE-2011-3031","project_name":"chromium","description":"","mistakes":null},{"id":434,"cve":"CVE-2011-3032","project_name":"chromium","description":"","mistakes":null},{"id":435,"cve":"CVE-2011-3033","project_name":"chromium","description":"","mistakes":null},{"id":436,"cve":"CVE-2011-3034","project_name":"chromium","description":"","mistakes":null},{"id":437,"cve":"CVE-2011-3035","project_name":"chromium","description":"","mistakes":null},{"id":438,"cve":"CVE-2011-3036","project_name":"chromium","description":"","mistakes":null},{"id":439,"cve":"CVE-2011-3037","project_name":"chromium","description":"","mistakes":null},{"id":440,"cve":"CVE-2011-3038","project_name":"chromium","description":"","mistakes":null},{"id":441,"cve":"CVE-2011-3039","project_name":"chromium","description":"","mistakes":null},{"id":442,"cve":"CVE-2011-3040","project_name":"chromium","description":"","mistakes":null},{"id":443,"cve":"CVE-2011-3041","project_name":"chromium","description":"","mistakes":null},{"id":444,"cve":"CVE-2011-3042","project_name":"chromium","description":"","mistakes":null},{"id":445,"cve":"CVE-2011-3043","project_name":"chromium","description":"","mistakes":null},{"id":446,"cve":"CVE-2011-3044","project_name":"chromium","description":"","mistakes":null},{"id":448,"cve":"CVE-2011-3046","project_name":"chromium","description":"","mistakes":null},{"id":449,"cve":"CVE-2011-3047","project_name":"chromium","description":"","mistakes":null},{"id":451,"cve":"CVE-2011-3050","project_name":"chromium","description":"","mistakes":null},{"id":452,"cve":"CVE-2011-3051","project_name":"chromium","description":"","mistakes":null},{"id":470,"cve":"CVE-2011-3069","project_name":"chromium","description":"","mistakes":null},{"id":471,"cve":"CVE-2011-3070","project_name":"chromium","description":"","mistakes":null},{"id":472,"cve":"CVE-2011-3071","project_name":"chromium","description":"","mistakes":null},{"id":473,"cve":"CVE-2011-3072","project_name":"chromium","description":"","mistakes":null},{"id":474,"cve":"CVE-2011-3073","project_name":"chromium","description":"","mistakes":null},{"id":475,"cve":"CVE-2011-3074","project_name":"chromium","description":"","mistakes":null},{"id":476,"cve":"CVE-2011-3075","project_name":"chromium","description":"","mistakes":null},{"id":477,"cve":"CVE-2011-3076","project_name":"chromium","description":"","mistakes":null},{"id":478,"cve":"CVE-2011-3077","project_name":"chromium","description":"","mistakes":null},{"id":479,"cve":"CVE-2011-3078","project_name":"chromium","description":"","mistakes":null},{"id":480,"cve":"CVE-2011-3079","project_name":"chromium","description":"Inter-process Communication implementation does not correctly validate\nmessages allowing for attack vectors. It is possible to create a fake\nlistener process that does not have the proper permissions to connect to\na pipe started by the browser's process and cause a privledge escalation.\n","mistakes":"The mistake was trusting the pipe of input given to the process. By just\nassigning a random id to the process and adding it the system was trusting\nit by default. The fix worked by giving it a specific id so that it could\nbe controlled properly.\n\nIt was introduced when child process hosts were refactored through an\ninterface in content/public rather than inheritance.\n"},{"id":481,"cve":"CVE-2011-3080","project_name":"chromium","description":"","mistakes":null},{"id":482,"cve":"CVE-2011-3081","project_name":"chromium","description":"","mistakes":null},{"id":483,"cve":"CVE-2011-3083","project_name":"chromium","description":"The vulnerability allowed remote attackers to intentionally cause an\napplication crash by means of a specialized web page.\n\nIf an attacker placed an FTP URL in the SRC attribute of an HTML\n\u003cvideo\u003e tag, then a browser crash would inevitably result when a user\nvisited the web page and loaded the video.\n\nThis was caused by a failure to properly create FtpTransaction objects for\nmedia delivered over FTP. The FtpTransaction object handles FTP transactions\nbetween the web page and client. While the majority of non-media content\ndelivered over FTP used an FtpTransactionFactory object to create\ntransactions, any media content, like videos, delivered over FTP didn't\nuse the FtpTransactionFactory, which resulted in a NULL pointer dereference\nand a subsequent application crash when used.\n\nWhile the original reporter only noticed this issue when the FTP URL was\nwithin a \u003cvideo\u003e tag, the application would have similarly crashed if the user\nhad placed an FTP URL ending in a media file format (AVI, MP3, etc.) in\nChrome's address bar and hit enter. This was also the case for malformed\nFTP URLs with no file extension.\n","mistakes":"A simple coding mistake seems to have been the cause of this vulnerability.\nThroughout the file, there are many lines of code in which both the main and\nmedia context variables are modified together, one after the other. For example,\nthe function set_http_transaction_factory was called on both the main and media\ncontext variables. However, it seems that when the developer was writing the\ncode to call the function set_ftp_transaction_factory, they accidentally forgot\nabout the media context variable and only set the FTP transaction factory on\nthe main context variable. This led to no FtpTransaction objects being created\nfor media over FTP.\n\nThis might have been prevented if the developer was more careful when creating\nthe file, practiced pair programming, or if the code had undergone a more\nthorough code review before being released.\n"},{"id":484,"cve":"CVE-2011-3084","project_name":"chromium","description":"","mistakes":null},{"id":485,"cve":"CVE-2011-3085","project_name":"chromium","description":"","mistakes":null},{"id":486,"cve":"CVE-2011-3086","project_name":"chromium","description":"","mistakes":null},{"id":487,"cve":"CVE-2011-3087","project_name":"chromium","description":"","mistakes":null},{"id":488,"cve":"CVE-2011-3088","project_name":"chromium","description":"","mistakes":null},{"id":489,"cve":"CVE-2011-3089","project_name":"chromium","description":"","mistakes":null},{"id":490,"cve":"CVE-2011-3090","project_name":"chromium","description":"","mistakes":null},{"id":491,"cve":"CVE-2011-3091","project_name":"chromium","description":"","mistakes":null},{"id":493,"cve":"CVE-2011-3093","project_name":"chromium","description":"","mistakes":null},{"id":494,"cve":"CVE-2011-3094","project_name":"chromium","description":"The input validation vulnerability did not properly handle Tibetan text, and thus an\nout-of-bounds read could occur during Tibetan handling. If a Tibetan letter was followed\nby a Tibetan cantillation sign, a global buffer overflow would be reported.\n\nThe vulnerability was located in the method called tibetan_form().\n\nThis vulnerability could be exploited by remote attackers, who could execute arbitrary\ncode on the system and cause a denial of service via the out-of-bounds read through\nthe use of unspecified vectors. They can accomplish this by persuading a victim to\nvisit a specially-crafted web site or JavaScript program using Chromium or V8, where\nthey could exploit the vulnerability to trigger the out-of-bounds read in order to\nexecute the arbitrary code on the system.\n","mistakes":"A mistake that allowed for that out-of-bounds error was that some variable \"c\", which\nwhich represents the Tibetan unicode char hex value that can be used to find the index\nwith the involvement of some math, was allowed to be either less than or equal to 0x0fc0,\nwhich in turn allowed that out-of-bounds error to occur. It appeared to have been an\noversight in how the boundary cases were addressed and thus limited incorrectly.\n"},{"id":495,"cve":"CVE-2011-3095","project_name":"chromium","description":"","mistakes":null},{"id":497,"cve":"CVE-2011-3097","project_name":"chromium","description":"","mistakes":null},{"id":498,"cve":"CVE-2011-3098","project_name":"chromium","description":"","mistakes":null},{"id":499,"cve":"CVE-2011-3099","project_name":"chromium","description":"","mistakes":null},{"id":500,"cve":"CVE-2011-3100","project_name":"chromium","description":"","mistakes":null},{"id":501,"cve":"CVE-2011-3101","project_name":"chromium","description":"","mistakes":null},{"id":502,"cve":"CVE-2011-3102","project_name":"chromium","description":"","mistakes":null},{"id":503,"cve":"CVE-2011-3103","project_name":"chromium","description":"","mistakes":null},{"id":504,"cve":"CVE-2011-3104","project_name":"chromium","description":"","mistakes":null},{"id":505,"cve":"CVE-2011-3105","project_name":"chromium","description":"","mistakes":null},{"id":506,"cve":"CVE-2011-3106","project_name":"chromium","description":"","mistakes":null},{"id":507,"cve":"CVE-2011-3107","project_name":"chromium","description":"","mistakes":null},{"id":508,"cve":"CVE-2011-3108","project_name":"chromium","description":"","mistakes":null},{"id":509,"cve":"CVE-2011-3109","project_name":"chromium","description":"","mistakes":null},{"id":510,"cve":"CVE-2011-3110","project_name":"chromium","description":"","mistakes":null},{"id":511,"cve":"CVE-2011-3111","project_name":"chromium","description":"","mistakes":null},{"id":512,"cve":"CVE-2011-3112","project_name":"chromium","description":"","mistakes":null},{"id":513,"cve":"CVE-2011-3113","project_name":"chromium","description":"","mistakes":null},{"id":514,"cve":"CVE-2011-3114","project_name":"chromium","description":"","mistakes":null},{"id":515,"cve":"CVE-2011-3115","project_name":"chromium","description":"","mistakes":null},{"id":516,"cve":"CVE-2011-3234","project_name":"chromium","description":"","mistakes":null},{"id":517,"cve":"CVE-2011-3389","project_name":"chromium","description":"","mistakes":null},{"id":518,"cve":"CVE-2011-3640","project_name":"chromium","description":"","mistakes":null},{"id":519,"cve":"CVE-2011-3873","project_name":"chromium","description":"","mistakes":null},{"id":520,"cve":"CVE-2011-3875","project_name":"chromium","description":"","mistakes":null},{"id":522,"cve":"CVE-2011-3877","project_name":"chromium","description":"","mistakes":null},{"id":523,"cve":"CVE-2011-3878","project_name":"chromium","description":"","mistakes":null},{"id":524,"cve":"CVE-2011-3879","project_name":"chromium","description":"","mistakes":null},{"id":526,"cve":"CVE-2011-3881","project_name":"chromium","description":"","mistakes":null},{"id":528,"cve":"CVE-2011-3883","project_name":"chromium","description":"","mistakes":null},{"id":529,"cve":"CVE-2011-3884","project_name":"chromium","description":"A timing issues in the DOM traversal can cause denial of service attacks and\nremote vector issues or possible unknown issuess through a crafted document.\n\nThe DOM stands for Document Object Model and is a tree like structure, used to\nrepresent the HTML webpage.\n\nThe DOM traversal runs for at most 50ms before pausing to allow the WebkKit \nthread to run. If the frame is removed before the traversal resumes then it\nwill attempt to access a deleted WebFrame.\n\nThe fix is to ensure that the WebDocument is not null.\n\nAn interesting note is that these vulnerabilities are in a client side phishing\ndetection model.\n","mistakes":"The developers did not consider all the consequences for adding a time out.\nIt appears they were attempting to make the process quicker, since they even\nreduced the limit one time. \n\nManaging resources is an important part of security. Since you can not allways be\nsure that a resource or object will be available. Check for edge cases and attempt\nto prevent the possibility of freed resources being accessed."},{"id":530,"cve":"CVE-2011-3885","project_name":"chromium","description":"","mistakes":null},{"id":531,"cve":"CVE-2011-3887","project_name":"chromium","description":"","mistakes":null},{"id":532,"cve":"CVE-2011-3888","project_name":"chromium","description":"","mistakes":null},{"id":533,"cve":"CVE-2011-3889","project_name":"chromium","description":"","mistakes":null},{"id":534,"cve":"CVE-2011-3890","project_name":"chromium","description":"","mistakes":null},{"id":535,"cve":"CVE-2011-3891","project_name":"chromium","description":"","mistakes":null},{"id":536,"cve":"CVE-2011-3892","project_name":"chromium","description":"","mistakes":null},{"id":537,"cve":"CVE-2011-3893","project_name":"chromium","description":"","mistakes":null},{"id":538,"cve":"CVE-2011-3894","project_name":"chromium","description":"","mistakes":null},{"id":539,"cve":"CVE-2011-3895","project_name":"chromium","description":"","mistakes":null},{"id":540,"cve":"CVE-2011-3896","project_name":"chromium","description":"","mistakes":null},{"id":541,"cve":"CVE-2011-3897","project_name":"chromium","description":"","mistakes":null},{"id":543,"cve":"CVE-2011-3900","project_name":"chromium","description":"","mistakes":null},{"id":544,"cve":"CVE-2011-3903","project_name":"chromium","description":"","mistakes":null},{"id":545,"cve":"CVE-2011-3904","project_name":"chromium","description":"","mistakes":null},{"id":546,"cve":"CVE-2011-3905","project_name":"chromium","description":"","mistakes":null},{"id":547,"cve":"CVE-2011-3906","project_name":"chromium","description":"","mistakes":null},{"id":548,"cve":"CVE-2011-3907","project_name":"chromium","description":"","mistakes":null},{"id":549,"cve":"CVE-2011-3908","project_name":"chromium","description":"","mistakes":null},{"id":550,"cve":"CVE-2011-3909","project_name":"chromium","description":"","mistakes":null},{"id":551,"cve":"CVE-2011-3910","project_name":"chromium","description":"","mistakes":null},{"id":552,"cve":"CVE-2011-3911","project_name":"chromium","description":"","mistakes":null},{"id":553,"cve":"CVE-2011-3912","project_name":"chromium","description":"","mistakes":null},{"id":554,"cve":"CVE-2011-3913","project_name":"chromium","description":"","mistakes":null},{"id":555,"cve":"CVE-2011-3914","project_name":"chromium","description":"","mistakes":null},{"id":556,"cve":"CVE-2011-3915","project_name":"chromium","description":"","mistakes":null},{"id":557,"cve":"CVE-2011-3916","project_name":"chromium","description":"","mistakes":null},{"id":558,"cve":"CVE-2011-3917","project_name":"chromium","description":"","mistakes":null},{"id":559,"cve":"CVE-2011-3919","project_name":"chromium","description":"","mistakes":null},{"id":560,"cve":"CVE-2011-3921","project_name":"chromium","description":"","mistakes":null},{"id":561,"cve":"CVE-2011-3922","project_name":"chromium","description":"","mistakes":null},{"id":562,"cve":"CVE-2011-3924","project_name":"chromium","description":"","mistakes":null},{"id":564,"cve":"CVE-2011-3926","project_name":"chromium","description":"","mistakes":null},{"id":565,"cve":"CVE-2011-3927","project_name":"chromium","description":"","mistakes":null},{"id":566,"cve":"CVE-2011-3928","project_name":"chromium","description":"","mistakes":null},{"id":567,"cve":"CVE-2011-3953","project_name":"chromium","description":"After a user performed a paste operation, an attacker could use malicious\ncode on a webpage that could start a loop that would continiuously monitor \nthe user's clipboard. This could allow attackers to steal password information \nand other sensitive data from the clipboard\n","mistakes":"The primary mistake here was simply an oversight in the implementation of the \nproduct. None of the developers thought of this attack as a possible issue for \na few years after it was introduced, and it was therefore not directly mitigated\nfor quite some time.\nThe developers did a good job during the design of the product by applying\ndefense in depth to this area, so that users were at least notified when\nsomething was wrong. They could have possibly gone further than simply\nnotifying the users, but this was likely a design tradeoff that the\ndevelopers knew about going in - allowing sites to remain in infinite\njavascript loops in order to prevent a total crash. The mitigation for \nthis CWE states that priveleges should be extended only to complete \nthe exact task at hand. The fix for this issue does not follow this \nexactly, as access to the clipboard is not terminated directly after \nthe paste is complete, it is only terminated if the contents of the \nclipboard are changed. There does not, however, seem to be any direct \nnegative security implications to this fix, since the site is still \nrestricted to see only the clipboard contents that it already read from \nthe paste operation. Still, further thought could be put into this fix \nin order to be sure that the attacker cannot exploit some other method \nof stealing clipboard data using the permissions they are given.\n"},{"id":568,"cve":"CVE-2011-3954","project_name":"chromium","description":"","mistakes":null},{"id":569,"cve":"CVE-2011-3955","project_name":"chromium","description":"","mistakes":null},{"id":571,"cve":"CVE-2011-3957","project_name":"chromium","description":"","mistakes":null},{"id":572,"cve":"CVE-2011-3958","project_name":"chromium","description":"","mistakes":null},{"id":576,"cve":"CVE-2011-3962","project_name":"chromium","description":"","mistakes":null},{"id":577,"cve":"CVE-2011-3963","project_name":"chromium","description":"","mistakes":null},{"id":579,"cve":"CVE-2011-3965","project_name":"chromium","description":"Google Chrome crashed when the program internally called a function.\nThis function tries to access data from a NULL variable. This allows remote attackers\nto cause a denial of service (application crash).\n\nIn general, this is a NULL Pointer Deference problem, that can occur when the\napplication deferences a pointer expecting it to be a valid, but is NULL.\nThis causes a program to crash or exit.\n","mistakes":"NULL Pointer Dereference is one of the commonly seen vulnerabilities.\nIt is very important to validate data received from outside the module\nbefore acting upon it. Sanity-checking before using could nearly prevent all\nNULL pointer dereference problems. However, it is impossible to sanity-check\nall data all the times. Thus, writing some strong unit tests to check such\nscenarios whenever possible could go a long way.\n"},{"id":580,"cve":"CVE-2011-3966","project_name":"chromium","description":"","mistakes":null},{"id":581,"cve":"CVE-2011-3967","project_name":"chromium","description":"","mistakes":null},{"id":582,"cve":"CVE-2011-3968","project_name":"chromium","description":"","mistakes":null},{"id":583,"cve":"CVE-2011-3969","project_name":"chromium","description":"","mistakes":null},{"id":584,"cve":"CVE-2011-3970","project_name":"chromium","description":"","mistakes":null},{"id":585,"cve":"CVE-2011-3971","project_name":"chromium","description":"","mistakes":null},{"id":586,"cve":"CVE-2011-3972","project_name":"chromium","description":"","mistakes":null},{"id":587,"cve":"CVE-2011-4691","project_name":"chromium","description":"","mistakes":null},{"id":588,"cve":"CVE-2011-4692","project_name":"chromium","description":"","mistakes":null},{"id":590,"cve":"CVE-2012-0724","project_name":"chromium","description":"","mistakes":null},{"id":591,"cve":"CVE-2012-0725","project_name":"chromium","description":"","mistakes":null},{"id":592,"cve":"CVE-2012-1521","project_name":"chromium","description":"","mistakes":null},{"id":593,"cve":"CVE-2012-1845","project_name":"chromium","description":"","mistakes":null},{"id":594,"cve":"CVE-2012-1846","project_name":"chromium","description":"","mistakes":null},{"id":595,"cve":"CVE-2012-2764","project_name":"chromium","description":"","mistakes":null},{"id":596,"cve":"CVE-2012-2807","project_name":"chromium","description":"","mistakes":null},{"id":597,"cve":"CVE-2012-2815","project_name":"chromium","description":"","mistakes":null},{"id":598,"cve":"CVE-2012-2816","project_name":"chromium","description":"","mistakes":null},{"id":599,"cve":"CVE-2012-2817","project_name":"chromium","description":"","mistakes":null},{"id":600,"cve":"CVE-2012-2818","project_name":"chromium","description":"","mistakes":null},{"id":601,"cve":"CVE-2012-2819","project_name":"chromium","description":"","mistakes":null},{"id":602,"cve":"CVE-2012-2820","project_name":"chromium","description":"","mistakes":null},{"id":603,"cve":"CVE-2012-2821","project_name":"chromium","description":"","mistakes":null},{"id":604,"cve":"CVE-2012-2822","project_name":"chromium","description":"","mistakes":null},{"id":605,"cve":"CVE-2012-2823","project_name":"chromium","description":"","mistakes":null},{"id":606,"cve":"CVE-2012-2824","project_name":"chromium","description":"","mistakes":null},{"id":607,"cve":"CVE-2012-2825","project_name":"chromium","description":"","mistakes":null},{"id":608,"cve":"CVE-2012-2826","project_name":"chromium","description":"","mistakes":null},{"id":609,"cve":"CVE-2012-2827","project_name":"chromium","description":"","mistakes":null},{"id":610,"cve":"CVE-2012-2828","project_name":"chromium","description":"","mistakes":null},{"id":611,"cve":"CVE-2012-2829","project_name":"chromium","description":"","mistakes":null},{"id":612,"cve":"CVE-2012-2830","project_name":"chromium","description":"","mistakes":null},{"id":613,"cve":"CVE-2012-2831","project_name":"chromium","description":"","mistakes":null},{"id":614,"cve":"CVE-2012-2832","project_name":"chromium","description":"","mistakes":null},{"id":615,"cve":"CVE-2012-2833","project_name":"chromium","description":"","mistakes":null},{"id":616,"cve":"CVE-2012-2834","project_name":"chromium","description":"","mistakes":null},{"id":617,"cve":"CVE-2012-2842","project_name":"chromium","description":"","mistakes":null},{"id":618,"cve":"CVE-2012-2843","project_name":"chromium","description":"","mistakes":null},{"id":619,"cve":"CVE-2012-2844","project_name":"chromium","description":"","mistakes":null},{"id":620,"cve":"CVE-2012-2846","project_name":"chromium","description":"","mistakes":null},{"id":621,"cve":"CVE-2012-2847","project_name":"chromium","description":"","mistakes":null},{"id":622,"cve":"CVE-2012-2848","project_name":"chromium","description":"","mistakes":null},{"id":623,"cve":"CVE-2012-2849","project_name":"chromium","description":"","mistakes":null},{"id":624,"cve":"CVE-2012-2850","project_name":"chromium","description":"","mistakes":null},{"id":625,"cve":"CVE-2012-2851","project_name":"chromium","description":"","mistakes":null},{"id":626,"cve":"CVE-2012-2852","project_name":"chromium","description":"","mistakes":null},{"id":627,"cve":"CVE-2012-2853","project_name":"chromium","description":"","mistakes":null},{"id":628,"cve":"CVE-2012-2854","project_name":"chromium","description":"","mistakes":null},{"id":629,"cve":"CVE-2012-2855","project_name":"chromium","description":"","mistakes":null},{"id":630,"cve":"CVE-2012-2856","project_name":"chromium","description":"","mistakes":null},{"id":631,"cve":"CVE-2012-2857","project_name":"chromium","description":"","mistakes":null},{"id":632,"cve":"CVE-2012-2858","project_name":"chromium","description":"","mistakes":null},{"id":633,"cve":"CVE-2012-2859","project_name":"chromium","description":"","mistakes":null},{"id":634,"cve":"CVE-2012-2860","project_name":"chromium","description":"","mistakes":null},{"id":635,"cve":"CVE-2012-2862","project_name":"chromium","description":"","mistakes":null},{"id":636,"cve":"CVE-2012-2863","project_name":"chromium","description":"","mistakes":null},{"id":637,"cve":"CVE-2012-2865","project_name":"chromium","description":"","mistakes":null},{"id":638,"cve":"CVE-2012-2866","project_name":"chromium","description":"","mistakes":null},{"id":639,"cve":"CVE-2012-2867","project_name":"chromium","description":"","mistakes":null},{"id":640,"cve":"CVE-2012-2868","project_name":"chromium","description":"","mistakes":null},{"id":641,"cve":"CVE-2012-2869","project_name":"chromium","description":"","mistakes":null},{"id":642,"cve":"CVE-2012-2870","project_name":"chromium","description":"","mistakes":null},{"id":643,"cve":"CVE-2012-2871","project_name":"chromium","description":"","mistakes":null},{"id":644,"cve":"CVE-2012-2872","project_name":"chromium","description":"","mistakes":null},{"id":645,"cve":"CVE-2012-2874","project_name":"chromium","description":"","mistakes":null},{"id":646,"cve":"CVE-2012-2875","project_name":"chromium","description":"","mistakes":null},{"id":647,"cve":"CVE-2012-2876","project_name":"chromium","description":"","mistakes":null},{"id":648,"cve":"CVE-2012-2877","project_name":"chromium","description":"","mistakes":null},{"id":649,"cve":"CVE-2012-2878","project_name":"chromium","description":"","mistakes":null},{"id":650,"cve":"CVE-2012-2879","project_name":"chromium","description":"","mistakes":null},{"id":651,"cve":"CVE-2012-2880","project_name":"chromium","description":"","mistakes":null},{"id":652,"cve":"CVE-2012-2881","project_name":"chromium","description":"","mistakes":null},{"id":653,"cve":"CVE-2012-2882","project_name":"chromium","description":"","mistakes":null},{"id":654,"cve":"CVE-2012-2883","project_name":"chromium","description":"","mistakes":null},{"id":655,"cve":"CVE-2012-2884","project_name":"chromium","description":"","mistakes":null},{"id":656,"cve":"CVE-2012-2885","project_name":"chromium","description":"","mistakes":null},{"id":657,"cve":"CVE-2012-2886","project_name":"chromium","description":"","mistakes":null},{"id":658,"cve":"CVE-2012-2887","project_name":"chromium","description":"","mistakes":null},{"id":659,"cve":"CVE-2012-2888","project_name":"chromium","description":"","mistakes":null},{"id":660,"cve":"CVE-2012-2889","project_name":"chromium","description":"","mistakes":null},{"id":661,"cve":"CVE-2012-2890","project_name":"chromium","description":"","mistakes":null},{"id":662,"cve":"CVE-2012-2891","project_name":"chromium","description":"","mistakes":null},{"id":663,"cve":"CVE-2012-2892","project_name":"chromium","description":"","mistakes":null},{"id":664,"cve":"CVE-2012-2893","project_name":"chromium","description":"","mistakes":null},{"id":665,"cve":"CVE-2012-2894","project_name":"chromium","description":"","mistakes":null},{"id":666,"cve":"CVE-2012-2895","project_name":"chromium","description":"","mistakes":null},{"id":667,"cve":"CVE-2012-2896","project_name":"chromium","description":"","mistakes":null},{"id":668,"cve":"CVE-2012-2897","project_name":"chromium","description":"","mistakes":null},{"id":669,"cve":"CVE-2012-2898","project_name":"chromium","description":"","mistakes":null},{"id":670,"cve":"CVE-2012-2899","project_name":"chromium","description":"","mistakes":null},{"id":671,"cve":"CVE-2012-2900","project_name":"chromium","description":"","mistakes":null},{"id":672,"cve":"CVE-2012-4903","project_name":"chromium","description":"","mistakes":null},{"id":673,"cve":"CVE-2012-4904","project_name":"chromium","description":"","mistakes":null},{"id":674,"cve":"CVE-2012-4905","project_name":"chromium","description":"","mistakes":null},{"id":675,"cve":"CVE-2012-4906","project_name":"chromium","description":"","mistakes":null},{"id":676,"cve":"CVE-2012-4907","project_name":"chromium","description":"","mistakes":null},{"id":677,"cve":"CVE-2012-4908","project_name":"chromium","description":"","mistakes":null},{"id":678,"cve":"CVE-2012-4909","project_name":"chromium","description":"","mistakes":null},{"id":679,"cve":"CVE-2012-4929","project_name":"chromium","description":"","mistakes":null},{"id":680,"cve":"CVE-2012-4930","project_name":"chromium","description":"","mistakes":null},{"id":682,"cve":"CVE-2012-5109","project_name":"chromium","description":"","mistakes":null},{"id":683,"cve":"CVE-2012-5110","project_name":"chromium","description":"","mistakes":null},{"id":684,"cve":"CVE-2012-5111","project_name":"chromium","description":"","mistakes":null},{"id":685,"cve":"CVE-2012-5112","project_name":"chromium","description":"","mistakes":null},{"id":686,"cve":"CVE-2012-5115","project_name":"chromium","description":"","mistakes":null},{"id":687,"cve":"CVE-2012-5116","project_name":"chromium","description":"","mistakes":null},{"id":688,"cve":"CVE-2012-5117","project_name":"chromium","description":"","mistakes":null},{"id":689,"cve":"CVE-2012-5118","project_name":"chromium","description":"","mistakes":null},{"id":690,"cve":"CVE-2012-5119","project_name":"chromium","description":"","mistakes":null},{"id":691,"cve":"CVE-2012-5120","project_name":"chromium","description":"","mistakes":null},{"id":692,"cve":"CVE-2012-5121","project_name":"chromium","description":"","mistakes":null},{"id":693,"cve":"CVE-2012-5122","project_name":"chromium","description":"","mistakes":null},{"id":694,"cve":"CVE-2012-5123","project_name":"chromium","description":"","mistakes":null},{"id":695,"cve":"CVE-2012-5124","project_name":"chromium","description":"","mistakes":null},{"id":696,"cve":"CVE-2012-5125","project_name":"chromium","description":"","mistakes":null},{"id":697,"cve":"CVE-2012-5126","project_name":"chromium","description":"","mistakes":null},{"id":698,"cve":"CVE-2012-5127","project_name":"chromium","description":"","mistakes":null},{"id":699,"cve":"CVE-2012-5128","project_name":"chromium","description":"","mistakes":null},{"id":700,"cve":"CVE-2012-5130","project_name":"chromium","description":"","mistakes":null},{"id":701,"cve":"CVE-2012-5131","project_name":"chromium","description":"","mistakes":null},{"id":702,"cve":"CVE-2012-5132","project_name":"chromium","description":"","mistakes":null},{"id":703,"cve":"CVE-2012-5133","project_name":"chromium","description":"","mistakes":null},{"id":704,"cve":"CVE-2012-5134","project_name":"chromium","description":"","mistakes":null},{"id":705,"cve":"CVE-2012-5135","project_name":"chromium","description":"","mistakes":null},{"id":706,"cve":"CVE-2012-5136","project_name":"chromium","description":"","mistakes":null},{"id":707,"cve":"CVE-2012-5137","project_name":"chromium","description":"","mistakes":null},{"id":708,"cve":"CVE-2012-5138","project_name":"chromium","description":"","mistakes":null},{"id":709,"cve":"CVE-2012-5139","project_name":"chromium","description":"","mistakes":null},{"id":710,"cve":"CVE-2012-5140","project_name":"chromium","description":"","mistakes":null},{"id":711,"cve":"CVE-2012-5141","project_name":"chromium","description":"","mistakes":null},{"id":712,"cve":"CVE-2012-5142","project_name":"chromium","description":"","mistakes":null},{"id":713,"cve":"CVE-2012-5143","project_name":"chromium","description":"","mistakes":null},{"id":714,"cve":"CVE-2012-5144","project_name":"chromium","description":"","mistakes":null},{"id":715,"cve":"CVE-2012-5145","project_name":"chromium","description":"","mistakes":null},{"id":716,"cve":"CVE-2012-5146","project_name":"chromium","description":"","mistakes":null},{"id":717,"cve":"CVE-2012-5147","project_name":"chromium","description":"","mistakes":null},{"id":718,"cve":"CVE-2012-5148","project_name":"chromium","description":"","mistakes":null},{"id":719,"cve":"CVE-2012-5149","project_name":"chromium","description":"Integer overflow in the audio layer of Google Chrome allowed remote attackers to cause a denial of service or possibly have other unspecified impacts via unknown vectors.","mistakes":null},{"id":720,"cve":"CVE-2012-5150","project_name":"chromium","description":"","mistakes":null},{"id":721,"cve":"CVE-2012-5151","project_name":"chromium","description":"","mistakes":null},{"id":723,"cve":"CVE-2012-5153","project_name":"chromium","description":"","mistakes":null},{"id":724,"cve":"CVE-2012-5154","project_name":"chromium","description":"An Integer overflow in a web browser could allow attackers to\ncause a denial of service attack. It could also allow for other impacts through \"vectors\"\nrelated to the allocation of shared memory.\n","mistakes":"If the requirements for the use of this buffer were laid out completely, the programmer may have known to check its\nsize upon the Implementation phase.\n\nThis programmer, however, could possibly have just forgotten to check the buffer size, which is a coding mistake.\n"},{"id":726,"cve":"CVE-2012-5156","project_name":"chromium","description":"","mistakes":null},{"id":727,"cve":"CVE-2012-5157","project_name":"chromium","description":"","mistakes":null},{"id":728,"cve":"CVE-2012-5376","project_name":"chromium","description":"","mistakes":null},{"id":729,"cve":"CVE-2012-5851","project_name":"chromium","description":"","mistakes":null},{"id":730,"cve":"CVE-2013-0828","project_name":"chromium","description":"","mistakes":null},{"id":731,"cve":"CVE-2013-0829","project_name":"chromium","description":"","mistakes":null},{"id":732,"cve":"CVE-2013-0830","project_name":"chromium","description":"","mistakes":null},{"id":733,"cve":"CVE-2013-0831","project_name":"chromium","description":"Path traversal vulnerability that allows remote attackers to\nhave an unspecified impact by leveraging access to an extension process.\n","mistakes":"In my opinion, it was a coding mistake. The author of the code did not\naccount for '/.' in file names. So when '/.' was present, the code\nreturned the unintended filepath.\n"},{"id":734,"cve":"CVE-2013-0832","project_name":"chromium","description":"","mistakes":null},{"id":735,"cve":"CVE-2013-0833","project_name":"chromium","description":"","mistakes":null},{"id":736,"cve":"CVE-2013-0834","project_name":"chromium","description":"","mistakes":null},{"id":737,"cve":"CVE-2013-0835","project_name":"chromium","description":"","mistakes":null},{"id":738,"cve":"CVE-2013-0836","project_name":"chromium","description":"","mistakes":null},{"id":739,"cve":"CVE-2013-0837","project_name":"chromium","description":"","mistakes":null},{"id":740,"cve":"CVE-2013-0838","project_name":"chromium","description":"","mistakes":null},{"id":741,"cve":"CVE-2013-0839","project_name":"chromium","description":"","mistakes":null},{"id":742,"cve":"CVE-2013-0840","project_name":"chromium","description":"","mistakes":null},{"id":744,"cve":"CVE-2013-0842","project_name":"chromium","description":"","mistakes":null},{"id":746,"cve":"CVE-2013-0879","project_name":"chromium","description":"","mistakes":null},{"id":747,"cve":"CVE-2013-0880","project_name":"chromium","description":"","mistakes":null},{"id":749,"cve":"CVE-2013-0882","project_name":"chromium","description":"","mistakes":null},{"id":750,"cve":"CVE-2013-0883","project_name":"chromium","description":"","mistakes":null},{"id":752,"cve":"CVE-2013-0885","project_name":"chromium","description":"","mistakes":null},{"id":753,"cve":"CVE-2013-0886","project_name":"chromium","description":"","mistakes":null},{"id":755,"cve":"CVE-2013-0888","project_name":"chromium","description":"","mistakes":null},{"id":756,"cve":"CVE-2013-0889","project_name":"chromium","description":"Chromium browsers do not properly check that users performed a gesture\nrequired before downloading a file. This made it possible for remote hackers\nto run arbitrary code from a crafted file.\n","mistakes":"This was a simple mistake where it looks like the developer missed input\nvalidation. The fix was just to add one more check to the input to make\nsure that the request to download was one that came from the user and not\nremote hackers.\n"},{"id":757,"cve":"CVE-2013-0890","project_name":"chromium","description":"","mistakes":null},{"id":759,"cve":"CVE-2013-0892","project_name":"chromium","description":"","mistakes":null},{"id":760,"cve":"CVE-2013-0893","project_name":"chromium","description":"","mistakes":null},{"id":761,"cve":"CVE-2013-0894","project_name":"chromium","description":"","mistakes":null},{"id":762,"cve":"CVE-2013-0895","project_name":"chromium","description":"Google Chrome on Linux and Mac OS X does not properly handle file paths for \ncopy operations in the CopyDirectory method. The copy operation does not\nproperly strip trailing separators when creating its target path, which makes\nit possible for a remote attacker to execute arbitrary code through path \ntraversal.\n","mistakes":"The primary culprit of this vulnerability was the copy/paste styled\nimplementation of file paths in the first iteration of the CopyDirectory \nmethod for posix operating systems. There was no input checking on the \npath, it was assumed that no malicious file path would be used. \n\nIt is interesting that there was a gap of about 4 years from the first \nimplementation of the CopyDirectory method with the vulnerability to when\nthe vulnerability was fixed. All the while there were a series of edits\nmade to the problematic lines of code by Google employees. One of which\naddressed that there may be a problem with the path implementation (leading\n'/' characters) but it only scratched the surface of the greater problem.\n\nThe fix ended up utilized a generic AppendRelativePath function that could\nbe utilized in all operating systems and worked to both sanitize and validate\nthe file path inputs before constructing the file path for the CopyDirectory\nfunction.\n"},{"id":763,"cve":"CVE-2013-0896","project_name":"chromium","description":"","mistakes":null},{"id":764,"cve":"CVE-2013-0897","project_name":"chromium","description":"","mistakes":null},{"id":765,"cve":"CVE-2013-0898","project_name":"chromium","description":"","mistakes":null},{"id":766,"cve":"CVE-2013-0899","project_name":"chromium","description":"","mistakes":null},{"id":767,"cve":"CVE-2013-0900","project_name":"chromium","description":"","mistakes":null},{"id":768,"cve":"CVE-2013-0902","project_name":"chromium","description":"","mistakes":null},{"id":769,"cve":"CVE-2013-0903","project_name":"chromium","description":"","mistakes":null},{"id":770,"cve":"CVE-2013-0904","project_name":"chromium","description":"","mistakes":null},{"id":771,"cve":"CVE-2013-0905","project_name":"chromium","description":"","mistakes":null},{"id":772,"cve":"CVE-2013-0906","project_name":"chromium","description":"","mistakes":null},{"id":774,"cve":"CVE-2013-0908","project_name":"chromium","description":"","mistakes":null},{"id":775,"cve":"CVE-2013-0909","project_name":"chromium","description":"","mistakes":null},{"id":776,"cve":"CVE-2013-0910","project_name":"chromium","description":"Google Chrome previously did not properly manage browser interactions between browsers and\nrenderers. The issue occurs when plug-ins are loaded or validated/authorized. \nAttackers can use it to bypass access restrictions with blocked plug-ins due to \nthe exposed rendering process. The renderer is what loads the plug-ins in the browser, and is\nexposed enough to theoretically be compromised. If a renderer is compromised, there are no \nlonger any restricitions on the type of plug-ins that are loaded, and an attacker could use this\nto load in a nefarious plug-in.\n\nThis vulnerability was not a found bug, but more of a security oversight. Someone discovered\na potential vulnerability that could be corrected before it was ever an issue in practice.\n","mistakes":"All in all, I don't think that there were that many mistakes that were made that\nwere avoidable. Someone with more experience with Java and plug-ins noticed a section\nof code that could be improved, and google responded accordingly. If any mistakes were\nmade, it would be in the design phase. It also might be able to be considered a Maintainability\nissue, because as technologies evolved, they did not stay upgrade this feature accordingly.\n\nAs far as the mitigations go, the only one mentioned on the cwe page is to use an authentication\nframework and library. However, this is not entirely relevant because we are not concerned with\nuser authentication, but authentication of a renderer. This is a more unique problem than one that \ncan be solved with a default library. \n\nThe fix looks like a pretty good solution for a problem that is not very common.\n"},{"id":777,"cve":"CVE-2013-0911","project_name":"chromium","description":"","mistakes":null},{"id":778,"cve":"CVE-2013-0912","project_name":"chromium","description":"","mistakes":null},{"id":779,"cve":"CVE-2013-0916","project_name":"chromium","description":"","mistakes":null},{"id":780,"cve":"CVE-2013-0917","project_name":"chromium","description":"","mistakes":null},{"id":781,"cve":"CVE-2013-0918","project_name":"chromium","description":"","mistakes":null},{"id":782,"cve":"CVE-2013-0919","project_name":"chromium","description":"","mistakes":null},{"id":783,"cve":"CVE-2013-0920","project_name":"chromium","description":"","mistakes":null},{"id":784,"cve":"CVE-2013-0921","project_name":"chromium","description":"","mistakes":null},{"id":785,"cve":"CVE-2013-0922","project_name":"chromium","description":"","mistakes":null},{"id":786,"cve":"CVE-2013-0923","project_name":"chromium","description":"","mistakes":null},{"id":787,"cve":"CVE-2013-0924","project_name":"chromium","description":"","mistakes":null},{"id":788,"cve":"CVE-2013-0925","project_name":"chromium","description":"There is a missing check to see if an extension has permission to a tab before\nallowing it access to the tab's URL. This has potential to leak the user's\nvisited tabs to an attacker.\n","mistakes":"After searching through this CVE for a long time, I was unable to find the\nexact vulnerability. I know it has somewthing to do with not checking for\nextension permissions when updating tabs. This could be somewhere in the\nfollowing files:\n  /chrome/browser/extensions/browser_event_router.cc\n  /chrome/browser/extensions/extension_tab_util.cc\nPotentially in the TabUpdated or ExtensionActionExecuted functions of\nbrowser_event_router.cc, or the CreateTabValue function in\nextension_tab_util.cc.\n"},{"id":789,"cve":"CVE-2013-0926","project_name":"chromium","description":"","mistakes":null},{"id":790,"cve":"CVE-2013-2268","project_name":"chromium","description":"","mistakes":null},{"id":791,"cve":"CVE-2013-2493","project_name":"chromium","description":"","mistakes":null},{"id":792,"cve":"CVE-2013-2566","project_name":"chromium","description":"","mistakes":null},{"id":793,"cve":"CVE-2013-2632","project_name":"chromium","description":"","mistakes":null},{"id":794,"cve":"CVE-2013-2836","project_name":"chromium","description":"","mistakes":null},{"id":796,"cve":"CVE-2013-2838","project_name":"chromium","description":"","mistakes":null},{"id":798,"cve":"CVE-2013-2840","project_name":"chromium","description":"","mistakes":null},{"id":799,"cve":"CVE-2013-2841","project_name":"chromium","description":"","mistakes":null},{"id":801,"cve":"CVE-2013-2843","project_name":"chromium","description":"","mistakes":null},{"id":893,"cve":"CVE-2013-6642","project_name":"chromium","description":"","mistakes":null},{"id":804,"cve":"CVE-2013-2846","project_name":"chromium","description":"","mistakes":null},{"id":805,"cve":"CVE-2013-2847","project_name":"chromium","description":"","mistakes":null},{"id":806,"cve":"CVE-2013-2848","project_name":"chromium","description":"","mistakes":null},{"id":807,"cve":"CVE-2013-2849","project_name":"chromium","description":"","mistakes":null},{"id":808,"cve":"CVE-2013-2853","project_name":"chromium","description":"","mistakes":null},{"id":809,"cve":"CVE-2013-2854","project_name":"chromium","description":"","mistakes":null},{"id":810,"cve":"CVE-2013-2855","project_name":"chromium","description":"The vulnerability was in Google Chrome's Developer Tools API where in Chrome's\ninspector, which lets the user view HTML of the page, there was a way for a user\nto set up a setter and get access to a object called InjectedScriptHost.\n\nThe implementation, which was done in C++, had a class with methods that had\nelevated privileges from the common user which could be accessed.  This could\nresult in a crash at best and an integrity violation at worse.\n\nThe way this could be exploited would be if an attacker found out about this\nvulnerability and used it to purposely crash the site.  This could prevent\nother people from accessing the site, also known as denial of service.\n","mistakes":"The vulnerability was an oversight where the programmer intended for\nthe class to only be used be the inspector itself, but did not think about\nthe consequences if the user was able to access that object.  Also,\nJavascript code was not sanitized against in the console, which made this\nvulnerability possible.\n\nSurprisingly, the fix was simply to not use the methods for the object with\nelevated privileges unless it was specifically for the inspector.  They did\nnot get to the root of the problem where the console let the user set up a\nsetter in Javascript, which made the object vulnerable in the first place.\nI believe that sanitizing the console input could improve this fix.\n"},{"id":811,"cve":"CVE-2013-2856","project_name":"chromium","description":"","mistakes":null},{"id":812,"cve":"CVE-2013-2857","project_name":"chromium","description":"","mistakes":null},{"id":814,"cve":"CVE-2013-2859","project_name":"chromium","description":"","mistakes":null},{"id":815,"cve":"CVE-2013-2860","project_name":"chromium","description":"","mistakes":null},{"id":816,"cve":"CVE-2013-2861","project_name":"chromium","description":"Part of Chromium's image rendering system allows attackers to cause a memory\nreference to already freed memory. This could cause memory corruption and\ncrashes allowing an attacker to make resources unavailable.\n","mistakes":"The mistake appears to be a coding mistake. The original author failed to\ncheck that the view had not already been freed before using.\n\nIn the fix process, there appeared to be a lot of miscommunication regarding\nhow to reproduce the issue and what its impact was. Quite late into the fix\nthere was still confusion as to how the vulnerability actually impacted the\nsystem.\n"},{"id":817,"cve":"CVE-2013-2862","project_name":"chromium","description":"","mistakes":null},{"id":818,"cve":"CVE-2013-2863","project_name":"chromium","description":"","mistakes":null},{"id":819,"cve":"CVE-2013-2864","project_name":"chromium","description":"","mistakes":null},{"id":820,"cve":"CVE-2013-2865","project_name":"chromium","description":"","mistakes":null},{"id":821,"cve":"CVE-2013-2866","project_name":"chromium","description":"","mistakes":null},{"id":822,"cve":"CVE-2013-2867","project_name":"chromium","description":"","mistakes":null},{"id":823,"cve":"CVE-2013-2868","project_name":"chromium","description":"","mistakes":null},{"id":824,"cve":"CVE-2013-2869","project_name":"chromium","description":"","mistakes":null},{"id":825,"cve":"CVE-2013-2870","project_name":"chromium","description":"","mistakes":null},{"id":826,"cve":"CVE-2013-2871","project_name":"chromium","description":"","mistakes":null},{"id":827,"cve":"CVE-2013-2872","project_name":"chromium","description":"","mistakes":null},{"id":828,"cve":"CVE-2013-2873","project_name":"chromium","description":"When loading the error 404 page, there was a vulnerability in WebKit in which\nan object called the WebURLLoader was used after being deleted.  The WebURLLoader was \noriginally released because it received an inter-process communication that the page had \nfinished loading.  The subresources of the 404 page had transitioned into the finished state, \nbut may have signaled an error that resulted in a message from a nested message loop.  \nBecause the subresource was already finished and the WebURLLoader had been freed, a use-after-free \ncrash occurred when the subresource attempted to proccess the body received from the nested message loop.\n","mistakes":"The fix for this vulnerability was simple enough (adding a protective pointer),\nbut the main mistake was the developers' failure to reinstate the reverted test that\nwould have caught this vulnerability months earlier.  It's unclear why the test was reverted\nand never reexamined, but because the comments on the thread for the reverting commit stop after\na few days, it's likely that the team because busy with more pressing matters and simply forgot about\nthe test since the fix itself for that bug had landed fine.  This was a process mistake, possibly due to\nmiscommunication or the emergence of higher-priority bugs.\n"},{"id":829,"cve":"CVE-2013-2874","project_name":"chromium","description":"","mistakes":null},{"id":831,"cve":"CVE-2013-2876","project_name":"chromium","description":"","mistakes":null},{"id":832,"cve":"CVE-2013-2877","project_name":"chromium","description":"","mistakes":null},{"id":833,"cve":"CVE-2013-2878","project_name":"chromium","description":"Lack of bounds protections and input sanitization allows for remote attacks to cause denial of service attacks.","mistakes":null},{"id":835,"cve":"CVE-2013-2880","project_name":"chromium","description":"","mistakes":null},{"id":836,"cve":"CVE-2013-2881","project_name":"chromium","description":"","mistakes":null},{"id":837,"cve":"CVE-2013-2882","project_name":"chromium","description":"","mistakes":null},{"id":838,"cve":"CVE-2013-2883","project_name":"chromium","description":"","mistakes":null},{"id":839,"cve":"CVE-2013-2884","project_name":"chromium","description":"","mistakes":null},{"id":840,"cve":"CVE-2013-2885","project_name":"chromium","description":"","mistakes":null},{"id":841,"cve":"CVE-2013-2886","project_name":"chromium","description":"","mistakes":null},{"id":842,"cve":"CVE-2013-2887","project_name":"chromium","description":"","mistakes":null},{"id":843,"cve":"CVE-2013-2900","project_name":"chromium","description":"Windows version does not properly handle components of the path name containing\njust a . (dot) and white space characters. Remote hackers can utilize this to do\na directory traversal by a crafted directory name.\n","mistakes":"The main take away for this CVE is that more investigations need to be done when changing security. In this case an additional secuirty check was put in place in a handfull of different files solved the vulnerability. I would argue that there is a lack of organization of path traversal mitigations which may have caused this issue to be overlooked. I believe that this vulnerability was caused by a lack of proper design. In this case, many different files had logic for handling file paths securely and some cases were missed. By having sanitation logic split up in many different files it makes it harder to track what is being sanitized properly and what isn't."},{"id":844,"cve":"CVE-2013-2901","project_name":"chromium","description":"","mistakes":null},{"id":845,"cve":"CVE-2013-2902","project_name":"chromium","description":"","mistakes":null},{"id":846,"cve":"CVE-2013-2903","project_name":"chromium","description":"","mistakes":null},{"id":847,"cve":"CVE-2013-2904","project_name":"chromium","description":"Use-after-free vulnerability in Google Chrome before 29.0.1547.57 allows remote attackers to cause a denial of service attack","mistakes":null},{"id":848,"cve":"CVE-2013-2905","project_name":"chromium","description":"","mistakes":null},{"id":849,"cve":"CVE-2013-2906","project_name":"chromium","description":"","mistakes":null},{"id":850,"cve":"CVE-2013-2907","project_name":"chromium","description":"","mistakes":null},{"id":851,"cve":"CVE-2013-2908","project_name":"chromium","description":"","mistakes":null},{"id":852,"cve":"CVE-2013-2909","project_name":"chromium","description":"","mistakes":null},{"id":853,"cve":"CVE-2013-2910","project_name":"chromium","description":"","mistakes":null},{"id":854,"cve":"CVE-2013-2911","project_name":"chromium","description":"","mistakes":null},{"id":855,"cve":"CVE-2013-2912","project_name":"chromium","description":"","mistakes":null},{"id":856,"cve":"CVE-2013-2913","project_name":"chromium","description":"","mistakes":null},{"id":858,"cve":"CVE-2013-2915","project_name":"chromium","description":"","mistakes":null},{"id":859,"cve":"CVE-2013-2916","project_name":"chromium","description":"Blink, as used in Google Chrome before 30.0.1599.66, allows remote attackers to spoof the address bar via vectors involving a response with a 204 (aka No Content) status code, in conjunction with a delay in notifying the user of an attempted spoof.","mistakes":null},{"id":860,"cve":"CVE-2013-2917","project_name":"chromium","description":"","mistakes":null},{"id":861,"cve":"CVE-2013-2918","project_name":"chromium","description":"","mistakes":null},{"id":862,"cve":"CVE-2013-2919","project_name":"chromium","description":"","mistakes":null},{"id":863,"cve":"CVE-2013-2920","project_name":"chromium","description":"","mistakes":null},{"id":864,"cve":"CVE-2013-2921","project_name":"chromium","description":"","mistakes":null},{"id":865,"cve":"CVE-2013-2922","project_name":"chromium","description":"","mistakes":null},{"id":866,"cve":"CVE-2013-2923","project_name":"chromium","description":"","mistakes":null},{"id":867,"cve":"CVE-2013-2924","project_name":"chromium","description":"","mistakes":null},{"id":868,"cve":"CVE-2013-2925","project_name":"chromium","description":"","mistakes":null},{"id":870,"cve":"CVE-2013-2927","project_name":"chromium","description":"","mistakes":null},{"id":871,"cve":"CVE-2013-2928","project_name":"chromium","description":"","mistakes":null},{"id":872,"cve":"CVE-2013-2931","project_name":"chromium","description":"","mistakes":null},{"id":873,"cve":"CVE-2013-6166","project_name":"chromium","description":"","mistakes":null},{"id":874,"cve":"CVE-2013-6621","project_name":"chromium","description":"","mistakes":null},{"id":876,"cve":"CVE-2013-6623","project_name":"chromium","description":"","mistakes":null},{"id":924,"cve":"CVE-2014-1705","project_name":"chromium","description":"","mistakes":null},{"id":879,"cve":"CVE-2013-6626","project_name":"chromium","description":"","mistakes":null},{"id":883,"cve":"CVE-2013-6631","project_name":"chromium","description":"","mistakes":null},{"id":884,"cve":"CVE-2013-6632","project_name":"chromium","description":"","mistakes":null},{"id":887,"cve":"CVE-2013-6636","project_name":"chromium","description":"Versions of Google Chrome before 31.0.1650.63 made an incorrect check for  an\nempty document during presentation of a modal dialog, which allows remote\nattackers to spoof the address bar via vectors involving the  document.write\nmethod. These vectors involved calling document.write on a  window opened by\nwindow.open and then Chrome not correctly setting the URL  in the OmniBox (the\nnavigation and search bar). Because of this error, malicious websites could\ncreate windows with spoofed URLs in the OmniBox, leading users to believe their\ninformation was being given to a trusted destination or even securely\ntransmitted when it was not.\n","mistakes":"The mistakes that were made where coding mistakes. The author didn't think \nof every situation where the code could be exploited and more specficly,\ndidn't realize the effects of unnecessary environment checks. The bugfix for\nthis specfic issue involved removing a single line that limited the \nfunctionality of notifyIfInitialDocumentAccessed() to only operate when\nm_stateMachine.isDisplayingInitialEmptyDocument() returned a truthy value.\nThis allowed for a vulnerability where the URL in the OmniBox was not\nproperly updated when the document.write() function was used. Hence, allowing\nusers to spoof any address in the OmniBox, the perfect setup for phishing \nschemes.\n"},{"id":888,"cve":"CVE-2013-6637","project_name":"chromium","description":"","mistakes":null},{"id":889,"cve":"CVE-2013-6638","project_name":"chromium","description":"","mistakes":null},{"id":890,"cve":"CVE-2013-6639","project_name":"chromium","description":"","mistakes":null},{"id":891,"cve":"CVE-2013-6640","project_name":"chromium","description":"","mistakes":null},{"id":892,"cve":"CVE-2013-6641","project_name":"chromium","description":"","mistakes":null},{"id":895,"cve":"CVE-2013-6644","project_name":"chromium","description":"","mistakes":null},{"id":896,"cve":"CVE-2013-6645","project_name":"chromium","description":"A vulnerability where a pointer was being used after it was already freed, called a \"use-after-free\" vulnerability.\n\nThis vulnerability can allow attackers to cause a \"denial of service\" attack, where some set of users would no longer be able to use the browser. The sequence of activities that could cause an exploit involves specific actions related to a speech input element of the Chrome browser.\n","mistakes":"A coding mistake led to this vulnerability. It seems a developer was implementing a quick fix for a different bug and did not realize that they were introducing a use-after-free vulnerability in doing so.\n\nThe fix to the mistake does look proper. The issue was created because the developer was properly handling a parent object, but not properly handling the pointers to the children of that parent. The fix involved iterating through the child objects and handling them properly as well.\n"},{"id":899,"cve":"CVE-2013-6650","project_name":"chromium","description":"","mistakes":null},{"id":900,"cve":"CVE-2013-6652","project_name":"chromium","description":"","mistakes":null},{"id":902,"cve":"CVE-2013-6654","project_name":"chromium","description":"","mistakes":null},{"id":903,"cve":"CVE-2013-6655","project_name":"chromium","description":"This vulnerability is when a heap that had previously been freed, would attempt to get accessed by scripts that were running as pages were being loaded.","mistakes":"With my limited knowlege in the area, it sounds like this was really more of a design mistake. It sounds like the scripts being run IN layout devs thought NEEDED to be there, in order to maintain performance; however, these same scripts were causing bugs and security risks because the place where they were actually being executed. Had more testing and research been done ahead of time when designing, these bugs would never have happened. In the end the devs ended up changing when certain events were fired as a fix to these bugs and risks."},{"id":904,"cve":"CVE-2013-6656","project_name":"chromium","description":"The vulnerability was in WebKit's XSS Auditor which is a built-in function designed \nto mitigate XSS attacks. It identifies if query parameters contain malicious \nJavaScript and block the response if it believes the payloads were injected into a response.\n\nXSS Auditor, when processing a POST request with a chain of page redirects and a single \nfinal destination page, initializes with the URL of the destination page and the body of\nthe initial request page. This means that the body of the request page is still accessible \nthru the XSS Auditor by brute-forcing character by character the POST body of the initial request.\nHowever, this will only occur if the original request url has a \u003cscript\u003e tag in it, to make \nXSS Auditor suspicious and initialize.\n\nBy pairing this exploit with a login form, an attacker can get the body of the form\nwith the user inputs in the values and gain access to passwords and other sensitive \ninformation.\n","mistakes":"I honestly think that this vulnerability came to be because of a typo. \n\nThe solution was a one-liner (worth $500) that changed \n\"FormData* httpBody = documentLoader-\u003eoriginalRequest().httpBody();\" to\n\"FormData* httpBody = documentLoader-\u003erequest().httpBody();\"\n\nNotice that the only difference is which request function is being used;\neach gives the XSS Auditor access to certain http bodies. After a form fill and a login attempt,\nthe request http body doesn't contain any of the user's input while the original \nrequest body does.\n\nThe vulnerability went long undiscovered mostly because of its security by obscurity\ndue to the specificity of its prerequesites and inputs. \n\nSince this vulnerability was introduced entirely as new code along with a larger featueset,\nI think that the original developer just mistyped and chose the wrong request function\nwhile not thinking about the consequences of choosing one or the other. They both \nare syntactically similar after all.\n"},{"id":1400,"cve":"CVE-2017-5030","project_name":"chromium","description":"Memory corruption in V8.\n","mistakes":null},{"id":909,"cve":"CVE-2013-6661","project_name":"chromium","description":"","mistakes":null},{"id":911,"cve":"CVE-2013-6664","project_name":"chromium","description":"","mistakes":null},{"id":913,"cve":"CVE-2013-6666","project_name":"chromium","description":"The PepperFlashRendererHost::OnNavigate function does not verify nor sanitize\nheaders, which can cause a Cross-Site Request Forgery by allowing remote\nattackers to bypass the verification standards. Attackers can get around the\nintended Cross-Origin Resource Sharing restrictions by using a custom and\nunexpected header in the request.\n","mistakes":"This vulnerability was most likely caused by an Archetectural Design mistake. The content within the headers of a POST request should always be verified as well as sanitized to prevent and mitigate CSRF, which did not seem to be done in this scenario."},{"id":914,"cve":"CVE-2013-6667","project_name":"chromium","description":"","mistakes":null},{"id":915,"cve":"CVE-2013-6668","project_name":"chromium","description":"","mistakes":null},{"id":916,"cve":"CVE-2013-6802","project_name":"chromium","description":"","mistakes":null},{"id":917,"cve":"CVE-2014-1568","project_name":"chromium","description":"An attacker could spoof an RSA signature via the Bleichenbacher's Low-Exponent Attack on the TLS handshake and certificate signature forgery. This is due to the fact that the Network Security Services had a small Abstract Syntax Notation One for decoding.","mistakes":"The main mistake was trusting the ASN.1 which had a Bleichenbacher's Low-Exponent Attack. This is a problem not only this project had but was cross multiple applications. There is only one solution is creating every component, however this is not realisitc. So the best solution is testing all aspects of the library you are using and staying up to date with what information the creator of the library is releasing."},{"id":918,"cve":"CVE-2014-1681","project_name":"chromium","description":"","mistakes":null},{"id":920,"cve":"CVE-2014-1701","project_name":"chromium","description":"The Cross-Site Scripting (XSS) vulnerability was located in the GenerateFunction \nfunction in the path bindings/scripts/code_generator_v8.pm in Blink. It existed \nbecause the aforementioned function didn't implement a specific cross-origin \nrestriction for the EventTarget::dispatchEvent function.\n\nThe \"events\" processing component wasn't able to properly filter user input from \nthe HTML code before displaying the input.\n\nA way this vulnerability can be exploited is that a remote attacker can trigger\nUniversal XSS (UXSS) attacks via vectors involving events, and can essentially \nforce the execution of arbitrary scripting code by the target user's browser within \nthe context of a different domain. Such as how it affected iframes, as it permitted \na page on an arbitrary site to retrieve the document element of any target page so \nlong as the following conditions concerning the target page were met - \n(1) it may be imbedded in an iframe, (2) it has a handler for any window event,\n(3) it gets or sets any property of the event in any jQuery listener, and\n(4) it returns a dom node from the handler.\n","mistakes":"The mistake seemed to stem from a lack of proper security checks in place. As stated\npreviously in the description above, The \"events\" processing component wasn't able \nto properly filter user input from the HTML code before displaying the input.\n"},{"id":921,"cve":"CVE-2014-1702","project_name":"chromium","description":"This vulnerability is of the free after use nature. When a task is running on a thread,\nand that task ends the thread is being shutdown. This vulnerability could allow an\nattacker to creat an denial of service. They leverage the improper handling of how\nthese threads are terminated.\n","mistakes":"This appears to be a code mistake. There was only one line of code in one file\nthat caused this vulnerability. This leads me to belive that this was simple a\nfunction that a programmer overlooked. They use the mitigation of setting pointers\nto null once they are freed. This prevents attackers from gaining accesss through\nimproper termination of a terminating thread in the clean up process.\n"},{"id":923,"cve":"CVE-2014-1704","project_name":"chromium","description":"","mistakes":null},{"id":928,"cve":"CVE-2014-1716","project_name":"chromium","description":"","mistakes":null},{"id":929,"cve":"CVE-2014-1717","project_name":"chromium","description":"","mistakes":null},{"id":930,"cve":"CVE-2014-1718","project_name":"chromium","description":"An integer overflow was possible when finding the area of a frame during a swap.\nThis could happen when the height or width of the frame was set to a large \nenough value as the formula multiplies these values by 4 but does not check\nthe size of the resulting integer. Thiss could allow a web application to potentially\nescape its own memory space by allocating a large amount of renderer memory and overwriting \nor controling the memory space of other applications running within chrome. (Sandbox escape) \nIt also allows a denial of service attack by forcing crashes.\nby \n","mistakes":"This issue seems to have come from a coding mistake. It appears that the variables leading up to the section of code were properly checked to avoid an integer overflow but the calculation done on the variables was not considered."},{"id":931,"cve":"CVE-2014-1719","project_name":"chromium","description":"A vulnerability was found that allowed for already used memory to be used again in the Web workers API implementation. The\nvulnerability allowed remote attackers to cause attacks that could bring down the system as well\nas possibly have inputs that trigger a termination of shared web workers during script loading.\n","mistakes":"The mistake came from a coding flaw and caused what would be a denial of service\nattack as well as other potential errors. This could have been avoided by knowing\nwhere the function should have properly been placed. Moving the position of one \nof the lines of code is what made the fix. \nThere may have been a potential for the vulnerability to have been fixed during \nthe design phase of the module. During the code review is when it seemed like the \ndiscussion was sparked regarding the correct placement of this line. If the discussion\nwas brought up during implementation or if the implications of the placement of the \nline of code were known it could have been mitigated. \n"},{"id":932,"cve":"CVE-2014-1720","project_name":"chromium","description":"","mistakes":null},{"id":933,"cve":"CVE-2014-1721","project_name":"chromium","description":"","mistakes":null},{"id":934,"cve":"CVE-2014-1722","project_name":"chromium","description":"","mistakes":null},{"id":936,"cve":"CVE-2014-1724","project_name":"chromium","description":"","mistakes":null},{"id":937,"cve":"CVE-2014-1725","project_name":"chromium","description":"","mistakes":null},{"id":938,"cve":"CVE-2014-1726","project_name":"chromium","description":"The file drag-and-drop feature could be exploited by a user \nperforming the drag-and-drop action with a file containing malicious code. \nThis would allow the attacker to bypass the Same Origin Policy and forge \nlocal pathnames. HTML files that were loaded from file:// URLs were able \nto read other local files because Chromium would automatically grant the \ntarget of the drop action read acess to the file. \n","mistakes":"This vulnerability seems to be caused by design mistakes. There are some incorrect uses of \nmethods in addition to a number of missing handlers. The fix seems to address the issues related to \nmatching CWE entry. \n"},{"id":939,"cve":"CVE-2014-1727","project_name":"chromium","description":"A vulnerability in the web color chooser UI. The object is removed in the wrong\nclass allowing an attacker to access freed memory. This can cause denial of \nservice attacks, or possible other attacks on unknown vectors related to forms. \n","mistakes":"This vulnerability is related to resource management. We should take into \naccount when each paticular object may be deleted and ensure that it is\nok to be deleted at that time.\n\nThis is something very hard to protect against. There are many different times\nan object can be deleted and figuring out all posible interactions can be tough.\n\nIts best to limit the possiblities of object iteractions and ensure that it only\ndoes what it needs to do and when. It was an easy fix for a bug that could have\nhad big implications since it's a use-after-free vulnerability. "},{"id":940,"cve":"CVE-2014-1728","project_name":"chromium","description":"","mistakes":null},{"id":941,"cve":"CVE-2014-1729","project_name":"chromium","description":"","mistakes":null},{"id":942,"cve":"CVE-2014-1730","project_name":"chromium","description":"","mistakes":null},{"id":943,"cve":"CVE-2014-1731","project_name":"chromium","description":"","mistakes":null},{"id":944,"cve":"CVE-2014-1732","project_name":"chromium","description":"The original design of the Speech Recognition Bubble view in Google Chrome had\na fault where a slower computer could delete the view of web page before the\nother critical items could be deleted first causing a denial of service to occur.\n","mistakes":"The coding mistake was a design mistake where an speech file could be attempted\nto be played yet caused a denial of service under the right conditions. This being\na legacy issue, specifically slow, older Window XP, showed that the mistake was\na design error of ensuring the order of closing tasks took priority.\n\nThe fix looks proper, as it implements a correct design pattern for the job, however\nsince there weren't any unit tests to push the limits of the code, only the physical\ntest could be re-created to see if the issue had been resolved for that specific\nsituation, opposed to trying to solve for future issues at hand.\n"},{"id":961,"cve":"CVE-2014-3155","project_name":"chromium","description":"The implementation of the network transfer protocol queue's 'write' function\ndoesn't check for re-entrancy (being called again after being interrupted).\nShrinking the queue while this happens results in an out-of-bounds read which\nremote attackers could use to cause a denial of service.\n","mistakes":"This seems like a basic coding mistake where the developer didn't consider how\niterating mutable data requires careful thought in an environment where it is prone\nto change.\n"},{"id":962,"cve":"CVE-2014-3156","project_name":"chromium","description":"Inside of the clipboard implementation there was a buffer overflow vulnerability. When trying to copy certain things to clipboard, the renderer cliboard would return something with NULL pixels causing this overflow.","mistakes":"From the solution I am seeing it seems to just be a simple coding mistake. The developer just allocates and does arithmatic with values that are never checked so this problem arose quickly."},{"id":946,"cve":"CVE-2014-1734","project_name":"chromium","description":"","mistakes":null},{"id":947,"cve":"CVE-2014-1735","project_name":"chromium","description":"","mistakes":null},{"id":948,"cve":"CVE-2014-1736","project_name":"chromium","description":"","mistakes":null},{"id":949,"cve":"CVE-2014-1740","project_name":"chromium","description":"This vulnerability was an example of trying to use memory after it has been discarded.\nIt could lead to a crash of Chrome thus giving a denial of service attack and potentially\nothers issues. The exploit affected ninety-three versions of Chrome. After being\ndiscovered, Google's AddressSanitizer was able to find the issue and detect the leak.\nWhile this vulnerability was fixed, the tests were never added due to other code they\ndepended on not ready to be merged in.\n","mistakes":"This error was found because of the lack of testing. This test case itself \nseemed to be a fairly obscure case that I can easily see the team missing.\nThe evidence for this being an obscure edge case is further supported by the \ncode remaining unchanged for 4 years. The area was indeed unit \ntested so it was not for lack of testing per say that this was not found. \nA cursory internet search does not lead me to find the script the reporter used and \nit is likely they created the script themselves or was looking for this specific case \nand then made the script afterwards to confirm it.\n"},{"id":951,"cve":"CVE-2014-1742","project_name":"chromium","description":"","mistakes":null},{"id":952,"cve":"CVE-2014-1743","project_name":"chromium","description":"Attackers could cause an application crash by exploiting a use-after-free\nvulnerabilty in Blink. Use-after-free is a vulnerabilty where the use of\npreviously freed memory creates unexpected behavior.\n","mistakes":"The code for where this vulnerability exists seemed to be changing\nas multiple began pushing their commits. The use of  the\"free\" operation in the code seemed to be\nintroduced by miscommunication where one user removed a check and another user\nadded a feature without said check.\n"},{"id":955,"cve":"CVE-2014-1746","project_name":"chromium","description":"A function relies on an integer data type that is not large enough. This\nvulnerability allows for attackers to cause a denial of service by using vectors\nwith a buffer larger than the integer data type mentioned above, this leads to\nan out-of-bounds error.\n","mistakes":"This bug was caused by developers not realizing that changing the data type to\nint would not allow for the variable to be sufficiently large. This error would\nwould be classified as a coding mistake. When making any changes, developers\nshould take time to contemplate why things were the way they\nwere. Unless the developer is intimately knowledgeable about the source code,\nit's a good idea to consult colleagues about potential changes.\n"},{"id":958,"cve":"CVE-2014-1749","project_name":"chromium","description":"","mistakes":null},{"id":959,"cve":"CVE-2014-3152","project_name":"chromium","description":"","mistakes":null},{"id":1047,"cve":"CVE-2015-1213","project_name":"chromium","description":"","mistakes":null},{"id":1048,"cve":"CVE-2015-1214","project_name":"chromium","description":"","mistakes":null},{"id":965,"cve":"CVE-2014-3160","project_name":"chromium","description":"","mistakes":null},{"id":967,"cve":"CVE-2014-3162","project_name":"chromium","description":"","mistakes":null},{"id":968,"cve":"CVE-2014-3165","project_name":"chromium","description":"","mistakes":null},{"id":970,"cve":"CVE-2014-3167","project_name":"chromium","description":"","mistakes":null},{"id":971,"cve":"CVE-2014-3168","project_name":"chromium","description":"","mistakes":null},{"id":973,"cve":"CVE-2014-3170","project_name":"chromium","description":"","mistakes":null},{"id":974,"cve":"CVE-2014-3171","project_name":"chromium","description":"","mistakes":null},{"id":975,"cve":"CVE-2014-3172","project_name":"chromium","description":"The Debugger Extension API does not validate the tab's URL, allowing an attacker to get root access and bypass all\nChrome security.\n","mistakes":"It appears that this vulnerability was a case where accessing the tab's permissions may have been overlooked. \nAlthough there were very particular steps invovled in reproducing the vulnerability, the exploit would have been a huge disaster. \nThe attacker would have been able to wiretap the user's microphone, disable touchpad, DoS, steal private keys, etc. \nSo although the steps to reproduce the exploit requires expert knowledge, the exploit would have caused distrust with Chrome.\n"},{"id":977,"cve":"CVE-2014-3174","project_name":"chromium","description":"","mistakes":null},{"id":978,"cve":"CVE-2014-3175","project_name":"chromium","description":"","mistakes":null},{"id":979,"cve":"CVE-2014-3176","project_name":"chromium","description":"","mistakes":null},{"id":980,"cve":"CVE-2014-3177","project_name":"chromium","description":"","mistakes":null},{"id":981,"cve":"CVE-2014-3178","project_name":"chromium","description":"","mistakes":null},{"id":982,"cve":"CVE-2014-3179","project_name":"chromium","description":"","mistakes":null},{"id":983,"cve":"CVE-2014-3187","project_name":"chromium","description":"","mistakes":null},{"id":984,"cve":"CVE-2014-3188","project_name":"chromium","description":"","mistakes":null},{"id":1049,"cve":"CVE-2015-1215","project_name":"chromium","description":"","mistakes":null},{"id":988,"cve":"CVE-2014-3192","project_name":"chromium","description":"","mistakes":null},{"id":989,"cve":"CVE-2014-3193","project_name":"chromium","description":"","mistakes":null},{"id":990,"cve":"CVE-2014-3194","project_name":"chromium","description":"","mistakes":null},{"id":991,"cve":"CVE-2014-3195","project_name":"chromium","description":"","mistakes":null},{"id":993,"cve":"CVE-2014-3197","project_name":"chromium","description":"","mistakes":null},{"id":994,"cve":"CVE-2014-3198","project_name":"chromium","description":"When scrolling using the arrow keys the subsystem PDFium does a check for the first visible page.  In the case where there is not yet a visible page this check will return -1.  There was no check for this scenario which caused an attempt to index by -1 resulting in a buffer overflow. The app would then crash causing a denial of service. The buffer overflow also exposes the app to potential data corruption or malicious code execution.","mistakes":"The vulnerability was caused by simply overlooking the case where there is no visible page and -1 is returned, which causes the logic to try and index by -1.  Once the fuzzer found the issue it was a very simple fix.\nInterestingly this case of returning -1 when there is no visible page was checked for further down in the file. In the entire file they checked for the first visible page 3 times.  The first 2 occasions they did not check to see if -1 was returned, but the third time they did. Due to the fact the the VCC added a lot of functionality this leads me to beleive that they did not thouroughly check the commit and only happened to consider this edge case in the third scenario.  Because there was no unit testing they did not notice this simple mistake until the fuzzer found it and then they were able to add in the checks for -1."},{"id":995,"cve":"CVE-2014-3199","project_name":"chromium","description":"","mistakes":null},{"id":996,"cve":"CVE-2014-3200","project_name":"chromium","description":"","mistakes":null},{"id":999,"cve":"CVE-2014-7899","project_name":"chromium","description":"","mistakes":null},{"id":1000,"cve":"CVE-2014-7900","project_name":"chromium","description":"","mistakes":null},{"id":1001,"cve":"CVE-2014-7901","project_name":"chromium","description":"","mistakes":null},{"id":1002,"cve":"CVE-2014-7902","project_name":"chromium","description":"","mistakes":null},{"id":1003,"cve":"CVE-2014-7903","project_name":"chromium","description":"","mistakes":null},{"id":1004,"cve":"CVE-2014-7904","project_name":"chromium","description":"","mistakes":null},{"id":1005,"cve":"CVE-2014-7905","project_name":"chromium","description":"","mistakes":null},{"id":1006,"cve":"CVE-2014-7906","project_name":"chromium","description":"","mistakes":null},{"id":1007,"cve":"CVE-2014-7907","project_name":"chromium","description":"","mistakes":null},{"id":1008,"cve":"CVE-2014-7908","project_name":"chromium","description":"Integer overflow for multiple media file types. This overflow vulnerability\nallows attackers to cause a denial of serivce. Any Mov/QuickTime/MPEG4 Container\nhad a defect that could cause performance degradation and potentially be used to\nas a vector for denial of service attacks.\n","mistakes":"The biggest mistake that lead to this vulnerability was focusing efforts on higher\npriority bugs that existed within the same file. This was a coding bug as there was\nan initial check for integer overflow, however it was not robust enough to cover\nall cases. The working solution for this bug is using Input Validation. This is done\nby ensuring that the input is within expected bounds of what should be expected. This fix\nlooks proper as it changes the following two lines\n  int atomsize = Read32(buffer + offset); --\u003e uint32 atomsize = Read32(buffer + offset);\n  if (atomsize \u003c= 0) --\u003e if (atomsize == 0 || atomsize \u003e static_cast\u003csize_t\u003e(buffer_size))\nThese fixes show that it uses checks to see if the input is within the proper bounds, as\nwell as paying close attention to variable types in calculations for a given language.\n"},{"id":1009,"cve":"CVE-2014-7909","project_name":"chromium","description":"","mistakes":null},{"id":1010,"cve":"CVE-2014-7910","project_name":"chromium","description":"","mistakes":null},{"id":1401,"cve":"CVE-2017-5031","project_name":"chromium","description":"Use after free in ANGLE.\n","mistakes":null},{"id":1013,"cve":"CVE-2014-7925","project_name":"chromium","description":"Chrome tab crashes because audio nodes in the Blink WebAudio component are being destroyed/disposed by the garbage collector. This is caused by racing in the AudioContext thread and the Garbage Collector thread. It means that as an Audio node is traversing it's graph,there's mutation with the Garbage collector which causes Chrome to crash and the tab to close.","mistakes":"In my opinion, this was a design issue. The way threads are handled which allow data and processes that are being used by chrome are also being cleared out by the Garbage collector process."},{"id":1014,"cve":"CVE-2014-7926","project_name":"chromium","description":"The Regular Expressions package has an issue with handling empty responses or\n\"zero-length quantifiers\" allowing remote attackers to cause a denial of service \n(memory corruption), as well as other possible unforseen impacts.\n","mistakes":"A coding mistake that can be identified here is not tracking your process, \nespecially when various operations are happening at once. In this case a \ncheck was not put in place to ensure that the variables were in the correct\nstate prior to operation. This caused some information to be lost and peculiar\nthings started to happen because of it."},{"id":1015,"cve":"CVE-2014-7927","project_name":"chromium","description":"","mistakes":null},{"id":1016,"cve":"CVE-2014-7928","project_name":"chromium","description":"","mistakes":null},{"id":1018,"cve":"CVE-2014-7930","project_name":"chromium","description":"The vulnerability was in Blink, Google Chrome's browser engine, in a DOM \nimplementation of a tree data structure written in C. \n\nA DOM model represents a document with a logical tree. Each branch of the \ntree ends in a node, and each node contains objects. DOM methods allow \nprogrammatic access to the tree. \n\nThe cause of this vulnerability was that it was possible for a variable called \nTreeScope, which represents a DOM object root node, to be deleted while it was\nstill in use in another context. \n\nThis created a use-after-free vulnerability. Use After Free refers to the \nattempt to access memory after it has been freed, which can cause a program to crash\nin the best case, or can potentially result in the execution of \narbitrary code or even enable full remote code execution capabilities.\n\nFurthermore, crafted JavaScript code could trigger improper maintenance of TreeScope data through this vulnerability.\n","mistakes":"The user who committed the VCC introduced this vulnerability in his own code. \nHowever, since the concern is that different event contexts require the TreeScope at \ndifferent times, it can be argued that this is a Design mistake first and foremost. \nPointers to the root node of a DOM object should be null after the root has been deleted.\nIn this case the mitigation solution was to store a backup to the rootNode of\nthe tree. Developers should have taken into account for the tight coupling between these\ntwo contexts, and the possiblity that actions in one scope would have catastrophic effects \non another. This is more of a band-aid fix that doesn't fully adress the fact that the \nscope of these variable should not be so tightly coupled. \n"},{"id":1019,"cve":"CVE-2014-7931","project_name":"chromium","description":"","mistakes":null},{"id":1021,"cve":"CVE-2014-7933","project_name":"chromium","description":"","mistakes":null},{"id":1026,"cve":"CVE-2014-7938","project_name":"chromium","description":"","mistakes":null},{"id":1028,"cve":"CVE-2014-7940","project_name":"chromium","description":"","mistakes":null},{"id":1030,"cve":"CVE-2014-7942","project_name":"chromium","description":"","mistakes":null},{"id":1031,"cve":"CVE-2014-7943","project_name":"chromium","description":"","mistakes":null},{"id":1032,"cve":"CVE-2014-7944","project_name":"chromium","description":"","mistakes":null},{"id":1033,"cve":"CVE-2014-7945","project_name":"chromium","description":"","mistakes":null},{"id":1035,"cve":"CVE-2014-7947","project_name":"chromium","description":"","mistakes":null},{"id":1037,"cve":"CVE-2014-7967","project_name":"chromium","description":"","mistakes":null},{"id":1038,"cve":"CVE-2014-9646","project_name":"chromium","description":"","mistakes":null},{"id":1039,"cve":"CVE-2014-9647","project_name":"chromium","description":"","mistakes":null},{"id":1040,"cve":"CVE-2014-9648","project_name":"chromium","description":"","mistakes":null},{"id":1042,"cve":"CVE-2015-1205","project_name":"chromium","description":"","mistakes":null},{"id":1044,"cve":"CVE-2015-1210","project_name":"chromium","description":"When an exception is thrown in the DOM, the exception object is\ncreated by inheriting from the object the method is called on, even if it comes\nfrom a different origin. The created object does not conduct any checks on\nwhether it is supposed to be allowed access to said origin, exposing them to\npotential attackers.\n","mistakes":"This was a case in code, as this was a small hole that was easily\nremedied without any serious structural overhaul. The fixer ended up creating\na fix on what is essentially the \"server-side\" in this scenario (this is a\nbrowser vulnerability so not exactly the same typical scenario), by modifying\nthe ThrowException class in order to apply the fix in other potential exploit\nscenarios\n"},{"id":1046,"cve":"CVE-2015-1212","project_name":"chromium","description":"","mistakes":null},{"id":1053,"cve":"CVE-2015-1219","project_name":"chromium","description":"","mistakes":null},{"id":1056,"cve":"CVE-2015-1222","project_name":"chromium","description":"A use after free vulnerability was present, as there was no check against null or other unexpected input, causing the program to\ndelete space in memory, and then try to delete the same space again. This left the door open to denial of service errors or other \nimpacts when an attacker would enter a null value into the object, or other unexpected input. \n","mistakes":"I believe that a coding mistake caused this vulnerability. I think that if the programmer\nwould have validated the input and put the checks in place, the vulnerability never would \nhave come up. \n\nI think the fix that was put into place is a good mitigation. The problem was that if the context\nwas null, the system would try to delete and start over the null space in memory and it\nwas causing use after free problems, resulting in denial of service. By implementing a null check, \nit makes sure it isn't freeing up / trying to delete null space. You should check if the memory\naddress is not null before you try to free / delete it.\n"},{"id":1057,"cve":"CVE-2015-1223","project_name":"chromium","description":"","mistakes":null},{"id":1059,"cve":"CVE-2015-1225","project_name":"chromium","description":"","mistakes":null},{"id":1060,"cve":"CVE-2015-1226","project_name":"chromium","description":"","mistakes":null},{"id":1063,"cve":"CVE-2015-1229","project_name":"chromium","description":"Cookie-injection attacks via crafted response could occur when a 407 error was raised","mistakes":"This was caused by a design mistake, security was not throughly thought out when this issue was created curiously the user didnt remember to close the ticket and it took a while for the fix to be listed"},{"id":1064,"cve":"CVE-2015-1230","project_name":"chromium","description":"","mistakes":null},{"id":1065,"cve":"CVE-2015-1231","project_name":"chromium","description":"","mistakes":null},{"id":1066,"cve":"CVE-2015-1232","project_name":"chromium","description":"","mistakes":null},{"id":1067,"cve":"CVE-2015-1233","project_name":"chromium","description":"","mistakes":null},{"id":1069,"cve":"CVE-2015-1235","project_name":"chromium","description":"","mistakes":null},{"id":1070,"cve":"CVE-2015-1236","project_name":"chromium","description":"The process function in the Web Audio API function is allowing attackers to access sensitive audio sample values through an offline\nwebsite containing an offline media element \n","mistakes":"There seemed to have been a coding/maintainability mistake that could have been mitigated. The vulnerability is a difficult one to discover because it would have required extensive testing of all components of the system. This is impractical because it would require a lot of resources and you don't know what exactly you're looking for. \nOne thing that could have been looked into was that since the audio object was handling sensitive data, the subsystem that handles this object should have been a focus on unit testing. It should be common practice to evauluate areas where assets are being accessed. This vulnerability is a perfect example. The other mistake was trusting the API to be secure. The Web Audio API was responsible for hosting this vulnerability, so it would have been the Google's responsibility to evaluate the API implementation that involved handling sensitive data.\n"},{"id":1071,"cve":"CVE-2015-1237","project_name":"chromium","description":"Google Chrome was susceptible to a use-after-free vulnerability, where a \npointer is used after it has been freed. Accessing a pointer after it has been\nfreed can cause unintended behavior like: program crash, unexpected runtime \nvalues, and change in program execution. An attacker could exploit the \nvulnerability, through a specially crafted website, cause renderer crashes or \narbitrary code executions.. \n","mistakes":"This vulnerability is resultant of a coding mistake. This vulnerability \nonly required a two SLOC change, which is indicative that this vulnerability \nwas sourced from an oversight of the author. The fix only required following \nthe MITRE recommended mitigation, which is to set the pointer to null after \nfreeing. \n"},{"id":1072,"cve":"CVE-2015-1238","project_name":"chromium","description":"","mistakes":null},{"id":1073,"cve":"CVE-2015-1240","project_name":"chromium","description":"There was a vulnerability which allowed remote attackers to cause a denial of\nservice (out-of-bounds read) via a crafted WebGL program that triggers a state\ninconsistency. In other words, any attacker writing a WebGL program who is\naware of this bug may force an integer out-of-bounds read which may halt or\nbreak the WebGL operation.\n","mistakes":"The largest mistakes that led to this vulnerability were all problems with\nvalidating parameters before and after executing functions in WebGL programs.\nThis was a case of improper restriction of operations within the bounds of a\nmemory buffer. This, overall, was simply an oversight by a developer who did\nnot consider this at first, and the issue was left unknown until a hacker\ndiscovered the issue. In the end, when they put in validation measures in\norder to avoid out-of-bounds errors, the case was considered solved and I do\nbelieve that this solution has held up over time and has not been an issue\nsince this.\n"},{"id":1074,"cve":"CVE-2015-1241","project_name":"chromium","description":"On mobile, click events were able to fire outside of the scope that they were created in. This can be exploited through the use of tapjacking. Tapjacking is the concept that an attacker can listen for taps with a screen overlay, and can sniff any data that is being passed to an underlying application. This can even include credit card data or passwords. In the case of this specific vulnerability, the trigger page will redirect to the victim page (under ideal circumstances), and events can be fired across domain boundaries. This would give attackers access to input single clicks to perform simple tasks. Like buying something, or posting something. Anythig with a single button.\n","mistakes":"This seems most like a requirements mistake. The commit that introduced the vulnerability seemed to have introduced it carelessly without knowing the consequences of what they changed. Proper requirements could have cleared up the misunderstanding. It could have been a miscommunication. It's puzzling why it was introduced. It seems like it was just changed for seemingly no reason, just to be changed back once it caused an issue. It'd be interesting to know what was going through the original developers heads. Maybe there is something more to the story here. Requirements that could have been added to prevent this could be something as verbose as Taps must execute only where they belong, and must not go outside of their scope. This could have helped eliminate this issue, as it doesn't make sense for Taps to travel between subsystems and to separate web pages."},{"id":1075,"cve":"CVE-2015-1242","project_name":"chromium","description":"","mistakes":null},{"id":1076,"cve":"CVE-2015-1243","project_name":"chromium","description":"When Google first wrote it's DOM implementation the \"use-after-free\"\nvulnerability was intoduced. They iterated over a copy of a structure in\nan Observer class and never checked the conditions of the original before\nattempting to use it based on the copy. This caused the tab being used to\ncrash.\nThis could allow for a Denial of Service attack or other unspecified impact\nbecause a remote attacker can trigger this by trying to force the freeing\nof a non registered observer.\nThis also becomes a data integrity issue as the memory that was freed\nmay have been allocated again somewhere else, causing corruption of that\ndata.\n","mistakes":"The coding mistake was made when this code was first created. This code was\nnot modifed again until this bug was found. The time between the bug being\nfound, the cause of the bug and the possible fix was very short (less then a\nday).\nThis was a simple mistake where the coders assumed that the object they\nmade a copy of couldn't be changed and would remain identical to their\ncopy.\nThis mistake was mostly a coding mistake. The coders made an assumption\nabout the state of their object, and that assumption ended up being\nincorrect, which resulted in this vulnerability.\nThe reviewers likely looked over this code and thought along the same lines\nas the code author. There were not any unit tests to check for this part of\nthe code behavior, they were added after the defensive check was put into\nplace as no one anticipated this would be an issue.\n"},{"id":1077,"cve":"CVE-2015-1244","project_name":"chromium","description":"","mistakes":null},{"id":1078,"cve":"CVE-2015-1245","project_name":"chromium","description":"Use-after-free vulnerability in the OpenPDFInReaderView::Update function in \nbrowser/ui/views/location_bar/open_pdf_in_reader_view.cc in Google Chrome \nbefore 41.0.2272.76 might allow user-assisted remote attackers to cause a \ndenial of service (heap memory corruption) or possibly have unspecified other \nimpact by triggering interaction with a PDFium \"Open PDF in Reader\" button that \nhas an invalid tab association. \n\nThis can allow a malicious web site to cause a user to be redirected to a different\npage when opening a link on the original page with the \"Open PDF in Reader\" button.\nThis can cause a user's information to be stolen.\n","mistakes":null},{"id":1079,"cve":"CVE-2015-1246","project_name":"chromium","description":"","mistakes":null},{"id":1080,"cve":"CVE-2015-1247","project_name":"chromium","description":"Chrome allowed a file to be in the URL descriptor OpenSearch XML document.","mistakes":"File urls were forgotten when they added the check for valid urls, this appears to be a good fix as it is whitelisting a few urls allowed"},{"id":1081,"cve":"CVE-2015-1248","project_name":"chromium","description":"","mistakes":null},{"id":1082,"cve":"CVE-2015-1249","project_name":"chromium","description":"","mistakes":null},{"id":1083,"cve":"CVE-2015-1250","project_name":"chromium","description":"","mistakes":null},{"id":1084,"cve":"CVE-2015-1251","project_name":"chromium","description":"A Use-after-free vulnerability in the Speech subsystem allows remote attackers \nto execute arbitrary code via a crafted document. The use-after-free vulnerability\noccurs when a pointer is freed and then accessed again, thereby allowing arbitrary\ncode execution. No one was able to craft an exploit for this vulnerability but the \nerror can be replicated by initializing a speech recognition object, closing the \nwindow with window.close() and then calling the speech recognition object again, \ncausing the browser to access freed memory.\nThe main issue was caused when the system removed a managed pointer method with\nautomatic garbage collection and failed to set the pointer to null after it was freed.\n","mistakes":"The major mistake made was in removing a pointer management system and not\nreplacing it with an appropriate solution. The problem was that the document\nno longer existed in some cases and the speechRecognition object used the\ndocument after it was freed. The solution seems to be to check if the document\nis still the context, this is not the recommended solution. The CWE says to\nset the document to nil after it has been freed, this would make the check not\nneeded. An important lesson was to consider all pointers owned by a parent\nelement when removing the parent.\n"},{"id":1118,"cve":"CVE-2015-1285","project_name":"chromium","description":"By brute forcing XSS injections, secret values contained in scripts on a site can be guessed. This is because the XSS filter will trigger only when the value is guessed correctly. The site must then provide an x-xss-protection mode=block header so that the attacker knows what was blocked and what was not.","mistakes":"From my rudimentary understanding of this, it seems as if there should not be a notification for when something triggers the XSS filter. Additionally, the developers have allowed this issue to sit around for years without really addressing the source of the problem. In the long run, this will probably cost more time and resources than just addressing how the core issue with the XSS filter."},{"id":1119,"cve":"CVE-2015-1286","project_name":"chromium","description":"","mistakes":null},{"id":1087,"cve":"CVE-2015-1254","project_name":"chromium","description":"","mistakes":null},{"id":1088,"cve":"CVE-2015-1255","project_name":"chromium","description":"In Chromium, Blink, a rendering engine, is used with almost a one to one \nrelationship with each browser tab instance. It takes on the responsibility \nof rendering most of the content in a browser tab. In the \ncase of this vulenrability, Blink was trying to use a particular \nobject instance to stop playback of music content in the browser tab process after that instance \nwas destroyed. This Use-after-free vulnerability in the WebAudio implementation \nof Chromium allowed remote attackers to cause a denial of service \nor possibly have other unspecified impacts.\n\nThe fix adds to the empty an destructor to call newly introduced function \nwhich removes the instance of particular pointer from the Blink renderer engine instance so that \nit is not used later on by Blink. Even though initially in the VCC the destructor \nis empty, in C++ at time of destruction it will still destroy member variables \nof the class which is what caused our use-after-free issue being addressed here.\n","mistakes":"This appears to be an mistake with the design approach.\nSince the instance of WebAudioCapturerSource could have a shorter\nlife then Blink it should have been considered\nwhat things need to be done at time of destruction. In the case of the fix,\nadding to the destructor in WebAudioCapturerSource to remove its pointer\nto itself from Blink was the solution.    \n"},{"id":1090,"cve":"CVE-2015-1257","project_name":"chromium","description":"The graphics module used by the Chromium engine contained a bug in the FEColorMatrix.cpp file that was caused by the lack of a check for the amount of values in a matrix passed to the createColorFilter method. Specifically, if this method was passed a empty vector object it would cause a crash. This bug was proven to at least cause a denial of service and also had the potential to have a worse impact through a crafted document.","mistakes":"What ultimately led to this bug were assumptions made in the design stages. If the developers had put less trust in the surrounding code they could have avoided this vulnerability all together."},{"id":1092,"cve":"CVE-2015-1259","project_name":"chromium","description":"","mistakes":null},{"id":1094,"cve":"CVE-2015-1261","project_name":"chromium","description":"","mistakes":null},{"id":1096,"cve":"CVE-2015-1263","project_name":"chromium","description":"","mistakes":null},{"id":1097,"cve":"CVE-2015-1264","project_name":"chromium","description":"","mistakes":null},{"id":1098,"cve":"CVE-2015-1265","project_name":"chromium","description":"","mistakes":null},{"id":1100,"cve":"CVE-2015-1267","project_name":"chromium","description":"Scripts can pass any objects to the API as the chief context, meaning cross-origin scripting is possible. Therefore, information from one system can be passed into another and be considered as another system.   \n","mistakes":"The mistake was chiefly in the design/architecture domain, as developers failed to recognized that context needed to be validated. The mitigation was in accordance to the CWE recommendations, which involved obtaining the origin of the request (by passing in the global instance). An additional mitigation could have been whitelisting trusted applications using manifest.xml; however, it is not Chrome's intention to limit others applications as there are plenty of plug-ins and APIs. It is necessary to assume risk in order to reach the broader audience.  "},{"id":1103,"cve":"CVE-2015-1270","project_name":"chromium","description":"The function ucnv_io_getConverterName in the file ucnv_io.cpp doesn't parse\nstrings beginning with \"x-\" correctly, leading to potential DOS attacks.\n","mistakes":"The development team didn't consider if inputs beginning with certain \ncombinations of characters could cause problems. Better validation of\ninputs would have prevented this from becomming an issue.\n"},{"id":1104,"cve":"CVE-2015-1271","project_name":"chromium","description":"PDFium's out of memory conditions are not properly handled. This allows remote attackers to cause a denial of service or other potential attacks from a heap-based buffer overflow. This results in heap buffer overflow from a large memory allocation of a crafted PDF document.\n","mistakes":"The main factors that lead to the vulnerability were miscommunication and coding mistakes. I think it is clear looking through the comments that there was no clear task force on solving this error and many notes were inserted on the progress. This was clear by the mutliple comments back and forth on the Issue, trying to solve the bug.  Multiple months after the Issue was discovered and a solution was solved people agreed the orginal idea in the first comment would work.  The devloper on this had to be commented on to fix it, causing the bug to be open for months.  It had also exceeded the 60-day deadline for fixing a high severity security vulnerability that Google developers follow for Chromium.  There was also just a coding mistake in not checking for the alloc first."},{"id":1106,"cve":"CVE-2015-1273","project_name":"chromium","description":"This vulnerability is caused by incorrect data on an image file, which creates a heap-buffer overflow. A heap buffer overflow is different than a regular buffer\noverflow in that heaps dynamically allocate memory for usage, and the memory contains program data. When the overflow occurs, program critical data is corrupted by \nbeing overwritten; pointers are generally the victim of this. This causes instability, and denial of service by crashing services. \n\nThe subsystem is one called OpenJPG, whose purpose is to interpret and render images. Specifically here, it was for images within a PDF file, used by PDFium. \nPDFium is the Chromium tool for interpreting PDFs. The data read by OpenJPG for interpreting the image was not what the subsystem expected, so when it received improper input, it resulted in a heap buffer overflow.  \n\nThe solution was to upgrade to r3002 of OpenJPEG, which based on intuition and reasoning, added checks for the data to ensure it did not run over. \n","mistakes":"As this CVE is similar to CVE-2016-1645, which I also curated, I found it interesting that one problem could require two different solutions\nin two different, but similar, areas. \n\nThe biggest mistake that lead to this vulnerability was not properly validating inputs, and allowing invalid data to not be dynamically allocated \na larger buffer size to prevent heap-buffer overflows. \n\nThey failed to use unit testing at any phase of early development, except for seeming to add a large unit testing file that included some checks for\nthis vulnerability. There may have been some more in-between, but I was not able to look.\n\nIt seems to be a failure on multiple fronts. The original developer for not writing proper test cases, future developers for not writing them or verifying\nthat the method worked as intended, and looking for ways it could be broken, and the company for not having a proper code review to catch this before it \ncould be exploited. \n"},{"id":1108,"cve":"CVE-2015-1275","project_name":"chromium","description":"","mistakes":null},{"id":1109,"cve":"CVE-2015-1276","project_name":"chromium","description":"Use-after-free vulnerability in the IndexedDB implementation in Google Chrome allowed remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging an abort action before a certain write operation.","mistakes":null},{"id":1110,"cve":"CVE-2015-1277","project_name":"chromium","description":"Remote attackers can cause a denial of service, because some data aren't\nchecked for validity. If an attacker has a user open a specially crafted\npage, the memory resources on the user's computer could be exhausted. A\ndata tree gets serialized, and nodes aren't checked for validity as they\nare serialized.\n","mistakes":"The code was developed in such a way that tree nodes could point to freed memory"},{"id":1111,"cve":"CVE-2015-1278","project_name":"chromium","description":"","mistakes":null},{"id":1113,"cve":"CVE-2015-1280","project_name":"chromium","description":"","mistakes":null},{"id":1115,"cve":"CVE-2015-1282","project_name":"chromium","description":"In Chromium, PDF's are handled by an open sourced library called PDFium. PDFium\nwas developed along with Chromium, however the library remained closed source until 2014.\nThis vulnerability was discovered in 2015.\n\nAdobe (the creators of the PDF standards) includes a Javascript API that can allow\nPDF's to embed and execute JavaScript code in order to enhance a PDF's functionality. For ex,\nPDF's that include buttons are typically written with Javascript code. \n\nThis vulnerability allows a \"crafted\" PDF (term taken from Chromium bug report) that \ncontains specific Javascript code to crash the browser. Javascript code can cause\nthe delay() and doFieldDelay() functions in Document.cpp to call free() twice. This vulnerability \nis caused by javascript causing the PDFium (PDF) engine to enter a method, multiple times by \ncausing document level and field level JavaScript to interact using the field.delay property.\nThis would free a previously freed pointer. This results in a denial of service attack, \nsince Chromium defaults to crashing if it detects a use-after-free bug. \n","mistakes":"The mistake was a design mistake and a coding mistake. One thing the developers did well was\nthat they followed the fail securely principal. Freeing a pointer twice could cause undeterministic\noutcomes - as a result it is best to terminate when such an error occurs. However, most people\ndo not consider a vulnerability fix or good coding practice to also something that can be exploited\nfor malicious purposes. That was the case in this scenario. Knowing a foolproof mechanism to\ncrash the browser lead to malicious PDF's that could simply invoke that failsafe over and over - \nwriting a PDF that forced the browser to free a pointer twice, intentionally crashing it.\n\nOne potential solution that could be considered is to forbid Javascript in PDF's entirely - JS\nin PDF's is an enormous security risk by itself that there should be debate whether or not the benefit\nof having a Javascript API is worth the security headaches. A mitigation is to restrict the JS API \nin Acrobat API to prevent attacks as much as possible. The difficulty in this approach is the need\nto maintain security while not reducing the API so much that it is no longer useful to users.\n"},{"id":1116,"cve":"CVE-2015-1283","project_name":"chromium","description":"","mistakes":null},{"id":1121,"cve":"CVE-2015-1288","project_name":"chromium","description":"","mistakes":null},{"id":1122,"cve":"CVE-2015-1289","project_name":"chromium","description":"","mistakes":null},{"id":1123,"cve":"CVE-2015-1291","project_name":"chromium","description":"","mistakes":null},{"id":1124,"cve":"CVE-2015-1292","project_name":"chromium","description":"Blink, the rendering engine of Google Chrome since 2013, had a defect where an internal navigation function had no verification on the origin of a request.\nThis allowed a malicious attacker to perform arbitary cross site scripting if they were able to call this function.","mistakes":"The coding mistake made here was being too excited in implementing a new feature\nand not checking that the entities using the feature are who they say they are.\n\nThis was a design mistake mostly. The code written in this library does (and did)\nwhat it is intended to do. The designers of the subsystem did not think about the\ncase of untrusted users accessing the worker and so never thought to check.\n\nThe principle of defense in depth applies here mostly. Since service workers\nare a heavily integrated component of modern web browsers, any malicious user\ncould have injected arbitary code into browsers if they were able to somehow\ninvoke a service worker in the wrong context.\n"},{"id":1126,"cve":"CVE-2015-1294","project_name":"chromium","description":"","mistakes":null},{"id":1129,"cve":"CVE-2015-1297","project_name":"chromium","description":"The WebRequest API did not properly consider a request's source before\naccepting the request. This allows the bypassing of access restrictions.\n","mistakes":"Introduced in a bug fix 3 years prior. In fixing a similar bug with permissions,\nthis bug was introduced.\n"},{"id":1130,"cve":"CVE-2015-1298","project_name":"chromium","description":"","mistakes":null},{"id":1132,"cve":"CVE-2015-1300","project_name":"chromium","description":"A bug in Blink, Chrome's rendering engine, allowed malicious actors to read cross domain URLs from a browser after a redirect through an iFrame","mistakes":"This vulnerability actually was present on all browsers at the time (Firefox, IE, Chrome) and was demo'd/exploited on this website http://vwzq.net/lab/xreadurl/.  Given this, it's safe to assume that this vulnerability was the result of an assumption that all browser developers made and was a design flaw"},{"id":1133,"cve":"CVE-2015-1301","project_name":"chromium","description":"","mistakes":null},{"id":1134,"cve":"CVE-2015-1302","project_name":"chromium","description":"A vulnerability existed in Google Chrome where a web page could read PDF\ncontent from any other web page. This is an XSS vulnerability.\n","mistakes":"The mistake that lead to this vulnerability is likely a design mistake.\nThe team either didn't consider that external PDF files could be loaded,\nor didn't consider it a problem if they were. The fix looks proper, in that\nafter the fix external PDF files from outside the origin can no longer be\nloaded and executed. \n"},{"id":1135,"cve":"CVE-2015-1303","project_name":"chromium","description":"","mistakes":null},{"id":1136,"cve":"CVE-2015-1304","project_name":"chromium","description":"","mistakes":null},{"id":1137,"cve":"CVE-2015-1346","project_name":"chromium","description":"","mistakes":null},{"id":1138,"cve":"CVE-2015-1359","project_name":"chromium","description":"","mistakes":null},{"id":1139,"cve":"CVE-2015-1360","project_name":"chromium","description":"","mistakes":null},{"id":1162,"cve":"CVE-2015-6762","project_name":"chromium","description":"This vulnerability is an example of a circumvention of the Same-origin \nimplementation on Google Chrome. This vulnerability occurred in the manner \nGoogle Chrome handled Cascading Style Sheets (CSS); more specifically, it \noccurred in the code that fetched the fonts resource for a web page. The \nomission of the use of the Cross-origin Resource Sharing (CORS) algorithm, \nallows an attacker to bypass the single origin policy through JavaScript \nthat requests a font through a redirect. The Google Chrome panel did believe\nthat this vulnerability did not bypassed anything other than DRM. \n","mistakes":"The defect that caused this vulnerability is primarily from a coding mistake. \nAccording to the bug reports and commit messages, it is evident that CORs \nhandling of remote fonts are a requirement. Additionally, the fix did not \nrequire a significant rework of the code, therefore it was not a significant \noversight in the system architecture. The original author just had a \nmisunderstanding how to effectively implement CORS. \n"},{"id":1163,"cve":"CVE-2015-6763","project_name":"chromium","description":"","mistakes":null},{"id":1164,"cve":"CVE-2015-6764","project_name":"chromium","description":"","mistakes":null},{"id":1141,"cve":"CVE-2015-2238","project_name":"chromium","description":"","mistakes":null},{"id":1142,"cve":"CVE-2015-2239","project_name":"chromium","description":"","mistakes":null},{"id":1143,"cve":"CVE-2015-2808","project_name":"chromium","description":"","mistakes":null},{"id":1144,"cve":"CVE-2015-3333","project_name":"chromium","description":"","mistakes":null},{"id":1146,"cve":"CVE-2015-3335","project_name":"chromium","description":"","mistakes":null},{"id":1148,"cve":"CVE-2015-3910","project_name":"chromium","description":"","mistakes":null},{"id":1149,"cve":"CVE-2015-4000","project_name":"chromium","description":"","mistakes":null},{"id":1150,"cve":"CVE-2015-5605","project_name":"chromium","description":"","mistakes":null},{"id":1151,"cve":"CVE-2015-6580","project_name":"chromium","description":"","mistakes":null},{"id":1152,"cve":"CVE-2015-6581","project_name":"chromium","description":"","mistakes":null},{"id":1153,"cve":"CVE-2015-6582","project_name":"chromium","description":"","mistakes":null},{"id":1155,"cve":"CVE-2015-6755","project_name":"chromium","description":"This issue is found in chromium reported on august 11 2015 found by Mariusz\nMlynski.\n\nFrom /WebKit/Source/core/dom/ContainerNode.cpp:\n\nparserRemoveChild| can run script, and it can remove |nextChild| from DOM or\nmove the node around. When this happens, the tree will be in an inconsistent\nstate after the |insertBeforeCommon| call, allowing an attacker to bypass the\nframe restrictions.\n\nAttackers can exploit this issue to execute arbitrary code, bypass certain\nsecurity restrictions and perform unauthorized actions and to gain access to\nsensitive information that may aid in further attacks.\n","mistakes":"It really just boils down to improper testing on this one. This was an edge\ncase that the original author did not check for. The original user\nwho wrote the code didn't check the parent of the nextChildNode, and simply\ndidn't see the potential vulnerability there. All that took to fix it was a\nsimple check, and if failed, a return statement.\nThe issue was a really severe security risk, and could have been used to\nperform attacks on users by executing arbitrary code and gain access to private\ninformation. These seem like dire consequences for a missed check, but it doesn't\ntake much for an attacker to gain access to a system.\nAfter making the fix, it maintains the integrity of the DOM tree, as the insertion\nof the newChild node is aborded, and the addition of the return statement rectifies\nthe ability for an attacker to exploit the vulnerability in this edge case.\n"},{"id":1156,"cve":"CVE-2015-6756","project_name":"chromium","description":"","mistakes":null},{"id":1157,"cve":"CVE-2015-6757","project_name":"chromium","description":"Trying to access data in ServiceWorker after it has been freed, creating a Denial of Service Vulnerability. In C, data is freed once it's use is complete to save memory and allow the unused data to be picked up by the garbage collector. Once a data struct or pointer has been freed, you are no longer able to acces that block of data, creating a seg fault and crashing the system in many cases. Also, by freeing the data before its use is complete, the system is denied the service of, or unable to access, the ServiceWorker.  The ServiceWorker was freed too early its callback function thus creating this use-after-free vulnerability.","mistakes":"The mistake made here was a basic C coding mistake, which was freeing up data and then trying to access that freed data that no longer exists.\nAs far as the mitigation for using data aftering freeing goes, The fix looks proper, as data is now freed after it is done being used."},{"id":1158,"cve":"CVE-2015-6758","project_name":"chromium","description":"","mistakes":null},{"id":1159,"cve":"CVE-2015-6759","project_name":"chromium","description":"The origin of a LocalStorage resource in Google Chrome is not verified to be unique allowing remote attackers to obtain sensitive information via vectors involving a blob: URL\n","mistakes":"Unit testing did not properly cover all possible cases allowing for an incorrent validator to be used\n"},{"id":1160,"cve":"CVE-2015-6760","project_name":"chromium","description":"","mistakes":null},{"id":1161,"cve":"CVE-2015-6761","project_name":"chromium","description":"A function in FFMPEG, used by Google Chrome before 46.0.2490.71 relies on a coefficient-partition count during multi-threaded operation, allowing for a denial of service or an unspecified impact via a crafted WebM file\n","mistakes":"The main issue arose from an issue in FFMPEG resulting in a race condition that caused FFMPEG to terminate. The fix involved updating the version of FFMPEG being used as well as updating dependency tests to ensure that the issue doesn't repeat. This issue is a coding mistake in FFMPEG that results in a race condition. This bug is not directly inside Chrome\n"},{"id":1199,"cve":"CVE-2016-1612","project_name":"chromium","description":"","mistakes":null},{"id":1169,"cve":"CVE-2015-6769","project_name":"chromium","description":"The code that triggers unloading a window allows remote attackers to bypass \nthe Same Origin Policy (aka SOP) by using the delay in window proxy clearing.\n","mistakes":"It was a coding mistake, there was an extra line of code that ran the\nscript that gave an attacker time to execute an attack.\n"},{"id":1170,"cve":"CVE-2015-6770","project_name":"chromium","description":"","mistakes":null},{"id":1171,"cve":"CVE-2015-6771","project_name":"chromium","description":"","mistakes":null},{"id":1173,"cve":"CVE-2015-6773","project_name":"chromium","description":"","mistakes":null},{"id":1176,"cve":"CVE-2015-6776","project_name":"chromium","description":"","mistakes":null},{"id":1177,"cve":"CVE-2015-6777","project_name":"chromium","description":"In versions of Google Chrome before 47.0.2526.73 there was a vulnerabilty that\nwould cause the application to crash due to memory that was referenced after\nbeing freed by the application. This problem could have been leveraged to cause\ndenial of service attacks or other unspecified results.\nThis vulnerability was apart of the ContainerNode portion of the core WebKit \ncode. More specifically, it was triggered when a container node was inserted by\nthe ContainerNode::notifyNodeInsertedInternal function without checking if the \nnode was in the shadow tree.\n","mistakes":"This error was definitely a very simple coding mistake. The original commit \nthat introduced this error was meant to optimize node insertion by not \nnotifying leaf nodes when inserting a node into a detached tree. There was\na lack of foresight in not checking if the node in question that was\nin the shadow tree. Because of this, references to freed memory were made.\n"},{"id":1178,"cve":"CVE-2015-6778","project_name":"chromium","description":"This is a heap-overflow bug in Chromium's PDF reader. There is an image format called JBIG2 (similar to JPEG)\nand PDFs can store internal JBIG2 images. Specially crafted JBIG2 images would cause the image decoder to\nwrite to uninitialized memory.\n","mistakes":"The primary fix for this issue was listed as using C++ std::vector instead of doing manual memory management\nwhich is listed as a common mitigation strategy. I believe this issue was caused by a subtle mistake that anyone\ncould have made, just a simple coding mistake.\n"},{"id":1402,"cve":"CVE-2017-5032","project_name":"chromium","description":"Out of bounds write in PDFium. Chrome Browser is vulnerable to Out of Bound\nWrite/Invalid Pointer Write vulnerability due to improper pointer arithmetic\nwhile parsing malformed PDF file due incorrect validation - could be used to\ngain Remote Code Execution.\n","mistakes":null},{"id":1184,"cve":"CVE-2015-6785","project_name":"chromium","description":"Hostnames formatted as x.y were accepted as valid for *.x.y pattern, enabling\nusers to bypass access restrictions.\n","mistakes":"Faulty code and test cases resulted in the vulnerability. Test cases were\nexpected the opposite behavior of what should have occured, and allowed the\nvulnerability to exist for 4 years before being found. The fix to code as well\nas the unit tests appears to be sufficient and correct.\n"},{"id":1186,"cve":"CVE-2015-6787","project_name":"chromium","description":"","mistakes":null},{"id":1190,"cve":"CVE-2015-6791","project_name":"chromium","description":"","mistakes":null},{"id":1191,"cve":"CVE-2015-6792","project_name":"chromium","description":"There was a race condition that was not checked for. The MIDI subsystem in \nGoogle Chrome before 47.0.2526.106 does not properly handle the sending of \ndata, which allows remote attackers to execute arbitrary code or cause a \ndenial of service (application crash) via unspecified vectors, related to \nmidi_manager.cc, midi_manager_alsa.cc, and midi_manager_mac.cc, a different \nvulnerability than CVE-2015-8664.\n","mistakes":null},{"id":1192,"cve":"CVE-2015-7834","project_name":"chromium","description":"","mistakes":null},{"id":1193,"cve":"CVE-2015-8478","project_name":"chromium","description":"","mistakes":null},{"id":1194,"cve":"CVE-2015-8479","project_name":"chromium","description":"This vulnerability exists in the handling of an audio output device. The \ndevice's ability to communicate with other processes is supposed to be \ndisabled when the device is unauthorized. However the communication is \nnever actually closed so the unauthorized device remains registered. This \nmeans that an attacker can cause a denial of service by corrupting memory \noutside the bounds of execution. The bug description describes it as a \nheap-use-after-free. \n","mistakes":"After researching this vulnerability it appears that this is a case of someone going\nback and fixing a mistake in their code. The IPC stream is not closed when an audio \noutput device is unauthorized. The fix is only one line so it seems like this could\nbe called a coding mistake if the programmer simply forgot to write that line or deleted\nit by accident. However, it could also be considered a design mistake if the programmer\nhad no plan to include that safety precaution in the first place and only noticed \nthe potential security risk later. With the stream not properly closed it would have\nbeen possible for an attacker to corrupt heap memory, causing the potential for a denial\nof service attack. However closing the stream once an audio output device is no longer \nauthorized fixes this issue. \n"},{"id":1196,"cve":"CVE-2015-8548","project_name":"chromium","description":"","mistakes":null},{"id":1197,"cve":"CVE-2015-8664","project_name":"chromium","description":"","mistakes":null},{"id":1198,"cve":"CVE-2015-8960","project_name":"chromium","description":"","mistakes":null},{"id":1200,"cve":"CVE-2016-1613","project_name":"chromium","description":"Referencing memory after it has been freed can lead to a variety of behaviors including crashing, corrupting data. \nIn this specific CVE, due to the improper handling and tracking of 2 objects, after the destruction\nof these objects from memory, they are accessed. These cause use after free vulnerabilities found \nthat allow remote attackers to cause a denial of service ( Availability attack ) as well as the potential \nfor other unspecified impact.\n","mistakes":"It was an implementation / design mistake. Since they are working with memory management, \nthey should have when writing this code to begin with handle the proper accessing of these\nobjects they create that are destroyed. This isn't the first CVE I've seen from them that they've\ndone this. This makes me wonder if Use After Free vulnerabilities aren't that commonly thought of\nwhile coding or if they just didn't plan for it in their security procedures. \n"},{"id":1201,"cve":"CVE-2016-1614","project_name":"chromium","description":"","mistakes":null},{"id":1202,"cve":"CVE-2016-1615","project_name":"chromium","description":"","mistakes":null},{"id":1203,"cve":"CVE-2016-1616","project_name":"chromium","description":"There was a vulnerability where an attacker could spoof a URL using an unfocused\nbutton in the UI via an accelerator, or keyboard shortcut. An unfocused button is a\nbutton that does not currently have the focus of the web browser. Only one button\ncan be focused at a time and hitting enter essentially clicks the currently focused\nbutton. A button can become focused after it is clicked or if it is selected through\npressing tab. The issue is that when unfocused buttons are allowed to interact with\naccelerators, or keyboard shortcuts, a malicious actor could force a user to navigate\nto an arbitrary website.\n","mistakes":"This bug is the result of a mistake during planning given that a test case that\ncould have caught the issue was never considered until a vulnerability was discovered.\nThe lesson to be taken from this is that determining obscure edge cases can\nhelp determine potentially dangerous vulnerabilities. Oversights are inevitable,\nso bounty programs a good way to get as many eyes on your code as possible. If\nthis vulnerability wasn't reported by a community member, it could have languished\nin the source code for years to come.\n"},{"id":1204,"cve":"CVE-2016-1617","project_name":"chromium","description":"A feature of a Webkit tool implemented in Blink has a function called \"\n CSPSource::schemeMatches\" has an issue where http policies (regarding\n security of the site) aren't applied to https (secure http's) as well as\n Web Services or Web Service Security policies to the https. This lowers the\n level of difficulty for remote attackers to learn whether the specific\n header files (HSTS) website has been visited (in terms of the CSP report).\n While this isn't a terribly dangerous vulnerability, it is still a detail\n to be accounted for to prevent malicious attackers from exploiting user\n information.\n","mistakes":"N/A"},{"id":1207,"cve":"CVE-2016-1620","project_name":"chromium","description":"","mistakes":null},{"id":1210,"cve":"CVE-2016-1624","project_name":"chromium","description":"A heap-based buffer overflow was discovered in Brotli open source compression\nlibrary. Although the vulnerability is categorized as a heap-based\nbuffer overflow, it is caused by an integer overflow within a function\nfrom Brotlis library, allowing remote attackers to cause a denial of service.\nGoogle Chrome uses this compression library, and the buffer can be overwritten\nand allocated in memory with the use of malloc.\n","mistakes":"This vulnerability was caused by a third party library, therefore Google was\nnot responsible for it even though they review the third party software used\ninternally. As potential mitigation, bound checking should be performed for\nbuffers, and apply some defense in depth for prevention.\n"},{"id":1212,"cve":"CVE-2016-1626","project_name":"chromium","description":"","mistakes":null},{"id":1213,"cve":"CVE-2016-1627","project_name":"chromium","description":"","mistakes":null},{"id":1214,"cve":"CVE-2016-1628","project_name":"chromium","description":"This is a vulnerability that existed when handling JPEG2000 images.\nIf properly crafted, a JPEG2000 image could be embedded inside a PDF to force\nChrome to read memory past the end of an allocated object.  This would allow an\nattacker to execute arbitrary code.  JPEG2000 image\nformat improves compression performance and image quality.  The lack of this\nJPEG format being widely used contributed to the implementation of this\nvulnernability.\n","mistakes":"There was definitely a coding mistake that allowed the execution\nof arbitrary code to be run that wasn't intended.  While I can't see it,\nOliver Chang mentions in a code review that he doesn't agree with the\npng_gt function because an overflow might be able to happen, he let's it slide\nbecause it's only used once there.  Based on that comment that leads me to believe\nthe fix was not properly implemented on the pdfium side because if that function\ngets used again without proper checks, this could lead to more overflow errors.\nMaintainability was also a problem that became apparent in the build fail commits.\n"},{"id":1215,"cve":"CVE-2016-1629","project_name":"chromium","description":"","mistakes":null},{"id":1219,"cve":"CVE-2016-1633","project_name":"chromium","description":"This is a typical use-after-free. A pointer is pointing to a location in the heap. That location is then free'd with a call to free() or delete() and then that memory location can no longer be considered valid. Any pointer that attempts to read this memory address back MAY get a correct response, but the memory allocator is free to put whatever it wants back in this location. This is usually not possible in other programming languages, specifically those that use Garbage collection.","mistakes":"When looking at what was changed in order to fix the CVE, there are just two lines that are deleted and then checks performed to do the same actions that were performed in the line before.\nIt happens often, but if the mistake is actually as simple as these commits make it out to be then it's a case of checking a pointer's datatype, and verifying that the pointer is valid before performing an action that relies on that pointer's integrity.\nIn this project's C/C++ guidelines, there should be reference to bounds checking and pointer checking before any pointer operations are performed. Tests can be written to make sure that pointers have their data checked before being operations that could result in errors are performed. Stricter code review by team members should also be able to catch potential problems like this in the future."},{"id":1221,"cve":"CVE-2016-1635","project_name":"chromium","description":"In Chrome extensions there was a vulnerability that was discovered by a project\ncommitter. The vulnerability allowed malcious extensions to use memory that\nwas previously freed, by closing or writing to the page and then uing a function\nthat referenced the previous pointer.\n\nThis flaw is normally created during the architechture and implementation phases\nwhen the developer fails to consider all of the paths associated with a pointer.\nThe reviewer who discovered the bug also provided a patch to fix it.\n","mistakes":"The creation of this vulnerability appears to be due to oversight by the\ninitial developer and failure to be caught during the course of the code\nreview."},{"id":1223,"cve":"CVE-2016-1637","project_name":"chromium","description":"","mistakes":null},{"id":1225,"cve":"CVE-2016-1639","project_name":"chromium","description":"Based on the report of CVE-2016-1639, there is a Use after Free vulnerability in the WebRTC Audio Private API implementation in Google Chrome.\n\nUse after Free is a memory problem where the memory is referenced after it is freed. Developers usually face this problem in many application where\nthey have to allocate memory and the previoused memory was freeed. It may cause the program to crash or use unexpected value to perform a certain action. \n\nThe Use after Free vulnerability is dicovered in the file webrtc_audio_private_api.cc with the path browser/extensions/api/webrtc_audio_private/webrtc_audio_private_api.cc\nin the WebRTC API. The vulnerability may cause denial of service or unexpect result by dependent on resource context pointer. \n","mistakes":"The Use after Free is a simple oversight issue when the system has to deal with pointer. However, it seem like the vulnerability is ignore in commit \nf9583f83523a0ad7c2c97300dfe303066bcb1ec0. The system attempted to retrieval the media device ID salt even after resourceContext is no longer available. \nThe design may not work well to lead to this vulnerability. It is important to have a solid design of how to handle memory allocation and free it afterward. "},{"id":1239,"cve":"CVE-2016-1653","project_name":"chromium","description":"","mistakes":null},{"id":1240,"cve":"CVE-2016-1654","project_name":"chromium","description":"","mistakes":null},{"id":1435,"cve":"CVE-2017-5070","project_name":"chromium","description":"Type confusion in V8. This problem is related to the crankshaft JIT.\n","mistakes":null},{"id":1436,"cve":"CVE-2017-5071","project_name":"chromium","description":"Out of bounds read in V8.\n","mistakes":null},{"id":1228,"cve":"CVE-2016-1642","project_name":"chromium","description":"","mistakes":null},{"id":1230,"cve":"CVE-2016-1644","project_name":"chromium","description":"In the Blink Layouter, heap memory was used after being freed. This could result in arbitrary code execution or data corruption.\n","mistakes":"The mistake that was made ended up resulting from misunderstanding of how the code should work in the particular case. At one point, a variable was supposed to be false, however code was removed that verified this. This miscommunication in requirements was later clarified while fixing this vulnerability.\n"},{"id":1232,"cve":"CVE-2016-1646","project_name":"chromium","description":"","mistakes":null},{"id":1235,"cve":"CVE-2016-1649","project_name":"chromium","description":"","mistakes":null},{"id":1236,"cve":"CVE-2016-1650","project_name":"chromium","description":"","mistakes":null},{"id":1264,"cve":"CVE-2016-1678","project_name":"chromium","description":"","mistakes":null},{"id":1464,"cve":"CVE-2017-5100","project_name":"chromium","description":"Use after free in Chrome Apps.\n","mistakes":null},{"id":1241,"cve":"CVE-2016-1655","project_name":"chromium","description":"Before 50.0.2661.75, a denial of service / use-after-free vulnerability exists \nin Google Chrome where a crafted extension can be used to create an infinite \namount of new hidden windows that each have an observer tied to it that is\nnot deleted on frame removal\n","mistakes":"This was mainly a design mistake with a slight requirements mistake.\nThe design mistake was using observables that were not able to be cancelled.\nIt was never explicitlly stated, however I believe if the ability to easily\ncancel them was available, a developer would have had the thought to protect\nagainst this vulnerability. This is a requirements mistake because it was \nnot specifically stated to test against this. However, this requirements \nmistake is within reason, beacuse this exploit was extremely well crafted \nand required many layers of exploitation. It is not reasonable to plan for \nthis exact vulnerability beforehand. I believe this fix is a correct balance\nbetween how invasive it is, and how well thought designed it is.\n"},{"id":1244,"cve":"CVE-2016-1658","project_name":"chromium","description":"","mistakes":null},{"id":1245,"cve":"CVE-2016-1659","project_name":"chromium","description":"","mistakes":null},{"id":1246,"cve":"CVE-2016-1660","project_name":"chromium","description":"There was a problem in the library where attackers could cause a DoS attack \nwhere an input would cause an overflow error and crash the service. The function\nwould try to assert that the index specified is actually within the bounds of the array.\nHowever, before the fix, the assert that would throw an error if the index was out of range\nwould only throw an error in debug mode. The fix caused the error to be thrown in debug or\nproduction mode.\n","mistakes":"I believe that the only real vulnerability that led to this mistake on the chromium side is the\nfact that they trusted an outside source library to be secure, even though the outside library\nwas well established. I believe that the chromium team should've looked through the source before\njust adding it to their project. However, with the size of the WebKit repo, I know that it is likely\nimpossible to look over everything.\n"},{"id":1248,"cve":"CVE-2016-1662","project_name":"chromium","description":"","mistakes":null},{"id":1249,"cve":"CVE-2016-1663","project_name":"chromium","description":"","mistakes":null},{"id":1250,"cve":"CVE-2016-1664","project_name":"chromium","description":"","mistakes":null},{"id":1251,"cve":"CVE-2016-1665","project_name":"chromium","description":"","mistakes":null},{"id":1252,"cve":"CVE-2016-1666","project_name":"chromium","description":"","mistakes":null},{"id":1255,"cve":"CVE-2016-1669","project_name":"chromium","description":"","mistakes":null},{"id":1256,"cve":"CVE-2016-1670","project_name":"chromium","description":"","mistakes":null},{"id":1258,"cve":"CVE-2016-1672","project_name":"chromium","description":"","mistakes":null},{"id":1259,"cve":"CVE-2016-1673","project_name":"chromium","description":"When navigating from a new document to an empty document using Google's\n*Blink* engine, the engine loaded the request without checking whether\nnavigation was allowed. Due to this, it was possible to execute an XSS attack\nvia the request, bypassing the browser's protections.\n","mistakes":"When the vulnerability was introduced, the method containing it did not have\nanything that would allow the code to adhere to the Same Origin Policy.\nIn that area, it took some time for parts of this system to adhere to the\npolicy; I would not be surprised if there were related UXSS CVEs surrounding\nthat code area, especially in the second navigate method.\n\nUltimately, it appears that the vulnerability persisted due to a series of\noversights by developers. The VCC did not understand the risk of not\nvalidating the request before loading it; a subsequent developer made the\nsame error when making the second navigate method right below the first.\nThe vulnerability was passed over twice in code reviews, first in an\nunrelated code review that accidentally reverted code, and again in a second\ncode review that merely sought to restore reverted code. When adding\nadditional parameters to the method for user gesture support, the\nvulnerability remained untouched. The successive failures to recognize the\nvulnerability were what allowed a critical universal cross-site scripting\nvulnerability to continue to exist for almost 2 years.\n\nIt surprises me that the commit making changes to adhere to the Same Origin\nPolicy in the second navigate method overlooked the same occurrence four\nlines above. Perhaps it lasted for so long because developers were\nlaser-focused in the tasks they set out to accomplish. I would credit this\ntask-related \"tunnel vision\" to the maintenance of the vulnerability over\ntime.\n"},{"id":1260,"cve":"CVE-2016-1674","project_name":"chromium","description":"","mistakes":null},{"id":1262,"cve":"CVE-2016-1676","project_name":"chromium","description":"","mistakes":null},{"id":1263,"cve":"CVE-2016-1677","project_name":"chromium","description":"","mistakes":null},{"id":1265,"cve":"CVE-2016-1679","project_name":"chromium","description":"The ToV8Value function has unneccessary calls of setter functions that may\ncrash the Google Chrome Web Browser: This is due to a lack of necessary\nrestrictions on these getter and setter functions in the ToV8Value function.\nThe ToV8Value should never call setter functions. This behavior was\nunneccessary to execute its intended purpose. This flaw can be manipulated\nto trigger a use-after-free, and crash google chrome (Denial of Service).\n","mistakes":"A design/coding mistake has been made for this section of code. A setter\nwas introduced in an area where there was no need or reason for it, which\nlead to a denial of service by crashing the site.\n"},{"id":1266,"cve":"CVE-2016-1680","project_name":"chromium","description":"","mistakes":null},{"id":1267,"cve":"CVE-2016-1681","project_name":"chromium","description":"","mistakes":null},{"id":1268,"cve":"CVE-2016-1682","project_name":"chromium","description":"Checks to verify the content security policy (CSP) of a request were missing\nfrom a function that registers service workers. This allowed attackers to\nbypass CSP and register service workers even if they shouldn't have been\nable to.\n","mistakes":"It seems as though the developer just didn't think to check for CSP\nbefore registering the service workers. The fix was simply adding an if\nstatement before registration to check the CSP, so the mistake made by the\noriginal developer was just forgetting to make that check.\n"},{"id":1269,"cve":"CVE-2016-1683","project_name":"chromium","description":"","mistakes":null},{"id":1270,"cve":"CVE-2016-1684","project_name":"chromium","description":"","mistakes":null},{"id":1271,"cve":"CVE-2016-1685","project_name":"chromium","description":"","mistakes":null},{"id":1272,"cve":"CVE-2016-1686","project_name":"chromium","description":"A specific function in a PDF renderer which didn't properly handle a failure\nduring its initialization causes a denial of service (out-of-bounds read) via\na crafted PDF document that contained a malformed JPG image. An attacker who\nknows this exploit could potentiallycause the function to halt or crash,\nmeaning the browser utilizing this  function may have issues resulting from\nthis problem.\n","mistakes":"In my opinion, the mistakes were mostly coding mistakes, where ways of\navoiding issues such as this were already known to the coding world, however\nthe developer who originally wrote the functions here did not put them to\nuse. Simply adding wrappers and distrusting input fixed the issue.\n\nOverall, this was a very interesting vulnerability which might not have been\nobvious to most engineers tasked to do this, and I think that this only goes\nto show that the scope of vulnerabilities will always be larger than what\nyou initially expect. \n"},{"id":1274,"cve":"CVE-2016-1688","project_name":"chromium","description":"","mistakes":null},{"id":1276,"cve":"CVE-2016-1690","project_name":"chromium","description":"","mistakes":null},{"id":1277,"cve":"CVE-2016-1691","project_name":"chromium","description":"","mistakes":null},{"id":1278,"cve":"CVE-2016-1692","project_name":"chromium","description":"When downloading a style sheet, the checks on the style sheet were\ninsufficient. An actor could carefully craft a style sheet such that they\ncould inject scripting that could not only be executed, but it could have\naccess to native functions. This could lead to the attacker executing their\nown scripting with the native functions.\n","mistakes":"I believe this vulnerability was caused due to poor design. I don't believe\nit should be the programmer's responsibility to think about all scenarios\nwhere something could go wrong when processing stylesheets. I believe if\nthe Chromium team had used something a validation subsystem, where whenever\nstylesheet files were being used, they must go through this validation.\n\nI can only imagine how many places in chromium use stylesheets and would\nneed to validate using the validations the fix had, so it would be better\noff if there was a single location where this validation occured, rather\nthan multiple places in the project.\n\nWithout this subsystem, it is the developer's responsibility to think\nif the operation might cause some sort of vulnerability to allow\nscript execution. As the system scales, this sort of relaince on the\ndeveloper to think of scenarios will just lead to more of the same\nXSS vulnerability.\n"},{"id":1280,"cve":"CVE-2016-1694","project_name":"chromium","description":"","mistakes":null},{"id":1281,"cve":"CVE-2016-1695","project_name":"chromium","description":"","mistakes":null},{"id":1283,"cve":"CVE-2016-1697","project_name":"chromium","description":"Attackers were able to create javascript code that would escape from a html\nspecific html element known as an iframe, allowing them access a different \npage from an untrusted origin and execute javascript code on the target page.\n","mistakes":"This vulnerability was primarily the result of an oversight in the product\ndesign. Nobody considered how frame navigations could be used to exploit\na weakess in this product. On top of this, since frame navigations were\nnot a necessary function at this point of the execution, a good design\nchoice would have been to have them disabled by default. \nThe suggested mitigation for this type of cross site scripting is minimize\nthe attack surface. Disabling frame navigatons while detatching a frame\ncompletely cuts out the portion of the attack surface that is exploited\nby this vulnerability. The fix completely mitigates this exploit, since \nframe navigations cannot be exploited if they are entirely disabled. \nThis change, however, was only applied to one part of the code. It may be\nworthwhile to review other similar areas of the attack surface and determine\nwhether security by default can be applied to these areas of the code to \nprevent similar exploits from happening in the future.\n"},{"id":1302,"cve":"CVE-2016-2845","project_name":"chromium","description":"The Content Security Policy (CSP) implementation in Blink, as used in Google Chrome before 49.0.2623.75, does not ignore a URLs path component in the case of a ServiceWorker fetch, which allows remote attackers to obtain sensitive information about visited web pages by reading CSP violation reports, related to FrameFetchContext.cpp and ResourceFetcher.cpp.","mistakes":null},{"id":1303,"cve":"CVE-2016-3679","project_name":"chromium","description":"","mistakes":null},{"id":1285,"cve":"CVE-2016-1699","project_name":"chromium","description":"Lack of proper distrustful decomposite design led to the inclusion of a bug, which allowed a client script access to read the contents of a computer's entire filesystem.\nBy design, Chrome DevTools are allowed to run unsafe-eval, and unsafe-inline javascript execution. This shouldn't be an issue, because all trusted dev tools should be hosted at chrome-devtools-frontend.appspot.com/. This url is whitelisted, and only JavaScript code the browser believes came from this source is allowed to run with these typed of permissions. This security model allows DevTools to have more power and freedom than the average web page should be allowed to have, with reasonably little attack surface for exploit vectors to enter through. The omission of proper sanitization of the src attribute attatched to iFrame elements in a page, however, exposed an elevation of privlages vulnerability by executing code that may or may not come from the whitelisted source.","mistakes":null},{"id":1286,"cve":"CVE-2016-1700","project_name":"chromium","description":"During the creation of an array of views for an extension, there is\nnothing that prevents setters from destroying a view in one of the array\nindeces, which triggers unexpected behavior when said destroyed view is\nattempted to be accessed by other parts of the extension and browser.\n","mistakes":"This vulnerability was a simple coding mistake that did not take into\naccount how the deletion of a single member of the array affects the access of\nall data within said array. The fix takes this into account, and runs checks\nto validate the integrity of the data stored.\n"},{"id":1287,"cve":"CVE-2016-1701","project_name":"chromium","description":"","mistakes":null},{"id":1288,"cve":"CVE-2016-1702","project_name":"chromium","description":"","mistakes":null},{"id":1289,"cve":"CVE-2016-1703","project_name":"chromium","description":"","mistakes":null},{"id":1290,"cve":"CVE-2016-1704","project_name":"chromium","description":"","mistakes":null},{"id":1291,"cve":"CVE-2016-1705","project_name":"chromium","description":"","mistakes":null},{"id":1294,"cve":"CVE-2016-1708","project_name":"chromium","description":"The Chrome web store inine-installation implementation in the extensions subsystem does not properly consider object lifetimes during progress observation. This allows for remote attacks to cause a denial of service. Modifications of some system files or information is possible, but the attacker does not have direct control of what can be modified.","mistakes":"In chrome/browser/extensions/tab_helper.cc, CHECK() is frowned upon because it allows for trivial DoS. In chrome/browser/extensions/tab_helper.cc, DCHECK(install_observers_.find(webstore_item_id) == can use install_observers_.count(webstore_item_id) == 0. There wasn't testing added for the new functionality in tab_helper.cc."},{"id":1296,"cve":"CVE-2016-1710","project_name":"chromium","description":"An architectural problem existed in the way Chromium deferred the loading of \npages.  This problem involved pages created by frames on pages that had been\ndeferred not also being deferred.  This made it possible for an attacker to\ncraft and transfer a frame across the deferral boundary (between different\npages), essentially allowing them to inject malicious code across origins \n(sources of data).  This violates the Same-origin Policy.\n \n","mistakes":"This was a design mistake that was simply an oversight where the developers\ndid not consider that an attacker could take advantage of the way they \ndeferred page loads.  They didn't consider the consequences of someone\npotentially bypassing the page deferral code.  This kind of mistake really\ntakes a high level of thinking outside of the norms to catch.  However, if\nthey had been more prudent about validating the origins of all data loaded\ninto these pages, they could have mitigated this vulnerability without\nknowing it was even present to begin with.\n"},{"id":1298,"cve":"CVE-2016-2051","project_name":"chromium","description":"","mistakes":null},{"id":1299,"cve":"CVE-2016-2052","project_name":"chromium","description":"","mistakes":null},{"id":1300,"cve":"CVE-2016-2843","project_name":"chromium","description":"","mistakes":null},{"id":1301,"cve":"CVE-2016-2844","project_name":"chromium","description":"The ability to determine if an anonymous block wrapper existing did not work properly.  This caused a vulnerability that could allow remote attackers to cause a denial of service.\n","mistakes":"The major cause of this vulnerability was that it was the environment. It was working until another section was corrected, and then the automated tests started failing.  Also in the comments it was shown that some people did not understand Layout or had access so it was only one subset of people that could fix this issue.\n"},{"id":1385,"cve":"CVE-2017-15415","project_name":"chromium","description":"Embargoed. Pointer information disclosure in IPC call.\n","mistakes":null},{"id":1386,"cve":"CVE-2017-15416","project_name":"chromium","description":"Embargoed. Out of bounds read in Blink.\n","mistakes":null},{"id":1304,"cve":"CVE-2016-5127","project_name":"chromium","description":"This was a vulnerability that allowed remote attackers to attack Google Chrome \nbefore version 52.0.2743.82 had been released. Remote attackers can cause a \ndenial of service or possibly other problems that are not specified. \n\nThe attacks can be done using JavaScript code. The code involves @import \nat-rule in a CSS token sequence along with a rel=import attribute of a \nLINK element. This just means that the attacker is able to attack the HTML\nfile while the user is trying to import a file. This seems similar to the \nCross-Site Scripting (XSS) vulnerability we discussed in class.\n","mistakes":"This vulnerability was caused due to a lack of design. The developers did not\ndesign the updating of the layout tree appropriately.\n\nCWE-416 is \"Use After Free\" weakness. This is when someone references memory\nafter it has been freed, causing the program to crash. Presumably, the pending\nfiles is the free memory in this scenario. The mitigation to this was to \nset free pointers to null after freeing the pointer. In this situation the \nmain fix was making that intial check previousLinePosition() to not use dangling \nRootInlineBox. This ensures that the memory will no longer be free and vulnerable.\n\nThe developers seem to have done a fairly good job at patching the issue quickly and\neffectively.\n"},{"id":1305,"cve":"CVE-2016-5128","project_name":"chromium","description":"","mistakes":null},{"id":1306,"cve":"CVE-2016-5129","project_name":"chromium","description":"","mistakes":null},{"id":1308,"cve":"CVE-2016-5131","project_name":"chromium","description":"The vulnerabilitywas caused by the implementation of a function that handled the range-to\nfunction in XML. There was code where after memory was freed, it was attempted to be used\nwhich can cause Chrome to crash or freeze. This could be abused to intentionally make Chrome\nunavailable to users or allow for remote code execution.\n","mistakes":"I think that a misunderstanding of what range-to (in the xml markup language) did led to this vulnerability\nsince that what the commit message seems to imply.\n\"range-to is not a real function but a special type of location step which is handled in xpath.c.\"\n"},{"id":1310,"cve":"CVE-2016-5133","project_name":"chromium","description":"This vulnerability comes from lack of foresight during initial development,\nor a misunderstanding of how the process is being used. This vulnerability \nis effectively a way for an attacker to mislead users and obtain their\ncredentials. \n","mistakes":"This vulnerability appears that it came mostly from a requrements error.\nThe initial investigation of transmitting the VPN password as well as how to\nobtain the VPN password, when prompted, should have yielded the information \nconcerning any OS's support (or lack there of at the time). Without this piece\nof information from the beginning of the design process being taken, the \ninformation was not accurate. \n"},{"id":1311,"cve":"CVE-2016-5134","project_name":"chromium","description":"The Proxy Auto-Config (PAC) feature in Google Chrome does not ensure that the\nURL information is restricted to the schema, host and port. This allows remote\nattackers to discover credentials by operating a server with a PAC script.\n","mistakes":"The major mistake which lead to this vulnerability was in the requirements.\nThis is a result of an imporper understanding of the PAC script or the resulting\nvulnerability being overlooked. This could have also been a result of good enough\nprogramming as it was indicated that this is an issue for other browsers as well.\n"},{"id":1312,"cve":"CVE-2016-5135","project_name":"chromium","description":"","mistakes":null},{"id":1313,"cve":"CVE-2016-5136","project_name":"chromium","description":"Referencing memory after it has been freed can lead to a variety of behaviors including crashing and corrupting data. \n\nIn this specific CVE, when an extension is loaded or unloaded by the application, the content\nof these scripts are unregistered. If this happens in the middle of an injection, the freed addresses\nof these unregistered scripts are accessed causing a use after free vulnerability causing a crash. \n","mistakes":"After spending some time reading through the discussions held on the bug as well as looking through a plethora of commits, \nI feel like it was roughly a design mistake that led to the vulnerability. As no code was really deleted, just another variable\nwas added in the file along with some lines to deal with said variable in terms of handling the script.  I also feel that a lot\nof Use After Free vulnerabilities are caused by a combination of coding mistakes and design mistakes. If you don't specifically\ndesign your code or functions to account for it, it is easy to code in a way that leaves room for this vulnerability to happen. \n"},{"id":1314,"cve":"CVE-2016-5137","project_name":"chromium","description":"WebKit's schemeMatches function in the Content Security Policy does not apply\nhttp port 80 policies to https port 443 URLs and does not apply WebSocket (ws) \nport 80 policies to WebSocketSecure (wss) port 443 URLs. \n\nA Content Security Policy is a security measure that can be added to a site \nto restrict what resources can be loaded in the browser. When the\nschemeMatches function does not treat image resources identically through \neach protocol, an attacker can set a Content Security Policy that restricts\nimages from http and ws protocols. When an attacker does this they can monitor\nthe response time for the resources and determine if the user has visited \nthe image's domain previously (if the response time is quick, then the image\nis cached). This is sniffing browser history.\n","mistakes":"This is a coding mistake.\n\nThe Chromium developers defined the proper requirements and design, \nwhich is apparent through their mitigation efforts, but they missed the \nspecific cases when dealing with explicitly defined port numbers.\n"},{"id":1315,"cve":"CVE-2016-5138","project_name":"chromium","description":"","mistakes":null},{"id":1316,"cve":"CVE-2016-5139","project_name":"chromium","description":"A heap buffer overflow vulnerability is present in the jpeg2000. In this vulnerability\nmemory that is dynamically allocated has been been used passed its bounds.\n","mistakes":"It was a simple mistake where buffer sizes were not calculated correctly in PDFium"},{"id":1317,"cve":"CVE-2016-5140","project_name":"chromium","description":"","mistakes":null},{"id":1318,"cve":"CVE-2016-5141","project_name":"chromium","description":"","mistakes":null},{"id":1321,"cve":"CVE-2016-5144","project_name":"chromium","description":"There is a vulnerability with Chrome DevTools. Previously, when a url was \npassed in to a function and the function attempted to sanitize the url,\nthe sanitization algorithm was insufficient. This allowed attackers to bypass\naccess restrictions and inject arbitrary HTML tags into the page. The bug allowed\nchrome extensions such as Google Tone to be used to execute Cross-Site Scripting attacks\nthrough the 'chrome-devtool://' URLs.\n","mistakes":"The coding mistake was a failure to properly sanitize inputs. The VCC author\ndidn't think about different inputs when he wrote his sanitization functions.\n\nThe vulnerability was introduced in two commits by the same author. He wrote a\nsanitization function, but all that it check was that the url had a certain prefix.\nHe failed to realise that HTML tags could be injected into the site because\nthe input was not whitelisted. This essentially allowed malicious javascript code\nto be inserted on a user's page through the url (XSS). He should have thought\nmore about potential url inputs.\n"},{"id":1387,"cve":"CVE-2017-15417","project_name":"chromium","description":"Embargoed. Cross origin information disclosure in Skia.\n","mistakes":null},{"id":1323,"cve":"CVE-2016-5146","project_name":"chromium","description":"","mistakes":null},{"id":1324,"cve":"CVE-2016-5147","project_name":"chromium","description":"CVE-2016-5147, or known as Blink, is an attack that uses deferred page loadings to inject web scripts or malicious HTML.","mistakes":null},{"id":1327,"cve":"CVE-2016-5150","project_name":"chromium","description":"Properties are variable attributes of an object. Like color is a property for\nfor a Bird. Properties can also be inherented from their perent class. \nFor example, Bird can inheret properties from the Animal parent class.\n\n\nKey-paths are a way of storing uninvoked references to properties.\nThis means they refer to a property itself rather than to that propertys value. \n\nThe vulnerability was in Google's Javascript Engine, *V8*, in an API \nimplementation written in C. Getters using key-paths were\nnot restricted to inherited properties, allowing getters on prototypes\nto be executed. \n\nThis created a use-after-free vulnerability. Use After Free specifically refers to the \nattempt to access memory after it has been freed, which can cause a program to crash\nin the best case. \nWorst case, since this is a vulnerability in a JavaScript feature, attackers could \nexecute arbitrary code or even enable full remote code execution capabilities.\n","mistakes":"As the bug report is not available, it is not clear whether this was a known issue\nwith the library, or if it was specific to v8's implementation of it.\nIf it were the latter, the mistake causing this vulnerability was improper implementation of 3rd\nparty library, IndexedDB, as the Google developers failed to restrict certain key-path evaluations, \nspecically getter calls made to prototypes. \n\nOn the other hand, if the library unknowingly contained the bug, then IndexedDB would\nbe at fault for not testing all edge cases when it came to their library's security.  \n"},{"id":1328,"cve":"CVE-2016-5151","project_name":"chromium","description":"Certain early builds of the software PDFium for chrome mishandles\ntimers, allowing remote attackers to cause a denial-of-service by trying to reference\nmemory that has already been freed by the system. That or some other unspecified \nissue through the use of a created PDF Document.\n","mistakes":null},{"id":1330,"cve":"CVE-2016-5153","project_name":"chromium","description":"","mistakes":null},{"id":1331,"cve":"CVE-2016-5154","project_name":"chromium","description":"","mistakes":null},{"id":1332,"cve":"CVE-2016-5155","project_name":"chromium","description":"","mistakes":null},{"id":1333,"cve":"CVE-2016-5156","project_name":"chromium","description":"The C++ event binder would fail to add an event matcher to a list\nof filtered events. After failing, the events would still be processed and\nthe missing event would never be run. If the missing event was followed up\nwith another event that required memory to be freed by the previous event, the\nnext event in the sequence would never be run. The event now waiting for\nmemory to be freed would cause a denial of service as it is just sitting\nthere waiting indefinitely.\n","mistakes":"There was a coding mistake made because it was assumed events would\nalways be matched properly. Due to event matchers occasionally not linking\nproperly to events, this unexpected and unhandled edge case stopped the\nsystem. If there were some kind of check for this linking to begin with,\nthe code would have failed securely and this vulnerability would not have\nhappened.\n"},{"id":1388,"cve":"CVE-2017-15418","project_name":"chromium","description":"Embargoed. Use of uninitialized value in Skia.\n","mistakes":null},{"id":1389,"cve":"CVE-2017-15419","project_name":"chromium","description":"Embargoed. Cross origin leak of redirect URL in Blink.\n","mistakes":null},{"id":1390,"cve":"CVE-2017-15420","project_name":"chromium","description":"Embargoed. URL spoofing in Omnibox.\n","mistakes":null},{"id":1391,"cve":"CVE-2017-15422","project_name":"chromium","description":"Embargoed. Integer overflow in ICU.\n","mistakes":null},{"id":1392,"cve":"CVE-2017-15423","project_name":"chromium","description":"Embargoed. Issue with SPAKE implementation in BoringSSL.\n","mistakes":null},{"id":1393,"cve":"CVE-2017-15424","project_name":"chromium","description":"Embargoed. URL Spoof in Omnibox.\n","mistakes":null},{"id":1394,"cve":"CVE-2017-15425","project_name":"chromium","description":"Embargoed. URL Spoof in Omnibox.\n","mistakes":null},{"id":1335,"cve":"CVE-2016-5158","project_name":"chromium","description":"In two places int overflows can occur, PDFium and OpenJPEG. The int overflow can be targeted to cause a denial of service this is done thorough a heap-based buffer overflow. Also this could have unspecified impact on JPEG data","mistakes":"The mistake really seemed to be that a manual change had to be made in Chromium so that a diffrent software peice that relayed on was updated this seemed like a easy to automate fix that would prevent this from happening"},{"id":1336,"cve":"CVE-2016-5159","project_name":"chromium","description":"","mistakes":null},{"id":1337,"cve":"CVE-2016-5160","project_name":"chromium","description":"The vulnerability was in Chrome's extensions utility. Every extension has\na manifest.json file, which holds a 'web_accessible_resources' field.\nThis field states every internal resource of the extension that can be accessed via\nthe web.\nThe system would allow a user to open an iframe to the settings page of the extension. Attackers could use this vulnerability to trick users into changing the settings of extensions.\n","mistakes":"The mistake here was not a coding one, but a design/requirements one. The\ncorrect behavior of the extension functionality needed to be revised, so the\nfix involved removing old code and writing new code to match the new\nrequirements. Interestingly, we did not find any records of the requirements\n"},{"id":1339,"cve":"CVE-2016-5162","project_name":"chromium","description":"","mistakes":null},{"id":1340,"cve":"CVE-2016-5163","project_name":"chromium","description":"While English and many other languages are processed from left-to-right (LTR), other languages (like Arabic and Hebrew) are processed from right-to-left (RTL).  Unicode supports characters from both classifications.  Strings made up of both LTR and RTL characters must be displayed in a specific order using the bidirectional text (bidi) algorithm.\nIn this vulnerability, on Chrome for Android, when a user entered a URL into the address bar, if the first strong character (A character with a clear direction, either LTR or RTL.  Usually an alphabetic character) in the URL is RTL, an attacker could construct a URL that was displayed in reverse, introducing address bar spoofing by constructing URLs that appear to be visiting one domain but are actually visiting some malicious site.\nFor example, in the URL 127.0.0.1//http://example.com , the first strong character from LTR is .  This character causes the neutral characters (numbers and punctuation) preceding it to take on the RTL direction, while http://example.com remains LTR.  As a result, the URL is displayed as http://example.com//127.0.0.1, with the LTR segment appearing before the RTL segment.\nThe displayed URL is an example of address bar spoofing because it leads the user to believe they are visiting example.com, when they are actually navigating to localhost.  This vulnerability was found in Omnibox, which is responsible for things like URL auto-complete, instant search, and search suggestions.","mistakes":"It was nearly impossible to find the source of this vulnerability because the introduction of the UrlBar\nand SuggestionView Omnibox code into this repo was buried so deep within a 1000+-file commit.  While\nthis may not have contributed to the vulnerability, the developers should consider breaking up future refactoring\nefforts across multiple, smaller commits to improve traceability.\n\nWhile the team clearly considered issues of bidirectional text in the code, this vulnerability seems to have\nslipped by them.  Therefore, I would classify this as a coding mistake, as support for bidi seems to have\nalready been a part of the requirements and design.  The fix seems proper; the developer specifically chose to \nforce LTR as the solution in order to align with the behavior of similar modules in the system.\n"},{"id":1341,"cve":"CVE-2016-5164","project_name":"chromium","description":"","mistakes":null},{"id":1344,"cve":"CVE-2016-5167","project_name":"chromium","description":"","mistakes":null},{"id":1345,"cve":"CVE-2016-5170","project_name":"chromium","description":"","mistakes":null},{"id":1347,"cve":"CVE-2016-5172","project_name":"chromium","description":"","mistakes":null},{"id":1395,"cve":"CVE-2017-15426","project_name":"chromium","description":"Embargoed. URL Spoof in Omnibox.\n","mistakes":null},{"id":1396,"cve":"CVE-2017-15427","project_name":"chromium","description":"Embargoed. Insufficient blocking of JavaScript in Omnibox.\n","mistakes":null},{"id":1397,"cve":"CVE-2017-15428","project_name":"chromium","description":"Embargoed. Out of bounds read in V8.\n","mistakes":null},{"id":1398,"cve":"CVE-2017-15429","project_name":"chromium","description":"Embargoed. UXSS in V8.\n","mistakes":null},{"id":1399,"cve":"CVE-2017-5029","project_name":"chromium","description":"Integer overflow in libxslt. With a xslt file which generates big text nodes\nit is possible to trigger an integer overflow in xsltAddTextString in\ntransform.c of the libxslt library. The function handles the memory management\nif new data are added to a text node. The vulnerability exists because there\nis no check for overflow while calculating a new size of a buffer to hold the\ndata of a text node. The issue can be exploited to trigger an out of bounds\nwrite.\n","mistakes":null},{"id":1350,"cve":"CVE-2016-5175","project_name":"chromium","description":"","mistakes":null},{"id":1351,"cve":"CVE-2016-5176","project_name":"chromium","description":"","mistakes":null},{"id":1352,"cve":"CVE-2016-7152","project_name":"chromium","description":"","mistakes":null},{"id":1353,"cve":"CVE-2016-7153","project_name":"chromium","description":"","mistakes":null},{"id":1355,"cve":"CVE-2016-7549","project_name":"chromium","description":"The reciever of an IPC message was never validated, meaning the messages could\nbe sent out to null, invalid or 'dead' processes. This created an opportunity\nfor denial of service attacks as well as an opening for arbitrary code execution.\n","mistakes":"This vulnerability stemmed from design flaw that assumed object state.\nThe reason for this design flaw can be summed up by a comment from one of\nthe developers.\n\n  'I see This frame being destroyed then sent a message,\n  I thought that should never happen'.\n\nThis type of assuming will lead to oversights and design flaws\nsuch as this one. The mitigation for the CWE is 'Use Static analysis tools\nto check for unreleased resources'. This sums this fix introduced for this\nvulnerability, checking the state of the object instead of assuming it.\n"},{"id":1356,"cve":"CVE-2017-0561","project_name":"chromium","description":"Embargoed. Broadcom WiFi SoC remote kernel code.\n","mistakes":null},{"id":1357,"cve":"CVE-2017-15386","project_name":"chromium","description":"Embargoed. UI spoofing in Blink.\n","mistakes":null},{"id":1358,"cve":"CVE-2017-15387","project_name":"chromium","description":"Embargoed. Content security bypass.\n","mistakes":null},{"id":1359,"cve":"CVE-2017-15388","project_name":"chromium","description":"Embargoed. Out of bounds read in Skia.\n","mistakes":null},{"id":1360,"cve":"CVE-2017-15389","project_name":"chromium","description":"Embargoed. URL Spoofing in Omnibox.\n","mistakes":null},{"id":1361,"cve":"CVE-2017-15390","project_name":"chromium","description":"Embargoed. URL Spoofing in Omnibox.\n","mistakes":null},{"id":1362,"cve":"CVE-2017-15391","project_name":"chromium","description":"Embargoed. Extension limitation bypass in Extensions.\n","mistakes":null},{"id":1363,"cve":"CVE-2017-15392","project_name":"chromium","description":"Embargoed. Incorrect registry key handling in PlatformIntegration.\n","mistakes":null},{"id":1364,"cve":"CVE-2017-15393","project_name":"chromium","description":"Embargoed. Referrer leak in Devtools.\n","mistakes":null},{"id":1366,"cve":"CVE-2017-15395","project_name":"chromium","description":"Embargoed. Null pointer dereference in ImageCapture.\n","mistakes":null},{"id":1367,"cve":"CVE-2017-15396","project_name":"chromium","description":"Embargoed. Stack overflow in V8.\n","mistakes":null},{"id":1368,"cve":"CVE-2017-15397","project_name":"chromium","description":"Embargoed. Use of plaintext network protocols in ChromeVox.\n","mistakes":null},{"id":1369,"cve":"CVE-2017-15398","project_name":"chromium","description":"Embargoed. Stack buffer overflow in QUIC.\n","mistakes":null},{"id":1370,"cve":"CVE-2017-15399","project_name":"chromium","description":"Embargoed. Use after free in V8.\n","mistakes":null},{"id":1371,"cve":"CVE-2017-15400","project_name":"chromium","description":"Embargoed. CRLF and code injection in printer zeroconfig.\n","mistakes":null},{"id":1372,"cve":"CVE-2017-15401","project_name":"chromium","description":"Embargoed. Out of bounds memory access in V8.\n","mistakes":null},{"id":1373,"cve":"CVE-2017-15402","project_name":"chromium","description":"Embargoed. Privilege escalation in PageState.\n","mistakes":null},{"id":1374,"cve":"CVE-2017-15403","project_name":"chromium","description":"Command injection in network_diag.\n","mistakes":null},{"id":1375,"cve":"CVE-2017-15404","project_name":"chromium","description":"Symlink traversal in crash_reporter. The crash handler for non-chrome\nprocesses copies files to /tmp/crash_reporter/\u003ccrashed pid\u003e/ as root.\n","mistakes":null},{"id":1377,"cve":"CVE-2017-15406","project_name":"chromium","description":"Embargoed. Stack overflow in V8.\n","mistakes":null},{"id":1378,"cve":"CVE-2017-15407.yml","project_name":"chromium","description":"Embargoed. Out of bounds write in QUIC.\n","mistakes":null},{"id":1379,"cve":"CVE-2017-15408","project_name":"chromium","description":"Embargoed. Heap buffer overflow in PDFium.\n","mistakes":null},{"id":1380,"cve":"CVE-2017-15409","project_name":"chromium","description":"Embargoed. Out of bounds write in Skia.\n","mistakes":null},{"id":1381,"cve":"CVE-2017-15410","project_name":"chromium","description":"Embargoed. Use after free in PDFium.","mistakes":null},{"id":1382,"cve":"CVE-2017-15411","project_name":"chromium","description":"Embargoed. Use after free in PDFium.\n","mistakes":null},{"id":1383,"cve":"CVE-2017-15412","project_name":"chromium","description":"Embargoed. Use after free in libXML.\n","mistakes":null},{"id":1384,"cve":"CVE-2017-15413","project_name":"chromium","description":"Embargoed. Type confusion in WebAssembly.\n","mistakes":null},{"id":1403,"cve":"CVE-2017-5033","project_name":"chromium","description":"Bypass of Content Security Policy in Blink. By loading a new document using\nwindow.open(\"\",\"_blank\") and document.write-ing into it, (being in\nabout:blank), you can circumvent the CSP restrictions put on the document\nyour js code was running on and reach out to other sites.\n","mistakes":null},{"id":1404,"cve":"CVE-2017-5034","project_name":"chromium","description":"Use after free in PDFium.\n","mistakes":null},{"id":1405,"cve":"CVE-2017-5035","project_name":"chromium","description":"Incorrect security UI in Omnibox.\n","mistakes":null},{"id":1406,"cve":"CVE-2017-5036","project_name":"chromium","description":"Embargoed. Use after free in PDFium.\n","mistakes":null},{"id":1407,"cve":"CVE-2017-5037","project_name":"chromium","description":"Multiple out of bounds writes in ChunkDemuxer.\n","mistakes":null},{"id":1409,"cve":"CVE-2017-5039","project_name":"chromium","description":"Use after free in PDFium.\n","mistakes":null},{"id":1410,"cve":"CVE-2017-5040","project_name":"chromium","description":"Information disclosure in V8.\n","mistakes":null},{"id":1411,"cve":"CVE-2017-5041","project_name":"chromium","description":"Address spoofing in Omnibox. When a \"Confirm Form Resubmission\" box appears\nand the Form submission is sent to another web site, the location bar shows\nthe URL and the SSL indicator of website targeted but the content of the\nprevious webpage continues to be shown.\n","mistakes":null},{"id":1412,"cve":"CVE-2017-5042","project_name":"chromium","description":"Incorrect handling of cookies in Cast. When a user starts the browser, it\nimmediately sends a UDP multicast SSDP request to 239.255.255.250:1900. The\npurpose of this request is to gather info from other local network devices\nthat Chrome could later use for screen casting. The problem is that the effect\nof this functionality is that the browser asks the network to suggest a set of\nURLs that it should run HTTP GET requests on at startup. Then it runs the\nrequests, all without any user interaction or awareness.\n","mistakes":null},{"id":1413,"cve":"CVE-2017-5043","project_name":"chromium","description":"Embargoed. Use after free in GuestView.\n","mistakes":null},{"id":1414,"cve":"CVE-2017-5044","project_name":"chromium","description":"Heap overflow in Skia.\n","mistakes":null},{"id":1415,"cve":"CVE-2017-5045","project_name":"chromium","description":"Information disclosure in XSS Auditor. Attackers can exploit the XSS Auditor's\nblocking mode in leaking information of any webpage from a different origin.\n","mistakes":null},{"id":1416,"cve":"CVE-2017-5046","project_name":"chromium","description":"Information disclosure in Blink.\n","mistakes":null},{"id":1417,"cve":"CVE-2017-5052","project_name":"chromium","description":"Bad cast in Blink.\n","mistakes":null},{"id":1418,"cve":"CVE-2017-5053","project_name":"chromium","description":"Out of bounds memory access in V8.\n","mistakes":null},{"id":1419,"cve":"CVE-2017-5054","project_name":"chromium","description":"Heap buffer overflow in V8.\n","mistakes":null},{"id":1420,"cve":"CVE-2017-5055","project_name":"chromium","description":"Use after free in printing. When the cross process navigation occurs, the\nonunload event of the iframe calls print() and\nPrintPreviewHandler::HandleGetPreview is called and manipulates freed memory.\n","mistakes":"PrintPreviewDone() got called multiple times and failed its internal state DCHeck(). These mistakes were found after the team created unit tests for the fix."},{"id":1421,"cve":"CVE-2017-5056","project_name":"chromium","description":"Embargoed. Use after free in Blink.\n","mistakes":null},{"id":1422,"cve":"CVE-2017-5057","project_name":"chromium","description":"Type confusion in PDFium.\n","mistakes":null},{"id":1423,"cve":"CVE-2017-5058","project_name":"chromium","description":"Heap use after free in Print Preview.\n","mistakes":null},{"id":1424,"cve":"CVE-2017-5059","project_name":"chromium","description":"Type confusion in Blink.\n","mistakes":null},{"id":1426,"cve":"CVE-2017-5061","project_name":"chromium","description":"URL spoofing in Omnibox.\n","mistakes":null},{"id":1427,"cve":"CVE-2017-5062","project_name":"chromium","description":"Embargoed. Use after free in Chrome Apps.\n","mistakes":null},{"id":1428,"cve":"CVE-2017-5063","project_name":"chromium","description":"Heap overflow in Skia.\n","mistakes":null},{"id":1429,"cve":"CVE-2017-5064","project_name":"chromium","description":"Use after free in Blink. Under certain conditions, setting the z-index of an\nanimated node during its animation (with -webkit-animation) then removing this\nnode from DOM before the end of the animation will cause this crash.\n","mistakes":null},{"id":1431,"cve":"CVE-2017-5066","project_name":"chromium","description":"Incorrect signature handing in Networking. As for a certificate, when the\ndeclared signature algorithm identifier (e.g. Sha1WithRSAEncryption) is\ndifferent from the actually used signature algorightm identifier (e.g.\nSha256WithRSAEncryption), the certificate should be rejected. However, Chrome\naccepts such a certificate without any warning.\n","mistakes":null},{"id":1432,"cve":"CVE-2017-5067","project_name":"chromium","description":"URL spoofing in Omnibox.\n","mistakes":null},{"id":1433,"cve":"CVE-2017-5068","project_name":"chromium","description":"Race condition in WebRTC. When a new iframe is inserted, the order of frames\non the page becomes ambiguous.\n","mistakes":null},{"id":1434,"cve":"CVE-2017-5069","project_name":"chromium","description":"Cross-origin bypass in Blink. By setting up a header of \"X-XSS-Protection: 1;\nreport=cross-domain-uri\" it is possible to send cross-origin post request with\ncontent-type value of \"application/json\". Any request containing content-type\nof \"application/json\" should trigger a pre-flight request - but this is not\nhappening. Imagine a situation where an application isn't expecting any\nparameters for an endpoint of https://app.com/user/1000/delete for a POST\nrequest and the only CSRF-Protection is based on CORS - this would bypass this\nrestriction.\n","mistakes":null},{"id":1437,"cve":"CVE-2017-5072","project_name":"chromium","description":"Address spoofing in Omnibox. The URL bar is the only reliable security\nindicator in browsers and if the only reliable security indicator could be\ncontrolled by an attacker it could carry adverse affects. For instance\npotentially tricking users into supplying sensitive information to a malicious\nwebsite due to the fact that it could easily lead the users to believe that\nthey are visiting is legitimate website as the address bar points to the\ncorrect website.\n","mistakes":null},{"id":1438,"cve":"CVE-2017-5073","project_name":"chromium","description":"Use after free in print preview.\n","mistakes":null},{"id":1439,"cve":"CVE-2017-5074","project_name":"chromium","description":"Embargoed. Use after free in Apps Bluetooth.\n","mistakes":null},{"id":1440,"cve":"CVE-2017-5075","project_name":"chromium","description":"Information leak in CSP reporting. Adding a Content-Security-Policy header\ncontaining a report-uri can lead to the leak of the current URL fragment to\nthe web server, even though it should never be sent. This turns an otherwise\nactive attack (serving an evil JavaScript file to the user to make it leak the\nfragment) into a passive and deferred attack, using a mechanism otherwise made\nto improve the security.\n","mistakes":null},{"id":1441,"cve":"CVE-2017-5076","project_name":"chromium","description":"Address spoofing in Omnibox. \"Canadian Syllabics\" unicode breaks URLs.\n","mistakes":null},{"id":1442,"cve":"CVE-2017-5077","project_name":"chromium","description":"Heap buffer overflow in Skia.\n","mistakes":null},{"id":1443,"cve":"CVE-2017-5078","project_name":"chromium","description":"Possible command injection in mailto handling.\n","mistakes":null},{"id":1444,"cve":"CVE-2017-5079","project_name":"chromium","description":"UI spoofing in Blink. Usually, window.open() deactivates the origin window\nand validation bubble on the origin window is closed. However, if\nwindow.print() is executed, it suspends message loop of the window, and\ndeactivation isn't noticed until print dialog is closed.\n","mistakes":null},{"id":1445,"cve":"CVE-2017-5080","project_name":"chromium","description":"Use after free in credit card autofill. Duplicate instances of SaveCardBubble\nfail to get cleaned up.\n","mistakes":null},{"id":1446,"cve":"CVE-2017-5081","project_name":"chromium","description":"Extension verification bypass. There is an approach to bypass extension's\ncontent verification mechanism in Chromium-based browsers. This approach is\nused by malware / adware writers and there are malicious extensions droppers,\nwhich use this mechanism ITW. The nutshell of the bug is a lack of\nverification in extensions locale folder. So, it's possible to create\nextension, which consists of only content script, for example, and this\nscript is located in _locales folder.\n","mistakes":null},{"id":1448,"cve":"CVE-2017-5083","project_name":"chromium","description":"UI spoofing in Blink.\n","mistakes":null},{"id":1449,"cve":"CVE-2017-5084","project_name":"chromium","description":"Local access to local files via dbus.\n","mistakes":null},{"id":1450,"cve":"CVE-2017-5085","project_name":"chromium","description":"Inappropriate javascript execution on WebUI pages. From a security POV this\ndoesn't seem terribly interesting (the attacker must convince the user to add\na dangerous bookmarklet, navigate to a privileged page, and invoke the\nbookmarklet).\n","mistakes":null},{"id":1451,"cve":"CVE-2017-5086","project_name":"chromium","description":"Address spoofing in Omnibox.\n","mistakes":null},{"id":1452,"cve":"CVE-2017-5087","project_name":"chromium","description":"Sandbox Escape in IndexedDB. When an IndexedDB transaction is created,\nindexed_db_connection.cc stores a map from transaction id to a unique_ptr\ncontaining the IndexedDBTransaction, and schedules some actions with the raw\npointer. A compromised renderer can create a new transaction with the same\nid, leading to UaF when one of the raw pointers is accessed.\n","mistakes":null},{"id":1453,"cve":"CVE-2017-5088","project_name":"chromium","description":"Out of bounds read in V8: v8::wasm::module-decoder. This discloses sensitive\ninformation in the heap.\n","mistakes":null},{"id":1454,"cve":"CVE-2017-5089","project_name":"chromium","description":"Domain spoofing in Omnibox. The character \"U+0F8C\" when used in a domain name\nin Chrome looks just like a space. This can be abused to spoof a legitimate\ndomain followed by a chain of the character. This is a Mac OS-specific\nvulnerability.\n","mistakes":null},{"id":1455,"cve":"CVE-2017-5091","project_name":"chromium","description":"Use after free in IndexedDB. In normal scenarios, a cursor is created and\npassed off to a callback function, however, if there are no callbacks, the\ncursor gets destructed, but the pointer to it remains within the system.\n","mistakes":null},{"id":1456,"cve":"CVE-2017-5092","project_name":"chromium","description":"Use after free in PPAPI. The sandbox process sends an IPC message to the\nbrowser, but the browser is unable to verify its authenticity. This results\nin the browser reading uninitialized memory from the heap and crashing.\n","mistakes":null},{"id":1458,"cve":"CVE-2017-5094","project_name":"chromium","description":"Embargoed. Type confusion in extensions.\n","mistakes":null},{"id":1459,"cve":"CVE-2017-5095","project_name":"chromium","description":"Out-of-bounds write in PDFium.\n","mistakes":null},{"id":1460,"cve":"CVE-2017-5096","project_name":"chromium","description":"User information leak via Android intents. URL can be used to navigate from\nHTTP to FILE.\n(i.e. \"googlechrome://navigate?url=file:///sdcard/Download/a.html\")\n","mistakes":null},{"id":1461,"cve":"CVE-2017-5097","project_name":"chromium","description":"Out-of-bounds read in Skia.\n","mistakes":null},{"id":1462,"cve":"CVE-2017-5098","project_name":"chromium","description":"Use after free in V8.\n","mistakes":null},{"id":1463,"cve":"CVE-2017-5099","project_name":"chromium","description":"Out-of-bounds write in PPAPI. When the sandbox process fails to verify the\nauthenticity of a message, fake data can be inserted, resulting in elevation\nof privilege.\n","mistakes":null},{"id":1465,"cve":"CVE-2017-5101","project_name":"chromium","description":"URL spoofing in OmniBox. By changing the location hash and calling a modal\ndialog at the same time a user focuses on the omnibox it's possible to spoof\nthe URL and the HTTPS lock. After the spoof, if the user tries to interact\nwith the webpage the URL will return to normal, but this can be circumvented\nby putting the user in fullscreen after his first click.\n","mistakes":null},{"id":1466,"cve":"CVE-2017-5102","project_name":"chromium","description":"Uninitialized use in Skia. Uninitialized value was created by an allocation\nof \"color\" in the stack frame of the \"ReadBuffer\" function.\n","mistakes":null},{"id":1467,"cve":"CVE-2017-5103","project_name":"chromium","description":"Uninitialized use in Skia. Uninitialized value was created by an allocation\nof \"src\" in the stack frame of the \"ReadBuffer\" function.\n","mistakes":null},{"id":1468,"cve":"CVE-2017-5104","project_name":"chromium","description":"UI spoofing in browser. Secure/Not Secure label next to URL could be spoofed\non Mac OS.\n","mistakes":null},{"id":1469,"cve":"CVE-2017-5105","project_name":"chromium","description":"URL spoofing in OmniBox. Spoofing occurs when inserting \"U+0650\" into\nthe URL.\n","mistakes":null},{"id":1470,"cve":"CVE-2017-5106","project_name":"chromium","description":"URL spoofing in OmniBox. Similar to CVE-2017-5105, spoofing occurs when\ninserting Cyrillic characters into a URL.\n","mistakes":null},{"id":1472,"cve":"CVE-2017-5108","project_name":"chromium","description":"Type confusion in PDFium.\n","mistakes":null},{"id":1474,"cve":"CVE-2017-5110","project_name":"chromium","description":"UI spoofing in payments dialog. PaymentRequestAPI shows the native payment UI.\nAn attacker can change the origin of payment from this screen. Basically, you can\nspoof the payment screen so that it changes where the payment screen comes from.\nThis allows an abuser to use the spoofing to change the what is being paid out and to where.\n","mistakes":"The main mistake here was not realizing that their data has a vulnerable layer\nor a layer that could be removed and replaced interchangeablely with a malicious surface.\nThe possibility for interchangeable parts here is what allowed the system to have this spoofing problem,\nhowever that doesn't make the inherent software design wrong,\nbut instead it means that the software design should have considered the\nfact that there may have been a need to swap that layer out in the future,\nand the security aspect of it should have been considered in the architecture choosing-phase.\n"},{"id":1475,"cve":"CVE-2017-5111","project_name":"chromium","description":"Embargoed. Use after free in PDFium.\n","mistakes":null},{"id":1476,"cve":"CVE-2017-5112","project_name":"chromium","description":"Embargoed. Heap buffer overflow in WebGL.\n","mistakes":null},{"id":1477,"cve":"CVE-2017-5113","project_name":"chromium","description":"Embargoed. Heap buffer overflow in Skia.\n","mistakes":null},{"id":1478,"cve":"CVE-2017-5114","project_name":"chromium","description":"Embargoed. Memory lifecycle issue in PDFium.\n","mistakes":null},{"id":1479,"cve":"CVE-2017-5115","project_name":"chromium","description":"Embargoed. Type confusion in V8.\n","mistakes":null},{"id":1480,"cve":"CVE-2017-5116","project_name":"chromium","description":"Embargoed. Type confusion in V8.\n","mistakes":null},{"id":1481,"cve":"CVE-2017-5117","project_name":"chromium","description":"Embargoed. Use of uninitialized value in Skia.\n","mistakes":null},{"id":1482,"cve":"CVE-2017-5118","project_name":"chromium","description":"Embargoed. Bypass of Content Security Policy in Blink.\n","mistakes":null},{"id":1483,"cve":"CVE-2017-5119","project_name":"chromium","description":"Embargoed. Use of uninitialized value in Skia.\n","mistakes":null},{"id":1484,"cve":"CVE-2017-5120","project_name":"chromium","description":"Embargoed. Potential HTTPS downgrade during redirect navigation.\n","mistakes":null},{"id":1485,"cve":"CVE-2017-5121","project_name":"chromium","description":"Embargoed. Out-of-bounds access in V8.\n","mistakes":null},{"id":1486,"cve":"CVE-2017-5122","project_name":"chromium","description":"Embargoed. Out-of-bounds access in V8.\n","mistakes":null},{"id":1487,"cve":"CVE-2017-5124","project_name":"chromium","description":"Embargoed. UXSS with MHTML.\n","mistakes":null},{"id":1488,"cve":"CVE-2017-5125","project_name":"chromium","description":"Embargoed. Heap overflow in Skia.\n","mistakes":null},{"id":1489,"cve":"CVE-2017-5126","project_name":"chromium","description":"Embargoed. Use after free in PDFium.\n","mistakes":null},{"id":1490,"cve":"CVE-2017-5127","project_name":"chromium","description":"Embargoed. Use after free in PDFium.\n","mistakes":null},{"id":1491,"cve":"CVE-2017-5128","project_name":"chromium","description":"Embargoed. Heap overflow in WebGL.\n","mistakes":null},{"id":1492,"cve":"CVE-2017-5129","project_name":"chromium","description":"Embargoed. Use after free in WebAudio.\n","mistakes":null},{"id":1493,"cve":"CVE-2017-5130","project_name":"chromium","description":"Embargoed. Heap overflow in libxml2.\n","mistakes":null},{"id":1494,"cve":"CVE-2017-5131","project_name":"chromium","description":"Embargoed. Out of bounds write in Skia.\n","mistakes":null},{"id":1495,"cve":"CVE-2017-5132","project_name":"chromium","description":"Embargoed. Incorrect stack manipulation in WebAssembly.\n","mistakes":null},{"id":1496,"cve":"CVE-2017-5133","project_name":"chromium","description":"Embargoed. Out of bounds write in Skia.\n","mistakes":null},{"id":1497,"cve":"CVE-2017-6991","project_name":"chromium","description":"Embargoed. Pointer disclosure in SQLite.\n","mistakes":null},{"id":1,"cve":"CVE-2008-4340","project_name":"chromium","description":"","mistakes":null},{"id":1498,"cve":"CVE-2017-9417","project_name":"chromium","description":"BroadPwn security bug. A bug in Broadcom's WIFI chipsets allows remote access\nto billions of Android and iOS phones.\n","mistakes":""},{"id":2,"cve":"CVE-2008-4724","project_name":"chromium","description":"","mistakes":null},{"id":3,"cve":"CVE-2008-5749","project_name":"chromium","description":"","mistakes":null},{"id":4,"cve":"CVE-2008-5915","project_name":"chromium","description":"","mistakes":null},{"id":5,"cve":"CVE-2008-6994","project_name":"chromium","description":"","mistakes":null},{"id":6,"cve":"CVE-2008-6995","project_name":"chromium","description":"","mistakes":null},{"id":7,"cve":"CVE-2008-6996","project_name":"chromium","description":"","mistakes":null},{"id":8,"cve":"CVE-2008-6997","project_name":"chromium","description":"","mistakes":null},{"id":10,"cve":"CVE-2008-7061","project_name":"chromium","description":"","mistakes":null},{"id":11,"cve":"CVE-2008-7246","project_name":"chromium","description":"","mistakes":null},{"id":12,"cve":"CVE-2008-7294","project_name":"chromium","description":"","mistakes":null},{"id":13,"cve":"CVE-2009-0276","project_name":"chromium","description":"","mistakes":null},{"id":14,"cve":"CVE-2009-0374","project_name":"chromium","description":"","mistakes":null},{"id":15,"cve":"CVE-2009-0411","project_name":"chromium","description":"","mistakes":null},{"id":16,"cve":"CVE-2009-1412","project_name":"chromium","description":"An error related to handling URLs containg a \"chromehtml: protocol\" could allow\nan attacker to run malicious scripts or search files on the local disk. Visiting\nan attacker-controlled web page in Internet Explorer could launch Google Chrome,\nopen multiple tabs, and load scripts that run after navigating to a URL of the\nattacker's choice. This argument injection vulnerabilty allows for universal cross-site\nscripting.\n","mistakes":"This vulnerability seemed to stem from the result of another vulnerabilty not being handled properly.\nThe chromehtml feature seemed to be giving the team problems for months and\nwas ultimately completely removed in the end. This would be easily categorized as\na maintainabilty mistake as the chromehtml feature was not maintainable.\n"},{"id":19,"cve":"CVE-2009-1441","project_name":"chromium","description":"This vulnerability was a heap-based buffer overflow accessible via Google Chrome's IPC messaging. \nThis could allow attackers to malicously access the Bitmap Renderer and cause a denial of service (application crash) \nor possibly execute arbitrary code via vectors related to a large bitmap that arrived over the IPC channel. This means that \narbitrary data inputs were not properly verified and sanitized when data was passed to the Renderer. This overflow could allow \nfor arbitrary execution meaning the attacker could control the system and perform more advanced attacks once they know what inputs\nare controlled by the user and how the system handles input data.\n\nThis vulnerability would only be accessible after an attacker has gained control of the system and jumped here from another \npreviously discovered vulnerability. This is due to the subsystem not being customer-facing, and no actual user input is passed here.\nThe attacker would have to exploit other inputs to the system to utilize this heap overflow, due to IPC messages.\n","mistakes":"There was mainly the input sanitization and verification mistake, this was probably just lazy coding, as that is common.\nThe fix of verifying inputs to methods is being done with the vcc. However there was a flaw with the design of the system as\nthe team later mentioned that the vulnerability would only be possible with the interactions with other systems via IPC messages,\ntherefore they should not have trusted the data given to them to be well formed, as in this case it can lead to vulnerabilities.\n"},{"id":20,"cve":"CVE-2009-1442","project_name":"chromium","description":"","mistakes":null},{"id":21,"cve":"CVE-2009-1514","project_name":"chromium","description":"","mistakes":null},{"id":22,"cve":"CVE-2009-1598","project_name":"chromium","description":"","mistakes":null},{"id":23,"cve":"CVE-2009-1690","project_name":"chromium","description":"","mistakes":null},{"id":25,"cve":"CVE-2009-2071","project_name":"chromium","description":"","mistakes":null},{"id":26,"cve":"CVE-2009-2121","project_name":"chromium","description":"","mistakes":null},{"id":27,"cve":"CVE-2009-2352","project_name":"chromium","description":"","mistakes":null},{"id":28,"cve":"CVE-2009-2555","project_name":"chromium","description":"","mistakes":null},{"id":29,"cve":"CVE-2009-2556","project_name":"chromium","description":"","mistakes":null},{"id":30,"cve":"CVE-2009-2578","project_name":"chromium","description":"","mistakes":null},{"id":31,"cve":"CVE-2009-2816","project_name":"chromium","description":"","mistakes":null},{"id":32,"cve":"CVE-2009-2935","project_name":"chromium","description":"","mistakes":null},{"id":33,"cve":"CVE-2009-2955","project_name":"chromium","description":"","mistakes":null},{"id":34,"cve":"CVE-2009-2973","project_name":"chromium","description":"","mistakes":null},{"id":35,"cve":"CVE-2009-2974","project_name":"chromium","description":"","mistakes":null},{"id":36,"cve":"CVE-2009-3011","project_name":"chromium","description":"","mistakes":null},{"id":37,"cve":"CVE-2009-3263","project_name":"chromium","description":"Cross-site scripting (XSS) vulnerability in Google Chrome 2.x and 3.x before 3.0.195.21 \nallows remote attackers to inject arbitrary web script or HTML via a (1) RSS or (2) Atom feed, \nrelated to the rendering of the application/rss+xml content type as XML \"active content.\"\n","mistakes":null},{"id":38,"cve":"CVE-2009-3264","project_name":"chromium","description":"","mistakes":null},{"id":39,"cve":"CVE-2009-3268","project_name":"chromium","description":"","mistakes":null},{"id":40,"cve":"CVE-2009-3456","project_name":"chromium","description":"","mistakes":null},{"id":41,"cve":"CVE-2009-3931","project_name":"chromium","description":"","mistakes":null},{"id":42,"cve":"CVE-2009-3932","project_name":"chromium","description":"","mistakes":null},{"id":44,"cve":"CVE-2010-0315","project_name":"chromium","description":"","mistakes":null},{"id":45,"cve":"CVE-2010-0556","project_name":"chromium","description":"","mistakes":null},{"id":48,"cve":"CVE-2010-0645","project_name":"chromium","description":"","mistakes":null},{"id":49,"cve":"CVE-2010-0646","project_name":"chromium","description":"","mistakes":null},{"id":50,"cve":"CVE-2010-0647","project_name":"chromium","description":"","mistakes":null},{"id":51,"cve":"CVE-2010-0649","project_name":"chromium","description":"","mistakes":null},{"id":52,"cve":"CVE-2010-0650","project_name":"chromium","description":"","mistakes":null},{"id":53,"cve":"CVE-2010-0651","project_name":"chromium","description":"","mistakes":null},{"id":54,"cve":"CVE-2010-0655","project_name":"chromium","description":"","mistakes":null},{"id":56,"cve":"CVE-2010-0657","project_name":"chromium","description":"","mistakes":null},{"id":57,"cve":"CVE-2010-0658","project_name":"chromium","description":"","mistakes":null},{"id":58,"cve":"CVE-2010-0659","project_name":"chromium","description":"","mistakes":null},{"id":60,"cve":"CVE-2010-0661","project_name":"chromium","description":"","mistakes":null},{"id":62,"cve":"CVE-2010-0663","project_name":"chromium","description":"This vulnerability can be described as a buffer overread, in which an\nattacker can force an array index to read beyond the bounds of the array.\nAn attacker can use this to induce a system crash or to potentially read\nmemory they shouldn't have access to.\nThis vulnerability occurs in chromium's bitmap buffers. The bitmap buffer\nitself and the row size of the bitmap buffer are given\nby two different sources which can fall out of sync, causing the bitmap\nreader to read beyond the contents of the actual buffer (e.g. if the given\nbuffer is small).\n","mistakes":"This problem arose from the fact that certain properties of the data\nbeing used were derived from different sources of truth. Namely, the\nsize of a bitmap buffer could be calculated from the buffer itself,\nhowever in one instance, a function accepted a parameter which it used as\nit's source of truth for the buffer size. This led to the possibility that\nthe actual size of the buffer could be different than the size given by\nthe parameter, which led to logical inconsistencies. This potentially\nallowed for a buffer overread as well as limited escalation.\n"},{"id":64,"cve":"CVE-2010-1029","project_name":"chromium","description":"","mistakes":null},{"id":65,"cve":"CVE-2010-1228","project_name":"chromium","description":"","mistakes":null},{"id":66,"cve":"CVE-2010-1229","project_name":"chromium","description":"","mistakes":null},{"id":67,"cve":"CVE-2010-1230","project_name":"chromium","description":"","mistakes":null},{"id":105,"cve":"CVE-2010-2298","project_name":"chromium","description":"","mistakes":null},{"id":463,"cve":"CVE-2011-3062","project_name":"chromium","description":"","mistakes":null},{"id":464,"cve":"CVE-2011-3063","project_name":"chromium","description":"","mistakes":null},{"id":465,"cve":"CVE-2011-3064","project_name":"chromium","description":"","mistakes":null},{"id":69,"cve":"CVE-2010-1232","project_name":"chromium","description":"","mistakes":null},{"id":70,"cve":"CVE-2010-1233","project_name":"chromium","description":"","mistakes":null},{"id":71,"cve":"CVE-2010-1234","project_name":"chromium","description":"","mistakes":null},{"id":72,"cve":"CVE-2010-1235","project_name":"chromium","description":"","mistakes":null},{"id":73,"cve":"CVE-2010-1236","project_name":"chromium","description":"","mistakes":null},{"id":74,"cve":"CVE-2010-1237","project_name":"chromium","description":"","mistakes":null},{"id":75,"cve":"CVE-2010-1500","project_name":"chromium","description":"","mistakes":null},{"id":76,"cve":"CVE-2010-1502","project_name":"chromium","description":"Attackers are able to traverse local google files by using vectors related to\n\"developer tools\" in the Chromium Browser.\n","mistakes":"The major coding mistake was that for two years, chromium did not sanitize its url input, allowing for attackers to access local files.\nThe vulnerability was introduced in the initial commit, and was unnoticed by the developers up until it was eventually exploited. Two google employees were asked to review the code for  security vulnerabilities, where they came across it. They ran into some problems fixing it, since the function itself could not be changed without updating more of the system, resulting in a more messy solution.\nThere were no unit tests to check for this vulnerability prior to its fix, prompting developers to add on for future updates and security issues."},{"id":80,"cve":"CVE-2010-1506","project_name":"chromium","description":"","mistakes":null},{"id":81,"cve":"CVE-2010-1663","project_name":"chromium","description":"","mistakes":null},{"id":82,"cve":"CVE-2010-1664","project_name":"chromium","description":"","mistakes":null},{"id":83,"cve":"CVE-2010-1665","project_name":"chromium","description":"","mistakes":null},{"id":84,"cve":"CVE-2010-1731","project_name":"chromium","description":"","mistakes":null},{"id":85,"cve":"CVE-2010-1767","project_name":"chromium","description":"","mistakes":null},{"id":86,"cve":"CVE-2010-1770","project_name":"chromium","description":"","mistakes":null},{"id":87,"cve":"CVE-2010-1772","project_name":"chromium","description":"","mistakes":null},{"id":88,"cve":"CVE-2010-1773","project_name":"chromium","description":"","mistakes":null},{"id":89,"cve":"CVE-2010-1822","project_name":"chromium","description":"","mistakes":null},{"id":90,"cve":"CVE-2010-1823","project_name":"chromium","description":"","mistakes":null},{"id":91,"cve":"CVE-2010-1824","project_name":"chromium","description":"","mistakes":null},{"id":92,"cve":"CVE-2010-1825","project_name":"chromium","description":"","mistakes":null},{"id":93,"cve":"CVE-2010-1851","project_name":"chromium","description":"","mistakes":null},{"id":94,"cve":"CVE-2010-1992","project_name":"chromium","description":"","mistakes":null},{"id":95,"cve":"CVE-2010-2105","project_name":"chromium","description":"","mistakes":null},{"id":96,"cve":"CVE-2010-2106","project_name":"chromium","description":"","mistakes":null},{"id":97,"cve":"CVE-2010-2107","project_name":"chromium","description":"This was an error that caused chromes memory to become corrupted. The issue would occurr when a user attempted to connecto to a site that was marked for malware that no longer existed, clicked continue anyway and then refreshed the page during the long loading time. This would cause memory corruption that could be used to execute code outside of the original memory space.","mistakes":"This seems to have been a coding error. The vulnerability was possible mainly because of an extra check that would enter an error state when a specific method was called twice."},{"id":98,"cve":"CVE-2010-2108","project_name":"chromium","description":"This vulnerability allows remote attackers to bypass the whitelist of\nacceptable plugins. The whitelist is part of the host-based settings. The \nwhitelist works as intended when navigating, because all webpages will have a\nhost. The issue is when a new tab is first created, there is no host and thus\nthe plugin whitelist will not be applied.  \n\nThe fix for this vulnerability was having new windows inherit host-based settings\nfrom the parent.\n","mistakes":"I think a few mistakes went into the creation of the vulnerability. First\nof all, I believe there may have been miscommunication within the team. \nWhen reading the thread detailing the vulnerability, there seemed to be \ndisagreement on whether this was a UI decision. It's possible that when\nthe vulnerability was first introduced, the programmer considered it a \nUI design decision. This can also lead to it being a mistake in the\nrequirements. It's very possible that the default blocking of plugins\nwas not a requirement. This also could be the result of the programmer \nnot understanding the system as a whole. If the programmer did not completely\nunderstand how the creation of a new window works, this vulnerability would\nhave gone unnoticed. Going forward, vulnerabilities like this can be avoided\nwith a couple steps. First, teammates always need to be on the same page when it\ncomes to requirements. Next, if something is unclear in the requirements,\ndevelopers should review it with the team. Finally, developers should also make\nsure that they understand the system they are working in completely before making\nchanges.\n"},{"id":99,"cve":"CVE-2010-2109","project_name":"chromium","description":"","mistakes":null},{"id":100,"cve":"CVE-2010-2110","project_name":"chromium","description":"","mistakes":null},{"id":101,"cve":"CVE-2010-2120","project_name":"chromium","description":"","mistakes":null},{"id":102,"cve":"CVE-2010-2295","project_name":"chromium","description":"","mistakes":null},{"id":103,"cve":"CVE-2010-2296","project_name":"chromium","description":"","mistakes":null},{"id":104,"cve":"CVE-2010-2297","project_name":"chromium","description":"","mistakes":null},{"id":106,"cve":"CVE-2010-2299","project_name":"chromium","description":"There are certain objects that are read in through the DispatchObject()\nfunction as clipboard objects. One of the types of objects that could be\nread through this function, CBF_SMBITMAP to be exact, contains information\nthat points to a shared memory object. If someone who normally does not have\naccess to the shared memory object obtains access, they could potentially\nmodify the object which may affect other processes using it. This dangerous\nprocess is normally okay since there are other methods that make it secure.\nHowever, there was a particular instance where said methods were not used,\nresulting in an unsecure use of the CBF_SMBITMAP object.\n","mistakes":"It seems that the main cause of this issue was a small oversight by the\ndevelopers. The developers could have run through all possible Clipboard\nobjects that are run through the dispatchObject function. If this had been\ndone, they would have realized that one of the objects leads to the\nvulnerability. Likewise, due to the fact that this was likely a minor\noversight by the developers, the vulnerability is also something that should\nhave been able to have been caught by looking at the code review a bit more\nclosely.\n"},{"id":107,"cve":"CVE-2010-2300","project_name":"chromium","description":"","mistakes":null},{"id":108,"cve":"CVE-2010-2301","project_name":"chromium","description":"","mistakes":null},{"id":109,"cve":"CVE-2010-2302","project_name":"chromium","description":"","mistakes":null},{"id":110,"cve":"CVE-2010-2645","project_name":"chromium","description":"","mistakes":null},{"id":111,"cve":"CVE-2010-2646","project_name":"chromium","description":"","mistakes":null},{"id":112,"cve":"CVE-2010-2647","project_name":"chromium","description":"","mistakes":null},{"id":113,"cve":"CVE-2010-2648","project_name":"chromium","description":"","mistakes":null},{"id":114,"cve":"CVE-2010-2649","project_name":"chromium","description":"","mistakes":null},{"id":115,"cve":"CVE-2010-2650","project_name":"chromium","description":"","mistakes":null},{"id":116,"cve":"CVE-2010-2651","project_name":"chromium","description":"","mistakes":null},{"id":117,"cve":"CVE-2010-2652","project_name":"chromium","description":"This vulnerability pertains to the availability of the browser. If it was\nexploited, the chromium web browser would crash. Websites can create and allow \nthe user to view Javascript dialogs. These dialogs can be queued so that another \nmay pop up when one closes. The crash would occur when a dialog that is in the queue \ncloses. In order to do this, multiple tabs must be opened in the browser. If both\npages open a dialog simultaniously it would trigger the vulnerability.\n","mistakes":"This was a design mistake. The initial implementation lacked any checking to \nvalidate that the modals were as expected. The orginal author was most likely not \naware of modal queues when working on the functionality. The CWE doesnt mention any\nobvious ways to mitigate this issue. In this situation, the author should have done more\nresearch on the functionality of dialogs.\n"},{"id":118,"cve":"CVE-2010-2897","project_name":"chromium","description":"","mistakes":null},{"id":120,"cve":"CVE-2010-2899","project_name":"chromium","description":"","mistakes":null},{"id":121,"cve":"CVE-2010-2900","project_name":"chromium","description":"","mistakes":null},{"id":122,"cve":"CVE-2010-2901","project_name":"chromium","description":"","mistakes":null},{"id":123,"cve":"CVE-2010-2902","project_name":"chromium","description":"","mistakes":null},{"id":124,"cve":"CVE-2010-2903","project_name":"chromium","description":"The security information dialog in Chrome incorrectly displayed the hostname.\nIn Windows, the hostname became merged with the following line and in Linux\nit was truncated. This could potentially result in an attacker using a long\nhostname to spoof another website.\n","mistakes":"This bug was due to simply not validating the hostname. An extremely long\nhostname may not have even been considered in the design, however it did\nbecome an issue later.\n\nIt was present in the very begining when the method was written over two\ncommits. As the vulnerability was considered very low severity after\ndiscovery, it was likely just an oversight during design and implementation.\n\nThere was initial disagreement that the issue required a fix at all. It was\nstill considered unlikely that enough \"important\" or frequently used websites\nwith long enough hostnames to allow an exploit existed. After establishing\nthat spoofing was indeed possible, it was filed as low severity.\n"},{"id":125,"cve":"CVE-2010-3111","project_name":"chromium","description":"A workaround was created for a Windows kernel bug that was triggered by hinting malformed fonts. Hinting is the process of rasterizing the vector fonts into bitmaps for specific display resolutions and is only applicable with the Compact Font Format (CFF) since raster information is stored in the TTF format.  \n","mistakes":null},{"id":126,"cve":"CVE-2010-3112","project_name":"chromium","description":"Versions of Chrome prior to 5.0.375.127 do not properly implement file dialogs, allowing attackers to cause denial of service attacks.","mistakes":null},{"id":127,"cve":"CVE-2010-3113","project_name":"chromium","description":"","mistakes":null},{"id":128,"cve":"CVE-2010-3114","project_name":"chromium","description":"","mistakes":null},{"id":129,"cve":"CVE-2010-3115","project_name":"chromium","description":"","mistakes":null},{"id":130,"cve":"CVE-2010-3116","project_name":"chromium","description":"","mistakes":null},{"id":133,"cve":"CVE-2010-3119","project_name":"chromium","description":"","mistakes":null},{"id":134,"cve":"CVE-2010-3120","project_name":"chromium","description":"","mistakes":null},{"id":239,"cve":"CVE-2011-1118","project_name":"chromium","description":"","mistakes":null},{"id":240,"cve":"CVE-2011-1119","project_name":"chromium","description":"","mistakes":null},{"id":466,"cve":"CVE-2011-3065","project_name":"chromium","description":"","mistakes":null},{"id":467,"cve":"CVE-2011-3066","project_name":"chromium","description":"","mistakes":null},{"id":138,"cve":"CVE-2010-3249","project_name":"chromium","description":"","mistakes":null},{"id":142,"cve":"CVE-2010-3253","project_name":"chromium","description":"","mistakes":null},{"id":143,"cve":"CVE-2010-3254","project_name":"chromium","description":"","mistakes":null},{"id":144,"cve":"CVE-2010-3255","project_name":"chromium","description":"","mistakes":null},{"id":146,"cve":"CVE-2010-3257","project_name":"chromium","description":"","mistakes":null},{"id":147,"cve":"CVE-2010-3258","project_name":"chromium","description":"","mistakes":null},{"id":148,"cve":"CVE-2010-3259","project_name":"chromium","description":"","mistakes":null},{"id":149,"cve":"CVE-2010-3412","project_name":"chromium","description":"","mistakes":null},{"id":151,"cve":"CVE-2010-3414","project_name":"chromium","description":"","mistakes":null},{"id":153,"cve":"CVE-2010-3416","project_name":"chromium","description":"","mistakes":null},{"id":154,"cve":"CVE-2010-3417","project_name":"chromium","description":"","mistakes":null},{"id":155,"cve":"CVE-2010-3729","project_name":"chromium","description":"","mistakes":null},{"id":156,"cve":"CVE-2010-3730","project_name":"chromium","description":"","mistakes":null},{"id":157,"cve":"CVE-2010-4008","project_name":"chromium","description":"An invalid memory access flaw was found in libxml2, a library providing\nsupport to read, modify and write XML and HTML files. A remote attacker could\nprovide a specially crafted XML file that, when processed by an application using libxml2,\nwould lead to an read at an invalid memory address, causing an application\ncrash (denial of service).\n read XPath expressions (a method used to navigate through elements and\nattributes in an XML file), an attacker could craft an XML document with\nmalformed XPaths that would cause an application crash.\n\nThis is due to the way libxml2 reads XPath expressions, which are a method t navigate\nthrough elements of an XML file. As libxml2 parses XML, it creates \"contexts\" (looks\nto be similar concept as scope) as it goes through the tree structure. The XPath most likely\ncause a reference to an invalid or null context, resulting in an invalid memory access.\n\nThis could be done by creating an XML file that forces the parser to attempt to\nread from an invalid memory location, leading to a crash. This is the example\ngiven by the reporter of the vulnerability.\n","mistakes":"The mistake that was made was trusting that if an xml node were null/not null that it would\nbe correctly formatted (depending on the situation). Because of this there wasn't an extra\ncheck to ensure that the node contained the correct information in it (i.e. not malicious/malformed).\nThe fix here appears to be proper as it now checks that the xml nodes are of the correct\ntype before returning on them or performing extra checks. Additionally, due to this happening\nwhen an XPath was being processed, additional validation of the nodes should have been performed.\n\nWhile the file involved with the vulnerability had a related test file, this was not discovered\nby testing. Additionally, the related test file was not updated to include specific tests for\nthis vulnerability, which is most likely an oversight by the dev(s) working on it. Possibly adding\na fuzzer for different XPaths or XML structures could have been implemented to help find/prevent\nvulnerabilities like this.\n"},{"id":159,"cve":"CVE-2010-4034","project_name":"chromium","description":"Does not handle form input in a safe manner allowing attackers to crash the application (DoS) due to a stale pointer bug, a programming error during dynamic memory allocation.","mistakes":"At first, it seemed to be a minor coding mistake. The issue was that Chrome needed to check the frame after it created the frame. However, after that was quickly fixed, other engineers pointed out that it was still crashing. This began to label the error as a release blocker. At one point, the engineers were discussing backup plans if the current fix was too risky. The easiest way around the issue was to remove Autofill, but the engineers decided against removing such a useful consumer tool. Eventually, the team found the issues to lie with Webkit. Interestingly, even though they found where the memory leaks happened, one can see that the code in 2018 no onger even uses this form manager."},{"id":162,"cve":"CVE-2010-4037","project_name":"chromium","description":"","mistakes":null},{"id":163,"cve":"CVE-2010-4038","project_name":"chromium","description":"","mistakes":null},{"id":165,"cve":"CVE-2010-4040","project_name":"chromium","description":"","mistakes":null},{"id":166,"cve":"CVE-2010-4041","project_name":"chromium","description":"","mistakes":null},{"id":167,"cve":"CVE-2010-4042","project_name":"chromium","description":"","mistakes":null},{"id":168,"cve":"CVE-2010-4197","project_name":"chromium","description":"","mistakes":null},{"id":169,"cve":"CVE-2010-4198","project_name":"chromium","description":"","mistakes":null},{"id":170,"cve":"CVE-2010-4199","project_name":"chromium","description":"","mistakes":null},{"id":171,"cve":"CVE-2010-4201","project_name":"chromium","description":"","mistakes":null},{"id":172,"cve":"CVE-2010-4202","project_name":"chromium","description":"","mistakes":null},{"id":173,"cve":"CVE-2010-4203","project_name":"chromium","description":"","mistakes":null},{"id":174,"cve":"CVE-2010-4204","project_name":"chromium","description":"","mistakes":null},{"id":175,"cve":"CVE-2010-4205","project_name":"chromium","description":"The vulnerability was in Google Chrome where they did not check the data type\nof an event object returned from a page click.\n\nThe implementation, which was done in C++, didn't properly check if the event\nobject it got back was a mouse event before executing it.  This could result\nin a crash or other unexpected events.\n\nThe way this could be exploited would be if an attacker found out about this\nvulnerability and used it to purposely crash the site.  This could prevent\nother people from accessing the site, also known as denial of service.\n","mistakes":"The vulnerability was a simple oversight where the programmer expected to always get\na mouse event object and did not put a conditional in to make sure that it was one.\n\nEven though it is reasonable to expect to always get a mouse event from a mouse click,\nit is always good to distrust input and checking the input provides defense in depth\nagainst an attacker who purposely injects a different type of object into the function.\n\nThe fix was simply adding a conditional and looks proper for this specific vulnerability,\nbut the developers should keep in mind to always check a returned value's type in other\ncases. Also, writing tests with different types of objects as inputs could help prevent\nfuture similar vulnerabilities in the future.\n"},{"id":176,"cve":"CVE-2010-4206","project_name":"chromium","description":"","mistakes":null},{"id":177,"cve":"CVE-2010-4482","project_name":"chromium","description":"The vulnerability is such that Chrome is able to open a webpage as a pop-up, which can be abused as malicious users will generate unwanted pages by bypassing the pop-up blocker using cross site-scripting (and by extension, cross-origin scripting). Chrome did not check whether the input was generated by an actual user. It is basically an example of improper input validation.\n","mistakes":"The mistake concerned design issues in processing input. The design failed to account for input-checking as to whether the user actually initiated the input or it was inserted as a script. The fix is appropriate as the developers have whitelisted the input."},{"id":178,"cve":"CVE-2010-4483","project_name":"chromium","description":"","mistakes":null},{"id":180,"cve":"CVE-2010-4485","project_name":"chromium","description":"Before 8.0.552.215, Google Chrome has a vulnerability that allows an attacker \nto create an infinite amount of file dialogs that can crash the browser by \nconsuming all available memory. This vulnerability was proven to be present\nthrough a crafted extension \n","mistakes":"Coding and design mistakes are what led to this vulnerability. It\nstarted out with a design mistakes to refactor how untrusted code is \nhandled, and then turned into a coding mistakes when the refactoring exposed\nthe function to content scripts directly to be executed by windows that are \nnot visible, allowing an attacker to create new invisible windows to then \nopen up file chooser dialogs. I believe this fix is a correct balance\nbetween how invasive it is, and how well thought out it is.\n"},{"id":181,"cve":"CVE-2010-4486","project_name":"chromium","description":"","mistakes":null},{"id":184,"cve":"CVE-2010-4489","project_name":"chromium","description":"","mistakes":null},{"id":186,"cve":"CVE-2010-4491","project_name":"chromium","description":"","mistakes":null},{"id":187,"cve":"CVE-2010-4492","project_name":"chromium","description":"","mistakes":null},{"id":188,"cve":"CVE-2010-4493","project_name":"chromium","description":"","mistakes":null},{"id":189,"cve":"CVE-2010-4494","project_name":"chromium","description":"There is a double free vulnerability in libxml2 2.7.8 and other version as used in gogole chrome before 8.0.552.215.\nThe vulnerability allows one to pop an XPath object off the stack, and since the object won't be null, it can be popped again.\nDouble free vulnerability is a common memory corruption error when developers free the same memory location twice by calling free() on the same\n allocated memory. \n\n This vulnerability may allows remote attackers to cause a denial of service or possibly have unspecified other impact relate to the Xpath in this case.\n","mistakes":"Double free vulnerability is a common memory corruption error if the developers don't write a proper check case before they free memory\nIn this case, it seems like a developer simply forgot or was not aware of this. It can also be very hard to catch, as the chromium code base in incredibly large, and can not be easily combed through.\nI believe that the vulnerability was fixed correctly, as they understood the complete problem and fixed it properly. \n"},{"id":193,"cve":"CVE-2010-4577","project_name":"chromium","description":"","mistakes":null},{"id":194,"cve":"CVE-2010-4578","project_name":"chromium","description":"","mistakes":null},{"id":195,"cve":"CVE-2010-5069","project_name":"chromium","description":"","mistakes":null},{"id":196,"cve":"CVE-2010-5073","project_name":"chromium","description":"","mistakes":null},{"id":197,"cve":"CVE-2011-0470","project_name":"chromium","description":"This issue was reported on Oct. 5 2010 by chromium user 'Eroman', and fixed by\nuser 'johnnyg' on Dec. 1 2010\n\nfrom the chromium Notifications subsystem\n\nGoogle chrome did not properly handle an extensions notifications, thus allowing\nremote attackers to cause the application to crash (denial of service) through the\nuse of unspecified vectors.\n","mistakes":"This vulnerability is a result of chrome not properly handling extensions\nnotification, allowing remote attackers to cause a system crash. The root\nof this problem could be found in the notifications subsystem. Generally,\nwhen you have something open in your code, when you finish using it, it is\nimportant to properly collect and close anything that is left. The issue\nthat occured here is that the notification 'balloons' were not properly\ncollected before attempting to close them. This led to a race condition\nthat happened on shut down. The browser would stop all rendering and force\nwindows to close. The code in the notifications subsystem would then detect\nthe renderer being shut down as well, and attempt to close the window a\nsecond time. The fix was introduced by properly collecting all notification\nballoons on shut down, and closing all of those first. This way, there is\nnothing left to try and close the window a second time after the window\nalready shuts down. This looks like a proper fix, and addresses the issue\nat multiple points in the system.\n"},{"id":198,"cve":"CVE-2011-0471","project_name":"chromium","description":"","mistakes":null},{"id":199,"cve":"CVE-2011-0472","project_name":"chromium","description":"","mistakes":null},{"id":200,"cve":"CVE-2011-0473","project_name":"chromium","description":"","mistakes":null},{"id":201,"cve":"CVE-2011-0474","project_name":"chromium","description":"","mistakes":null},{"id":202,"cve":"CVE-2011-0475","project_name":"chromium","description":"","mistakes":null},{"id":203,"cve":"CVE-2011-0476","project_name":"chromium","description":"","mistakes":null},{"id":468,"cve":"CVE-2011-3067","project_name":"chromium","description":"","mistakes":null},{"id":204,"cve":"CVE-2011-0477","project_name":"chromium","description":"Google Chrome before 8.0.552.237 and Chrome OS before 8.0.552.344 do not properly handle a mismatch in video frame sizes, which allows remote attackers to cause a denial of service (incorrect memory access) or possibly have unspecified other impact via unknown vectors. \n","mistakes":"An attacker could provide a webm video that when decoded via FFMPEG, would cause a segmentation fault, causing Chromium to cease running. It seems that the instance of decode_engine_ would be uninitialized under some circumstances, possibly leading to the mismatch in frame sizes. The fix seems to be to always uninitialize the decode_engine_.\n"},{"id":205,"cve":"CVE-2011-0478","project_name":"chromium","description":"","mistakes":null},{"id":206,"cve":"CVE-2011-0479","project_name":"chromium","description":"","mistakes":null},{"id":207,"cve":"CVE-2011-0480","project_name":"chromium","description":"","mistakes":null},{"id":208,"cve":"CVE-2011-0481","project_name":"chromium","description":"","mistakes":null},{"id":209,"cve":"CVE-2011-0482","project_name":"chromium","description":"","mistakes":null},{"id":210,"cve":"CVE-2011-0483","project_name":"chromium","description":"","mistakes":null},{"id":211,"cve":"CVE-2011-0484","project_name":"chromium","description":"","mistakes":null},{"id":214,"cve":"CVE-2011-0777","project_name":"chromium","description":"","mistakes":null},{"id":215,"cve":"CVE-2011-0778","project_name":"chromium","description":"","mistakes":null},{"id":217,"cve":"CVE-2011-0780","project_name":"chromium","description":"","mistakes":null},{"id":218,"cve":"CVE-2011-0781","project_name":"chromium","description":"","mistakes":null},{"id":219,"cve":"CVE-2011-0782","project_name":"chromium","description":"","mistakes":null},{"id":220,"cve":"CVE-2011-0783","project_name":"chromium","description":"Faulty logic for checking volume of audio caused the browser to crash, with\npotential for a large scale attack.\n","mistakes":"An oversight on validating data, that was replicated across functions and files caused\nthe vulnerability. Developers should have considered edge cases and all types of\npotential input to avoid this vulnerability.\n"},{"id":222,"cve":"CVE-2011-0981","project_name":"chromium","description":"","mistakes":null},{"id":223,"cve":"CVE-2011-0982","project_name":"chromium","description":"","mistakes":null},{"id":224,"cve":"CVE-2011-0983","project_name":"chromium","description":"","mistakes":null},{"id":225,"cve":"CVE-2011-0984","project_name":"chromium","description":"","mistakes":null},{"id":226,"cve":"CVE-2011-0985","project_name":"chromium","description":"","mistakes":null},{"id":228,"cve":"CVE-2011-1107","project_name":"chromium","description":"","mistakes":null},{"id":229,"cve":"CVE-2011-1108","project_name":"chromium","description":"A function meant to handle javascript dialog cleanup was not\nproperly implemented and would lead to site crash. This meant\nthat an attacker had the means to invoke a site crash or\ndenial of service attack. The vulnerability also left the application\nopen to arbitrary code execution though no instances were reported.\n","mistakes":"This vulnerability was caused by bad code implementation but also a lack of\ntesting. If unit tests had been put in place, it would have been clear that\nthe function was not working as designed. Since tests were not put in\nplace, the function stayed even after multiple different patches.\nThe CWE chosen is CWE-710, the developers should have followed better\ncoding standards and implemented testing to catch logic/functionality\nerrors such as this.\n"},{"id":230,"cve":"CVE-2011-1109","project_name":"chromium","description":"","mistakes":null},{"id":231,"cve":"CVE-2011-1110","project_name":"chromium","description":"","mistakes":null},{"id":232,"cve":"CVE-2011-1111","project_name":"chromium","description":"","mistakes":null},{"id":235,"cve":"CVE-2011-1114","project_name":"chromium","description":"","mistakes":null},{"id":236,"cve":"CVE-2011-1115","project_name":"chromium","description":"","mistakes":null},{"id":237,"cve":"CVE-2011-1116","project_name":"chromium","description":"","mistakes":null},{"id":238,"cve":"CVE-2011-1117","project_name":"chromium","description":"","mistakes":null},{"id":241,"cve":"CVE-2011-1120","project_name":"chromium","description":"The WebGL implementation in Google Chrome allowed remote attackers to cause a \ndenial of service (out-of-bounds read) via unspecified vectors.  This means that the\napplication was not verifying the inputs to the system properly and an attacker could\nhave utilized this vulnerability to crash the application, or perform more advanced exploits.\n\nThis vulnerability only presented itself when ran with a specific command line flag for\nhandling WebGL versions and the system had certain checks that were not performed\nWhen this flag was set.\n","mistakes":"There were inconsistencies in the implementation of WebGL that led to the cause of the vulnerability\nand they were not discovered until edge cases were tested.  This vulnerability is essentially a\nbuffer overflow allowed by lack of verification of inputs to the methods that utilize WebGL, so the fix\nwas sufficient in dealing with the problem.\n"},{"id":242,"cve":"CVE-2011-1121","project_name":"chromium","description":"","mistakes":null},{"id":243,"cve":"CVE-2011-1122","project_name":"chromium","description":"The WebGL implementation in Google Chrome before 9.0.597.107 allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors.","mistakes":"I believe the code in question handles rendering in the browser using OpenGL or OpenGL ES2.\nIn transitioning to OpenGL ES2, they initialized a buffer that was needed by OpenGL but not OpenGL ES2.\nUnder specific circumstances, the buffer could overflow and lead to out of bounds memory access.\n"},{"id":244,"cve":"CVE-2011-1123","project_name":"chromium","description":"","mistakes":null},{"id":245,"cve":"CVE-2011-1124","project_name":"chromium","description":"","mistakes":null},{"id":246,"cve":"CVE-2011-1125","project_name":"chromium","description":"","mistakes":null},{"id":247,"cve":"CVE-2011-1185","project_name":"chromium","description":"","mistakes":null},{"id":249,"cve":"CVE-2011-1187","project_name":"chromium","description":"","mistakes":null},{"id":250,"cve":"CVE-2011-1188","project_name":"chromium","description":"","mistakes":null},{"id":251,"cve":"CVE-2011-1189","project_name":"chromium","description":"","mistakes":null},{"id":252,"cve":"CVE-2011-1190","project_name":"chromium","description":"","mistakes":null},{"id":253,"cve":"CVE-2011-1191","project_name":"chromium","description":"","mistakes":null},{"id":254,"cve":"CVE-2011-1192","project_name":"chromium","description":"","mistakes":null},{"id":255,"cve":"CVE-2011-1193","project_name":"chromium","description":"","mistakes":null},{"id":256,"cve":"CVE-2011-1194","project_name":"chromium","description":"","mistakes":null},{"id":257,"cve":"CVE-2011-1195","project_name":"chromium","description":"","mistakes":null},{"id":259,"cve":"CVE-2011-1197","project_name":"chromium","description":"","mistakes":null},{"id":260,"cve":"CVE-2011-1198","project_name":"chromium","description":"This vulnerability present in Google Chrome's video feature could cause a denial of service attack because it allowed remote attackers to execute arbitrary code causing an \"out-of-bounds\" error and crashing the system.This is due to code that miscounts thread numbers.","mistakes":"Unaccounting for threads in addition to out-of-bound errors depending on thread count. Additionally, this was a high security bug that required the team to fix it early on rather than waiting for another release."},{"id":261,"cve":"CVE-2011-1199","project_name":"chromium","description":"","mistakes":null},{"id":262,"cve":"CVE-2011-1200","project_name":"chromium","description":"","mistakes":null},{"id":263,"cve":"CVE-2011-1201","project_name":"chromium","description":"","mistakes":null},{"id":264,"cve":"CVE-2011-1202","project_name":"chromium","description":"","mistakes":null},{"id":265,"cve":"CVE-2011-1203","project_name":"chromium","description":"","mistakes":null},{"id":266,"cve":"CVE-2011-1204","project_name":"chromium","description":"","mistakes":null},{"id":267,"cve":"CVE-2011-1285","project_name":"chromium","description":"","mistakes":null},{"id":268,"cve":"CVE-2011-1286","project_name":"chromium","description":"","mistakes":null},{"id":269,"cve":"CVE-2011-1291","project_name":"chromium","description":"","mistakes":null},{"id":270,"cve":"CVE-2011-1292","project_name":"chromium","description":"","mistakes":null},{"id":271,"cve":"CVE-2011-1293","project_name":"chromium","description":"","mistakes":null},{"id":272,"cve":"CVE-2011-1294","project_name":"chromium","description":"","mistakes":null},{"id":273,"cve":"CVE-2011-1295","project_name":"chromium","description":"","mistakes":null},{"id":274,"cve":"CVE-2011-1296","project_name":"chromium","description":"","mistakes":null},{"id":275,"cve":"CVE-2011-1300","project_name":"chromium","description":"","mistakes":null},{"id":276,"cve":"CVE-2011-1301","project_name":"chromium","description":"","mistakes":null},{"id":277,"cve":"CVE-2011-1302","project_name":"chromium","description":"","mistakes":null},{"id":278,"cve":"CVE-2011-1303","project_name":"chromium","description":"","mistakes":null},{"id":279,"cve":"CVE-2011-1304","project_name":"chromium","description":"","mistakes":null},{"id":453,"cve":"CVE-2011-3052","project_name":"chromium","description":"","mistakes":null},{"id":454,"cve":"CVE-2011-3053","project_name":"chromium","description":"","mistakes":null},{"id":284,"cve":"CVE-2011-1436","project_name":"chromium","description":"","mistakes":null},{"id":285,"cve":"CVE-2011-1437","project_name":"chromium","description":"","mistakes":null},{"id":286,"cve":"CVE-2011-1438","project_name":"chromium","description":"","mistakes":null},{"id":287,"cve":"CVE-2011-1439","project_name":"chromium","description":"This vulnerability is related to incomplete sandboxing around the chrome\nrenderer process and chrome extensions. By tracing process ids and messages\nit would be possible for an attacker to spoof parts of chrome and execute\narbitrary code.\n\nThe vulnerability did not effect Windows, but on Linux it was possible for\nattackers to escape their sandbox and install their own extensions remotely.\nThis is Linux specific because on Linux it was possible for sandboxed processes\nto interfere with each other due to requirements for chrome's crash reporting\nsystem, breakpad. \n\nIt is unclear in the chrome bug reporting whether the vector of attack was\ndirectly through breakpad, but the interprocess communication with breakpad\nallows for improper information disclosure of process IDs. This is what\nexposes the system to spoofing.\n","mistakes":"This vulnerability seems to be an issue of design mistakes and maintainability. It appears that the design of the renderer and breakpad functionality did not properly account for the sandboxing that was supposed to happen between processes. The intention to make the processes secure was clearly there, but the follow through was lacking.\nThe maintainability aspect of the mistake comes in that a large part of this vulnerability was interaction with the external libraries and dependencies, like breakpad or the Linux kernal signals. As these dependencies evolved, the code was not upkept. In the bug reports the team mentions that a lack of signal verifiability stems directly from failure to amend the code when new features were added.\nThis vulnerability falls squarely under the CWE-265 category - Privelege/Sandbox Issues. This vulnerability closely aligns with CWE-250 - Execution with Unnecessary Priveleges. The vulnerability was caused by unnessary exposure of process IDs, which led to conditions where a sandboxed process could unsafely execute code and break it's sandbox. Another CWE which it relates to is 267 - Privelege Defined With Unsafe Actions. In this vulnerability code used it's privleges improperly and unsafely exposed process IDs. A mitigation mentioned for 267 is to explicitly manage trust zones in the software, which appears to be the route Google took here."},{"id":288,"cve":"CVE-2011-1440","project_name":"chromium","description":"","mistakes":null},{"id":289,"cve":"CVE-2011-1441","project_name":"chromium","description":"","mistakes":null},{"id":290,"cve":"CVE-2011-1442","project_name":"chromium","description":"","mistakes":null},{"id":291,"cve":"CVE-2011-1443","project_name":"chromium","description":"","mistakes":null},{"id":292,"cve":"CVE-2011-1444","project_name":"chromium","description":"","mistakes":null},{"id":293,"cve":"CVE-2011-1445","project_name":"chromium","description":"","mistakes":null},{"id":294,"cve":"CVE-2011-1446","project_name":"chromium","description":"","mistakes":null},{"id":295,"cve":"CVE-2011-1447","project_name":"chromium","description":"","mistakes":null},{"id":296,"cve":"CVE-2011-1448","project_name":"chromium","description":"","mistakes":null},{"id":297,"cve":"CVE-2011-1449","project_name":"chromium","description":"","mistakes":null},{"id":298,"cve":"CVE-2011-1450","project_name":"chromium","description":"","mistakes":null},{"id":299,"cve":"CVE-2011-1451","project_name":"chromium","description":"","mistakes":null},{"id":300,"cve":"CVE-2011-1452","project_name":"chromium","description":"","mistakes":null},{"id":301,"cve":"CVE-2011-1454","project_name":"chromium","description":"","mistakes":null},{"id":302,"cve":"CVE-2011-1455","project_name":"chromium","description":"","mistakes":null},{"id":303,"cve":"CVE-2011-1456","project_name":"chromium","description":"","mistakes":null},{"id":305,"cve":"CVE-2011-1691","project_name":"chromium","description":"","mistakes":null},{"id":306,"cve":"CVE-2011-1793","project_name":"chromium","description":"","mistakes":null},{"id":307,"cve":"CVE-2011-1794","project_name":"chromium","description":"","mistakes":null},{"id":308,"cve":"CVE-2011-1795","project_name":"chromium","description":"","mistakes":null},{"id":309,"cve":"CVE-2011-1796","project_name":"chromium","description":"","mistakes":null},{"id":310,"cve":"CVE-2011-1798","project_name":"chromium","description":"","mistakes":null},{"id":311,"cve":"CVE-2011-1799","project_name":"chromium","description":"","mistakes":null},{"id":312,"cve":"CVE-2011-1800","project_name":"chromium","description":"","mistakes":null},{"id":313,"cve":"CVE-2011-1801","project_name":"chromium","description":"","mistakes":null},{"id":314,"cve":"CVE-2011-1804","project_name":"chromium","description":"","mistakes":null},{"id":315,"cve":"CVE-2011-1806","project_name":"chromium","description":"","mistakes":null},{"id":316,"cve":"CVE-2011-1807","project_name":"chromium","description":"Heap-based buffer overflow in Google Chrome's blob URL handling code. \nThe vulnerability allows remote attackers to execute arbitrary code via \nunspecified vectors that trigger an out-of-bounds write.\n\nThe fix for this vulnerability is to free memory as the very last step in the\naffected function.\n","mistakes":"The vulnerability seems to have been coding mistake. At first glance, it is not obvious that one the functions involved frees memory when called. As mentioned earlier the size of the commit was rather large (+1721 lines, -64 lines) and it affected 37 files. Perhpas the author or reviewers would have caught this if there were fewer concurrent changes to consider."},{"id":317,"cve":"CVE-2011-1808","project_name":"chromium","description":"","mistakes":null},{"id":318,"cve":"CVE-2011-1809","project_name":"chromium","description":"The Accessibility UI attempts to use memory after it's been freed. This allows for exploitable memory corruption, denial of service, or other impact via unknown attack vectors.\n","mistakes":"This vulnerability looks to be the result of a design oversight combined with a coding mistake. Its introduction was as part of a large change of almost 700 lines for another issue. This bug was missed, but ultimately found a day later by a fuzzer.\n"},{"id":319,"cve":"CVE-2011-1810","project_name":"chromium","description":"","mistakes":null},{"id":1499,"cve":"CVE-1999-1199","project_name":"httpd","description":"","mistakes":null},{"id":1500,"cve":"CVE-2000-0505","project_name":"httpd","description":"","mistakes":null},{"id":1501,"cve":"CVE-2000-0913","project_name":"httpd","description":"","mistakes":null},{"id":1502,"cve":"CVE-2000-1204","project_name":"httpd","description":"","mistakes":null},{"id":1503,"cve":"CVE-2000-1205","project_name":"httpd","description":"","mistakes":null},{"id":1504,"cve":"CVE-2000-1206","project_name":"httpd","description":"","mistakes":null},{"id":1505,"cve":"CVE-2001-0729","project_name":"httpd","description":"","mistakes":null},{"id":1506,"cve":"CVE-2001-0730","project_name":"httpd","description":"","mistakes":null},{"id":1507,"cve":"CVE-2001-0731","project_name":"httpd","description":"","mistakes":null},{"id":1508,"cve":"CVE-2001-0925","project_name":"httpd","description":"","mistakes":null},{"id":1509,"cve":"CVE-2001-1342","project_name":"httpd","description":"","mistakes":null},{"id":1510,"cve":"CVE-2002-0061","project_name":"httpd","description":"","mistakes":null},{"id":1540,"cve":"CVE-2004-0493","project_name":"httpd","description":"A component involved in parsing HTTP headers can be used for a remote denial of\nservice attack by triggering a memory leak by using long header lines with a large\namount of space or tab characters.\n","mistakes":"This is a design mistake, as the developer did not factor in the need to have an HTTP header with certain syntax"},{"id":1511,"cve":"CVE-2002-0392","project_name":"httpd","description":"This vulnerability was caused by a lack of error-checking which could allow HTTPD\nto use an invalid size during memory allocation, potentially causing a\ndenial-of-service (availability failure) by using all available memory for\nthe Apache daemon, or on 64-bit systems, an elevation of privilege attack\nallowing attackers to execute arbitrary code by altering return addresses\non the system stack.\n","mistakes":"This issue may have been mitigated if the system included additional unit test cases.\nThe test suite failed to include a case which evaluated this particular type of\ninvalid input, and it brought about a vulnerability. The issue is that this particular\navenue of attack was never brought to mind and as such, the vulnerability passed\nby unnoticed.\n"},{"id":1512,"cve":"CVE-2002-0654","project_name":"httpd","description":"","mistakes":null},{"id":1513,"cve":"CVE-2002-0661","project_name":"httpd","description":"This vulnerability was a simple example of directory traversal. Strings were \nsanitized for '/', but for nothing else. This allowed attackers to user '\\' \ninstead to bypass sanitization. This, paired with '..' could be used to traverse \nthe directory and access whatever files the attacker wishes.\n","mistakes":"The code mistake made here was only checking for '/' when sanitizing a \npotential path traversal vulnerability. If I try to put myself into the \nminds of the developers, I imagine they, likely with mostly UNIX experience, \nsimply did not consider that backslashes could be used for path traversal \nin other operating systems. Even one developer who looked at and commented \non the code in question between the VCC and the fix did not catch the issue \nbefore release. This shows the importance of thoroughly testing and viewing \nyour software from different perspectives, which might reveal new problems.\n"},{"id":1514,"cve":"CVE-2002-0839","project_name":"httpd","description":"","mistakes":null},{"id":1515,"cve":"CVE-2002-0840","project_name":"httpd","description":"Apache Server Side Include Cross Site Scripting Vulnerability.  \nThis is an input validation error.  Input request headers HTTP/1.1 \"Host\" are improperly filtered. \nIt is possible to maliciously hijack web sessions and compromise servers by injecting javascript.  \nThe following URL will demonstrate the attack http://%3CIMG%20SRC%3D%22%22%20ONERROR%3D%22alert%28document2Ecookie%29%22%3 . \n","mistakes":"The mistake that were made was trusting input and not validating it"},{"id":1516,"cve":"CVE-2002-0843","project_name":"httpd","description":"","mistakes":null},{"id":1517,"cve":"CVE-2002-1156","project_name":"httpd","description":"Remote attackers can potentially view Apache source code of one of the CGI \nscripts by directing a POST request to a directory with both WebDAV and CGI \nenabled. This is a very easy vulnerability to exploit with considerable \nimpact to confidentiality.\n","mistakes":"This vulnerability was due to a fundamental flaw in the design of CGI generation\nsystem. Fortunately this bug was addressed quickly, however it would not have \ntaken very much technical knowledge to take advantage of this vulnerability and\nthis was a major breach to confidentiality. This could have been prevented by\nhaving proper code reviews for any new systems and forcing teams to spend\nmore time on architecture design.\n"},{"id":1518,"cve":"CVE-2002-1592","project_name":"httpd","description":"","mistakes":null},{"id":1519,"cve":"CVE-2002-1593","project_name":"httpd","description":"There is a module that handles remote Web content authoring\noperations. This module was looking for versioning hooks, which are versions\nof the content using a pointer.\nThis pointer was not being checked for its existence. Therefore a null pointer\ncould attempted to be used and would cause the system to crash. The crash of\nthe system would cause a denial of service issue.\n","mistakes":"There was a coding mistake made that caused this vulnerability. It\nseemed to be a simple missed check for a null pointer. There was a general\nerror check when getting the value that the pointer held, but it was not\nbeing checked if the pointer existed in the first place. It was just assumed\nthat the pointer existed. Maintainability-wise, this code was fixed in the\nnon backwards compatabile Apache release. So there was never a work around\nfor this bug. This no longer needs to specifically be worried about unless\nsomething is using Apache \u003c2.0.42\n"},{"id":1520,"cve":"CVE-2003-0016","project_name":"httpd","description":"","mistakes":null},{"id":1521,"cve":"CVE-2003-0017","project_name":"httpd","description":"","mistakes":null},{"id":1522,"cve":"CVE-2003-0020","project_name":"httpd","description":"Certain terminals are susceptible to exploits in the form of harmful inputs.\nTake, for example, escape sequences. An escape sequence starts with the ASCII\nescape character and is followed by some arguments. This particular vulnerability\nwas caused by a failure to filter escape sequences out of the terminal when\noutputting error logs. Attackers were able to intentionally inject escape\nsequences into terminals, which caused certain malicious behavior.\n","mistakes":"This vulnerability was caused by code written decades ago. In those\nyears, software vulnerabilities were not as well known as they are today. It's\neasy to imagine that the original author of the code was simply unaware of the\npossibility of escape sequence injection through error logs. The most popular\nmitigation for this type of vulnerability is input validation. The recommended\nmitigation for CWE-150 is specifically whitelist input validation. However,\nthe author who wrote the fix for this vulnerability chose to implement code\nmore akin to a blacklist, rather than a whitelist, which was explicitly not\nrecommended as a mitigation.\n"},{"id":1523,"cve":"CVE-2003-0083","project_name":"httpd","description":"Lack of a filter for terminal escape sequences when writing to access logs. This can cause vulnerabilities in certain circumstances where the logs are viewed with a terminal emulator that has vulnerabilites related to escape sequences.","mistakes":"There was a failure during sanitization to identify all special characters of importance. This is most likely a requirements error."},{"id":1524,"cve":"CVE-2003-0132","project_name":"httpd","description":"","mistakes":null},{"id":1525,"cve":"CVE-2003-0134","project_name":"httpd","description":"","mistakes":null},{"id":1526,"cve":"CVE-2003-0189","project_name":"httpd","description":"","mistakes":null},{"id":1527,"cve":"CVE-2003-0192","project_name":"httpd","description":"","mistakes":null},{"id":1528,"cve":"CVE-2003-0245","project_name":"httpd","description":"","mistakes":null},{"id":1529,"cve":"CVE-2003-0253","project_name":"httpd","description":"MPM's are multi-processing modules which are used to bind to network ports on a \nmachine, accept requests, and handle requests. This vulnerability occurs when\nthe MPM binds to a specific uncommonly used network port. When the C accept() \nmethod (accepts a connection on a socket ) is called it would return an error, \ncausing a temporary denial of service. \n","mistakes":"A lot of factors came to allow this vulnerability to occur. The original author\nwasnt confident in the comments that the code would work all of the time. Edge \ncases in the code weren't properly met. Its possible that there was confusion \nin the requirements and the task wasnt descriptive enough to who was working on \nit. Unit tests were not made to ensure it the code worked as intended. \nThe mitigations for this fix on the CWE was to run fault injection tests. These\ntests weren't applied before and after the fix. This is one reason for the\nvulnerability to appear.\n"},{"id":1530,"cve":"CVE-2003-0254","project_name":"httpd","description":"","mistakes":null},{"id":1531,"cve":"CVE-2003-0460","project_name":"httpd","description":"","mistakes":null},{"id":1532,"cve":"CVE-2003-0542","project_name":"httpd","description":"","mistakes":null},{"id":1533,"cve":"CVE-2003-0789","project_name":"httpd","description":"","mistakes":null},{"id":1534,"cve":"CVE-2003-0987","project_name":"httpd","description":"","mistakes":null},{"id":1535,"cve":"CVE-2003-0993","project_name":"httpd","description":"","mistakes":null},{"id":1536,"cve":"CVE-2004-0113","project_name":"httpd","description":"Accessing an SSL enabled server port with a plain HTTP request would cause a\nmemory leak due to a bug in the mod_ssl implementation. This vulnerability\nopens up the possibility of denial of service attacks by sending many plain\nHTTP requests.\n","mistakes":"This vulnerability was due to two mistakes. A poor judgement call to avoid\nhaving to reimplement/fix a feature that no longer worked, and an assumption\nthat the memory for something would eventually be freed sometime somewhere else,\ninstead of the proper place for it to be freed.\nThe fix looks proper, but the lack of testing done around the issue leads me\nto believe that there are probably plenty of other similar, if not identical issues\npresent in the code base.\n"},{"id":1537,"cve":"CVE-2004-0174","project_name":"httpd","description":"Apache HTTP Servers before v2.0.48 contain a race condition when handling short lived connections. Such a connection on a rarely used socket can cause new connections to be blocked.","mistakes":"Leaving dead code for too long without any sort of testing. The socket causing the issue was rarely used and had barely been touched since its initial implementation. If more maintenance or testing had been done, this issue may never have occured."},{"id":1538,"cve":"CVE-2004-0488","project_name":"httpd","description":"This issue with this CVE was a buffer overflow in Apache HTTP Server 2.0.50. By using a user with trusted CA (Certificate Authority) a remote attacker could\nexecute arbitrary code via a client certificate with a subject DN (Distinguished Name) which exceeds 6K in length.\n","mistakes":"The cause of this error was most likely a design flaw. Whoever wrote the code did not account for a trusted user to exploit a buffer overflow and this lack of foresight is what led to this vulnerability."},{"id":1539,"cve":"CVE-2004-0492","project_name":"httpd","description":"","mistakes":null},{"id":1569,"cve":"CVE-2007-6421","project_name":"httpd","description":"","mistakes":null},{"id":1701,"cve":"CVE-2003-0866","project_name":"tomcat","description":"","mistakes":null},{"id":1702,"cve":"CVE-2005-0808","project_name":"tomcat","description":"","mistakes":null},{"id":1703,"cve":"CVE-2005-1753","project_name":"tomcat","description":"","mistakes":null},{"id":1541,"cve":"CVE-2004-0747","project_name":"httpd","description":"The application fails to validate length for user-inputed strings through the form of\n.httaccess and or httpd.conf config files which can, when malicious, cause a buffer overflow \nwhen this string is parsed, expanded, and copied into a finite buffer. This\ncan affect an environment variable and gives the user elevated privledges locally.\n","mistakes":"The mistakes that were made were primarily coding mistakes as the code written worked as intended but failed\nto check for boundary cases in which overflows could occur. Lots of changes were made between the VCC and the fix,\nand even a patch to the fix was made. It appears there are a lot of factors not considered initially and during the\nlifetime of the vulnerability, as different developers had to keep coming back to the logic. This seems like simple\nmiscommunication. They didn't cover all their tracks.\n\nLooking over their solution, it appears that they opted for the implementation mitigation of CWE-119, \nas they rewrote all the logic for the function in question, adding length checks, casting, etc. to check for\nextraneous inputs and to avoid harmful overflows. This fix needed one patch, and that was to handle a different \nuse case of the function separate from the issue (miscommunication once again). Since then the function was moved \nto a different file but not modified. For these reasons, it appears the solution was ultimately proper.\n"},{"id":1542,"cve":"CVE-2004-0748","project_name":"httpd","description":"","mistakes":null},{"id":1543,"cve":"CVE-2004-0751","project_name":"httpd","description":"The vulnerability occurs in the char_buffer_read function in the mod_ssl module.\nThis allows for a segmentation fault in the char_buffer_read function when \nreverse proxying to an SSL server. A malicious SSL server can force an HTTPD child\nprocess to crash by sending a specially-crafted response header. As a result, a \nremote attacker can cause a denial of service attack. This vulnerability is \nclassified as low impact since it does not allow for execution of arbitrary code\nand does not represent a significant denial of service attack. Requests can be\nhandled by other Apache child processes if one does crash.\n","mistakes":"This vulnerability was a result of a coding mistake in which there is no\ncheck to the memory consumption when running in speculative mode. A possible\nmitigation is to check to make sure that the buffer is large enough to read\nin data.\n"},{"id":1544,"cve":"CVE-2004-0786","project_name":"httpd","description":"","mistakes":null},{"id":1545,"cve":"CVE-2004-0809","project_name":"httpd","description":"Once the WebDAV undergoes an indirect lock, the wrong memory address is accessed and it results in a segmentation\nfault that could cause a system crash.\n","mistakes":"The fix presented did make it seem like a coding mistake as I interpret their was a typo causing the wrong memory address to be altered. But looking further in the commits\nI realize the whole way the system was designed had a lot of faults so there definitely was some design flaws with the way locking worked.\n"},{"id":1546,"cve":"CVE-2004-0811","project_name":"httpd","description":"This CVE involves an internal structure in Apache's HTTPD software that controls how\nauthentication directives (used for password protection) and access directives interact with \neach other. In this particular case, the internal structure was broken such that a request\ncould result in access being granted despite any configured authentication. The user who discovered this\nfound that if requests were ordered a certain way, this vulnerability could happen.\n","mistakes":"It seems that there was a somewhat simple coding mistake in the way the satisfy directives were aggregated in memory from the .htaccess file. \nThe vulnerability was never actually public, since it was only in a specific revision that was never publicly released.\n"},{"id":1547,"cve":"CVE-2004-0885","project_name":"httpd","description":"It is possible for remote clients to bypass restrictions on resources by using Apache's SSLCipherSuite directive. This can be done by using any cipher suite that is recognized by the server.","mistakes":"This vulnerability occured because the developers misinterpreted how the software packages they were using would handle events.\nThe fault does not lie in the packages they were using, but they misunderstood how the system would react when a very specific series of events occured.\nIn order to prevent this from occuring again, the developers should thoroughly study their packages documentation, even to a minute detail (especially when security is a factor)."},{"id":1548,"cve":"CVE-2004-0940","project_name":"httpd","description":"","mistakes":null},{"id":1549,"cve":"CVE-2004-0942","project_name":"httpd","description":"If a request is sent that contains tons of whitespace in an HTTP header, the\nserver consumes an excessive amount of CPU or memory (various sources\ndisagree on which it is; maybe it's both) while attempting to parse it.\n","mistakes":"Unfortunately there appears to be no public discussion of the bug; it was\njust quietly fixed 3 days after the report. Thus, it is difficult to tell\nwhat led to the vulnerability. It appears that it was just a simple coding\nmistake that was not caught by either the author or the two code reviewers.\nA more notable mistake is in commit 3d5263. That commit fixed the inital\nvulnerability of \"lots of whitespace.\" However, it did not fully fix the\nissue; instead, it changed it to \"lots of whitespace on lots of lines.\"\nThis indicated that they were aware of the vulnerability, and *still*\ndidn't consider how their code could be exploited. The vulnerability could\nlikely have been fixed at that commit in June (rather than in November) had\nthe author or reviewers tried to think like a hacker and try to break their\nown code.\n"},{"id":1550,"cve":"CVE-2004-1834","project_name":"httpd","description":"The mod_disk_cache is a tag that sets the program to use disk based storing of cashes,\nthis casheing in included client headers on the users local hard disk. Users can then\npotentially access this information retreiving sensitive data, which includes\nauthentication information.\n","mistakes":"The initial developers did not understand either the funcionality of the tools\nthey were using for cacheing or the full content of the header of which they\nwere caching.\n"},{"id":1551,"cve":"CVE-2005-1268","project_name":"httpd","description":"The vulnerability was in http's processing of certificate revocation lists in\ndebugging mode in its SSL module (mod_ssl).\n\nThe problem is that mod_ssl allocates a buffer of N bytes, and then tells\nBIO_Read that it can read N bytes of text into the buffer. BIO_Read returns a\ncount of how many bytes it read, and the function uses that count to append a\nNULL character to the end of the text. However, that returned value can be up\nto N, which when used as an index is the n+1th index, more than the buffer can\nhold. This could lead to memory corruption, or even a segmentation fault that\nwould bring down httpd.\n\nBefore the vulnerability-contributing commit (VCC) the buffer allocated for\nreading was of size N+1, but BIO_Read was told it could only read up to N\nbytes, thus there was always space for the null terminator.\n\nSome background, certificate revocation lists are used to revoke a\ncertificate in case its private key has been compromised, or the keys used to\nsign it.\n","mistakes":"The mistake was a simple coding mistake made during a cleanup, the entire\nportion of ssl_callback_SSLVerify_CRL that performs debug printing was\nrewritten, and the developer forgot to account for the null terminator when\nallocating size for the buffer and for when they copied the data into it.\n\nThe CWE entry only gives one mitigation, to use the correct size when\ncopying data, which is what the fix did.\n"},{"id":1552,"cve":"CVE-2005-2088","project_name":"httpd","description":"This vulnerability occured when the HTTP Server was acting as an HTTP proxy.\nThe vulnerability allowed remote attackers to perform an attack now known as Http Request Smuggling. Essentially attackers could send an HTTP request to the proxy\nwith two kinds of Headers (Transfer-Encoding chunked\" header and a Content-Length header). This caused apache to process the body of the request in such way and forward it so that the \nreceiveing server would process it as a seperate request. This opened a vulnerability to Cross Site Scripting. \n","mistakes":"This mistake seems to be a design flaw at its core, rather than a coding mistake. \nIt also could have been a series of misscommunication about what was truly needed in this parrt of the project. \nThe flaw (HTTP Request Smuggling) has four mitigations suggested by CWE. These are to use SSL only communication, use strict HTTP Parsing, and terminating the client after each request. \nIt seems like of these three, in the inital fix back in 2005, the termanting the client mitigation was used. \nThis can be avoided in the future by making sure to think about what is being forwarded when dealing with data that comes from the outside world. \n"},{"id":1553,"cve":"CVE-2005-2491","project_name":"httpd","description":"","mistakes":null},{"id":1554,"cve":"CVE-2005-2700","project_name":"httpd","description":"When using mod_ssl (required certificates) for the web server client certifcates are not enforced\nif the configuration in the virtual host specifies that client authication is optional. \n","mistakes":"This mistake was a design a mistake because it failed to verify client certificates during \na certain configuration. It appears that different virtual hosts would effect each other if their verification\nwas set to optional. This mistake could have been prevented had the was a seperation of privledge between the hosts.\n"},{"id":1555,"cve":"CVE-2005-2728","project_name":"httpd","description":"There is a non-limited byte-range weakness that can cause a denial of service attack. \nA byte-range is the buffer size of the input. If an attacker decided to fill an HTTP \nheader with a large amount of information, then it can cause the memory consumption to \nincrease exponentially. This memory leak can eventually lead to the crash of all servers \nwith the same resource allocation. \n","mistakes":"In my opinion this was just a mistake of negligence. I think that the lesson\nyagni really applies here. There were comments in the code talking about \nhow they knew there was no range limit. So they could have just added the check\nto make sure that there was an end to the input, however this vulnerability existed\ndue to this negligence. According to the CWE, they are mitigating it correctly, \nby implementing input validation.\n"},{"id":1704,"cve":"CVE-2005-1754","project_name":"tomcat","description":"","mistakes":null},{"id":1705,"cve":"CVE-2005-2090","project_name":"tomcat","description":"","mistakes":null},{"id":1706,"cve":"CVE-2005-3164","project_name":"tomcat","description":"","mistakes":null},{"id":1556,"cve":"CVE-2005-2970","project_name":"httpd","description":"What makes the Apache HTTP Server widely used is its robustness and ability to support a plethora of \nvarious platforms and environments. It facilitates this with the use of Multi-Process Modules (aka \nMPMs) MPMs are responsible for binding to network ports, taking in requests, and releasing children \nto handle these requests. Webmasters can choose which MPMs to load onto their server depending on \ntheir platform and environment.\n\nThis CVE pertains to the \"worker\" MPM. The \"worker\" MPM supports a multi-process and multi-threaded \nserver. It is capable of handling a multitude of requests and can keep multiple processes open with \neach process possessing multiple threads. Failure to properly close processes leads to memory that \nis not released when it is no longer needed. Attackers can remotely take advantage of this by constantly \naborting connections without closing them. This causes memory depletion and eventually, there is \nno longer any memory available to be reused for future connections, rendering denial of service.\n","mistakes":"A lack of tests seems to be a mistake that may not have led to the vulnerability but more of something \nthat led to the vulnerability being found later than it could have. They mention in their tests README \nthat their tests only cover \"various bits\" of Apache HTTPD so what they have in the repo is not the most \nextensive. Perhaps they have exclusive tests that have not been publicized."},{"id":1557,"cve":"CVE-2005-3352","project_name":"httpd","description":"This a vulnerability that can be exploited by an attacker using cross-site scripting.\nThe imagemap processing module can cause the referer header to be output without being\nescaped in HTML. An attacker who is able to influence the referer header will be able\nto use cross-site scripting to attack.\n","mistakes":"This vulnerability seems to be a result of design mistakes and a lack of maintainability.\nThey didn't consider this scenario when they were designing the project at all. The fix\nfor this problem isn't applicable to all aspects of the project so I would say that the \nmaintainability is fairly low as well.\n\nCWE-80 is \"Basic XSS.\" It is when the software does correctly neutralize special characters.\nThis is the case here. The referer header is being escaped in the HTML because the special \ncharacters were not being handled correctly. The mitigation for this is checking each input.\nAll data in the request, including hidden fields, cookies, headers, the URL itself, and so \nforth must all be checked. In this particular situation they just added a conditional.\n\nThe vulnerabilities fix does not seem very maintainable. The patch doesn't apply everwhere. \nIf the software is not understood, repairable or enhanceable it can't be considered maintainable.\nThe fact that the patch can't be applied everywhere implies that the software isn't understood\nor repairable. \n\nOverall it seems like the fix was effective. Even though it doesn't apply everywhere they know\nthat they can just remove the referer where it doesn't apply. It seems like the solution is not \nideal but it is working so it's alright. \n  \n"},{"id":1558,"cve":"CVE-2005-3357","project_name":"httpd","description":"There was a component of httpd where, if the user had a specific type of a \nSecure Socket Layer (SSL) and created a custom error page, they could cause \na denial of serivce through making the application crash. This was done by \nsubmitting an unsupported request to a certain type of port, which would \ncause a Null Pointer Expection.\n","mistakes":"The main mistake with this vulnerability was the lack of handling if ssl\nwas null. The team never accounted for a non-ssl request to be made on a ssl\nport when if ssl is not currently in use. They seem to have had it written\nso that all requests that came to an ssl port would go through a ssl control\ncheck, regardless of the state of SSL.\n\nThe fix that was implemented seems to effectively eliminate the problem as\nit immediately stops the problem from arising before it has a chance to\nraise an NPE. It was changed from only checking if the ssl protocol was on\nto verifying that ssl was acutally in use and not null, otherwise it would\nstop, as it was no longer relevant.\n"},{"id":1559,"cve":"CVE-2006-3747","project_name":"httpd","description":"This was a vulnerability that affected people who used Apache HTTPD versions 1.3 from 1.3.28 and 2.0.46.\nThis vulnerability allowed malicious users to perform remote attacks that cause denial of service or random code executions. This vulnerability makes use of a off-by-one error which is when data being added to a stack overwrites an extra bit. This situation was only able to happen when certain functions of the rewrite module was used with Lightweight Directory Access Protocol (LDAP) urls. The rewrite module is capable of manipulating urls so that requests from one url can be sent to another url.\nWhen data overflows past its intended boundaries, it allows for the next section of code in the stack to execute or it could even crash the whole program.","mistakes":"It seems like the fault was in the code. The fix was a simple change by decreasing a variable in an if statement by 1. Considering that the change was a simple fix of just editing one line of code, the cause was likely due to accidently overlooking a size limit when the code was made. Vulnerabilities that have to do with size boundaries are easily overlooked which is why I think additional boundary checking should have been done. Boundary tests should always check for extreme cases like maximum inputs."},{"id":1560,"cve":"CVE-2006-3918","project_name":"httpd","description":"","mistakes":null},{"id":1561,"cve":"CVE-2006-5752","project_name":"httpd","description":"when a module in apache is activated on a public page that shows \ndiagnostic data on server such as number of requests and cpu usage,\nan attack would be able to inject malicious html code due to the\nbrowser detecting a charset instead of specifying one.\n","mistakes":"Mistake The team did not give existing functionality a passover once new technologies are implemented, in this case being charset detection.\nLessons we could Learn Emerging technology can and will expose vulnerabilities in existing code.\nNotes Looking through previous iterations of the code, specifying a charset seemed to not be on any of the teams' minds. Originally, I believe it was not an oversight from the team."},{"id":1562,"cve":"CVE-2007-1862","project_name":"httpd","description":"When using HTTP for communication, headers are included that contain information about the data being sent. Due to changes in memory allocation, when Apache would copy header data for a response header it sometimes tried to copy from a location in memory that had already been cleared. New data could have been put in the old location, and this data could be sensitive. This would result in any data a user is entering or viewing potentially getting leaked to the header, which would not necessarily be secure.","mistakes":"It seems that when they began using the APR memory pool they made\nan incorrect assumption about how long their data would remain in its\ntable. While automated testing may have eventually caught it, it's\nunderstandable that a few manual tests might have missed this (as nothing\nappears to be wrong if you get lucky and nothing else takes up the freed\nlocation in memory). Better understanding their tools and using automated\ntests could have helped catch or prevent this. CWE-825 lists mitigations\nthat wouldn't be useful in the situation: use a language that manages \nmemory automatically and set pointers to null after freeing. They\nweren't in a position to stop using C code and, as the CWE site points \nout, complex data structures (like the new APR memory pool) reduces the\neffectiveness of setting pointers to null.\n"},{"id":1563,"cve":"CVE-2007-1863","project_name":"httpd","description":"","mistakes":null},{"id":1564,"cve":"CVE-2007-3304","project_name":"httpd","description":"","mistakes":null},{"id":1565,"cve":"CVE-2007-3847","project_name":"httpd","description":"In HTTPD, which is an open source web server for unix-like systems, remote\nservers can cause denial of service when using threaded MPM by sending a\nmalicious date header that triggers buffer over-read. Threaded MPM refers to\nusing multi-processing modules that handle tasks such as binding network\nports, and accepting requests. The triggered buffer over-read refers to when\nthe code attempts to read adjacent memory beyond the current buffer, where\nsensitive data could be stored that is not supposed to be accessed.\n","mistakes":"The date input causing the issue seems to have been trusted without doing\nall of the proper validation and checking before using it. As mentioned\nearlier I believe this vulnerability could have been avoided if boundary\nchecks were performed. To prevent vulnerabilities of this kind in the\nfuture, each component is supposed to distrust outside inputs and perform\nthe necessary validations to reject bad inputs.\n"},{"id":1566,"cve":"CVE-2007-5000","project_name":"httpd","description":"An attacker could inject malicious HTML/Javascript code into the input of the image\nmapping function of this program in order to compromise the integrity of the system.\nThis vulnerability works if the module is enabled and the imagemap files are publicly\navailable.\n","mistakes":"I think that it was a coding mistake since, when the code was first written,\nthere wasn't any sort of string escaping to mitigate XSS attacks, even though there\nshould have been from the start. I think that the mitigation looks proper since it\nfollows the input validation mitigation on the CWE entry.\n"},{"id":1567,"cve":"CVE-2007-6388","project_name":"httpd","description":"Where the server-status page was enabled, a cross-site scripting vulnerability\nwas possible because where only numbers should have been viable input, code\ncould be injected.\n","mistakes":"This is an implementation mistake. A case was not added to input to verify\nthat the input was an expected value. The fix looks proper. It seems like\nan obvious thing to look and test for now. Hopefully the whole system is\nunder more scrutiny now, I imagine it is since the fixing commit was\ncreated 11 years ago.\n"},{"id":1568,"cve":"CVE-2007-6420","project_name":"httpd","description":"This was a cross-site request forgery (CSRF) vulnerability in the balancer-manager in\nmod_proxy_balancer file for Apache HTTP Server 2.2.x allows remote attackers to\ngain privileges via unspecified vectors.\nThe vulnerability is due to the insufficient authentication checks on requests to the\nbalancer-manager web interface.  An attacker could exploit the vulnerability by\nconvincing a user to follow a link to a malicious website.  When visited, the site could\nsend malicious HTTP requests to the balancer-manager interface on behalf of the user.\n","mistakes":"This vulnerability was seen as medium severity in that if exploited, it\ncould cause a denial of services. However, I did not find records of the\nvulnerability being exploited. There was a mentions of the fact that the\nmalicious user would need to be authenticated to perform and exploit, this\nis probably why the vulnerability was not exploited since it was less likely\nhappen at the time. I also saw some documents that stted there was no need for\nauthentication for the bug to be exploited so I am not entirely sure what the\nactual case was. I also found that the fix was not placed urgently but\nrather addressed in a later release. Looking at the logs, it seemed like not\nvery much was done in order to combat the bug early on, the fix was placed in\n2008.\nThis flaw just shows me that code needs to be tested extensively before being\nreleased. A lot of other code bases relied on this particular servlet and were\nin turn \"affected\". I assume some of them may have had to place \"quick fixes\"\nof their own before adopting the fixed version.\n"},{"id":1570,"cve":"CVE-2007-6422","project_name":"httpd","description":"On sites with a specific setting (mod_proxy_balancer) enabled remote users could\ncraft a request that would cause the process handling it to crash. If the server\nfor the site was also multi-threaded this would lead to a denial of service attack\non the site. \n","mistakes":"They weren't correctly checking possible requests that could come into their\nserver through a large chunk of data. They didn't sanitize the input allowing\nusers to take down the server. They also just didn't think of the outliers in the\nsituation. Both having the mod_proxy_balancer and multi-threaded servers on were \nnot the default so they didn't build their security around this. That is also why\nthe CVE was considered only low priority because not many sites had this combo. \nThe solution was to put a check for the correct balancer name which is a fix for this\nspecific issue but a better fix may be to sanitize their inputs in the first place and not\njust add to the if statement every time an issue arises.\n"},{"id":1571,"cve":"CVE-2008-0005","project_name":"httpd","description":"Upon sending HTML for web pages, the software did not specify a text encoding.\n\nBecause browsers can auto-detect encoding, this meant any encode could effectively\nbe used. This includes UTF-7, which uses + and - characters to deliminate characters\nwith special meanings in order to construct certain other characters. \u003c and \u003e\ncharacters may therefore be written in UTF-7 without using those actual characters.\n\nThis means anyone who knew their way around UTF-7 could create cross-site script\nto run arbitrary JavaScript code.\n","mistakes":"This appears to have been an oversight at the inception of specifying content types that was\nnot addressed until someone proved it to be a vulnerability. This is true even though several\nother commits reworked the way content types were set.\n\nThe mitigation taken is quite straighforward. The charset was explicitly specified as ISO-8859-1.\nThis prevents any other encoding from being used, and it may then be sanitized much more effectively.\n"},{"id":1572,"cve":"CVE-2008-0456","project_name":"httpd","description":"If HTTPD is serving static files, and those static files have extraneous CRLFs,\nthey can inject headers into the HTTP response. Redhat says this isn't an issue\nsince you shouldn't have nasty files in the first place.\nIt also seems like HTTPD actually errors out (it gives either a 406 or 300),\nso this vulnerability can't modify seemingly fine responses, just cause errors.\n","mistakes":"Mainly lack of review and automated testing. Need smaller commits that are reviewed better."},{"id":1573,"cve":"CVE-2008-2364","project_name":"httpd","description":"A flaw was discovered when a server would have to handle excessive interim responses. In a situation where a user who is using the proxy is tricked into visiting a \nmalicious web-server, the proxy would need to use stack or heap memory. If this was continually done\nit could exhaust stack/heap space and crash the server.\n","mistakes":"This is an oversight in design and probably occured simply because it was never discussed. Somewhere in the planning phase there must have been a diagram depicting the interaction between the proxy and the web server. There was no consideration of how the system could be harmed given that the proxy was used to communicate with a malicious web server.\nThis vulnerability falls under the Availability category in the CIA model because it could be used to exhaust stack/heap space and create a DOS attack. The fix for this vulnerability was a simple flag which checked the amount of interim responses done by the forward proxy."},{"id":1574,"cve":"CVE-2008-2939","project_name":"httpd","description":"There was a cross site scripting vulnerability which allowed attackers to\ninject javascript or html. This was via a wildcard in the last pathname of a FTP URI.\nThe vulnerabilities were in the proxy_ftp.c and mod_proxy_ftp.c files.\n","mistakes":"The mistake that was made was a coding mistake. The design or developers did\nnot think to validate input coming from requests from Apace HTTP servers. All an attacker\nneeded to do is compose one wildcard charater in the last directory component of the path\nto use this vunerability as an exploit. Always distrust input and do you own validation.\n"},{"id":1575,"cve":"CVE-2009-0023","project_name":"httpd","description":"","mistakes":null},{"id":1576,"cve":"CVE-2009-1191","project_name":"httpd","description":"Http requests containing a non-zero content-length header value and not containing a body can cause apache to serve content that was intended for another user through the use of a second malformed http request.","mistakes":"This vulnerability was caused by a coding mistake. If an incomplete request was received which contained a non-zero content-length header field, the connection was kept alive and reused instead of being closed."},{"id":1577,"cve":"CVE-2009-1195","project_name":"httpd","description":"The Options=IncludesNOEXEC in configuration for Apache HTTP Server is not handled\nproperly on the AllowOverride directive. By default the code allowed a local user\nto execute code, and the language used in naming this option was counter intuitive.\nThe vulnerability led to a local user being able to execute code that could escalate\ntheir privileges and help further attack the system.\n","mistakes":"This was a design mistake, since the system wasn't defaulting to secure\noptions but rather had a configuration option to keep local users from\nexecuting file inputs. The solution they opted for was to add code to\nAllowOverride so that it does not permit Includes with exec= enabled to\nbe configured in an c file so user can't input code to execute\nin those files. They also made semantic changes so that the OPT_INCLUDES\ndoesn't default to with exec (using with instead of without makes it\nmore clear). I think the most important thing here was the semantic change\nas it honors security by default and helps avoid user error. \n"},{"id":1578,"cve":"CVE-2009-1890","project_name":"httpd","description":"","mistakes":null},{"id":1579,"cve":"CVE-2009-1891","project_name":"httpd","description":"","mistakes":null},{"id":1580,"cve":"CVE-2009-1955","project_name":"httpd","description":"","mistakes":null},{"id":1581,"cve":"CVE-2009-1956","project_name":"httpd","description":"","mistakes":null},{"id":1582,"cve":"CVE-2009-2412","project_name":"httpd","description":"","mistakes":null},{"id":1583,"cve":"CVE-2009-2699","project_name":"httpd","description":"","mistakes":null},{"id":1584,"cve":"CVE-2009-3094","project_name":"httpd","description":"","mistakes":null},{"id":1585,"cve":"CVE-2009-3095","project_name":"httpd","description":"This vulnerability allowed authorized attacks to send commands to an\nFTP server due to inadequate input validation.\n\nThe attack involved sending special characters to the server that\nwould cause unintended behavior when parsed.\n\nThis allowed attacks to bypass access restrictions for target FTP\nservers as they were capable of executing arbitrary commands.\n","mistakes":"The mistake that lead to this vulnerability is a simple coding mistake.\nSpecifically, a lapse in requirements for input validation.\n"},{"id":1586,"cve":"CVE-2009-3560","project_name":"httpd","description":"","mistakes":null},{"id":1587,"cve":"CVE-2009-3720","project_name":"httpd","description":"","mistakes":null},{"id":1588,"cve":"CVE-2010-0010","project_name":"httpd","description":"","mistakes":null},{"id":1589,"cve":"CVE-2010-0408","project_name":"httpd","description":"","mistakes":null},{"id":1590,"cve":"CVE-2010-0425","project_name":"httpd","description":"The Apache mod_isapi (module that implements the internet server extension API. Allows Internet Server extensions) module can be forced to unload a specific library before the processing of a request is complete, resulting in memory corruption. This vulnerability may allow a remote attacker to execute arbitrary code.","mistakes":"This vulnerability was due to the developers overlooking it and not quite understanding what was happening in a piece of their code. The fix for the vulnerability was simply deleting 2 lines of code which unloaded the ISAPI.dll module in the middle of a request which created oprhaned callback pointers. Based on this fix it seems that the unloading of the ISAPI.dll method call at that point in the code was completely unecessary as the system seemed to work completely fine without it. The biggest takeaway from this vulnerability is, it is important to not add unnecessary pieces of code to a system and understand what unintended consequences adding additional functionality can have on the system."},{"id":1591,"cve":"CVE-2010-0434","project_name":"httpd","description":"","mistakes":null},{"id":1592,"cve":"CVE-2010-1452","project_name":"httpd","description":"When the caching or WebDAV modules are enabled in a specific configuration, a process\ncrash can be triggered by sending a request without a path component. This is caused\nby an invalid read which assumes a path was present in the request.\n","mistakes":"This issue seems attributable to a coding mistake. The affected areas\ndid not consider the case in which a path segment could not be parsed from\na request.\n"},{"id":1621,"cve":"CVE-2014-0231","project_name":"httpd","description":"A CGI (Common Gateway Interface) is a protocol used by web servers that runs command-line interface scripts in response to client requests. Apache HTTP Server has a module \"mod_cgid\" which is responsible for running CGI scripts.\nCVE-2014-0231 was a vulnerability in Apache HTTP Server's mod_cgid module where users could create a denial of service attack by causing the process which ran these scripts to hang indefinitely. mod_cgid did not have any timeout feature. If an attacker found a request that caused one of a server's CGI scripts hosted in mod_cgid to halt, this would deny service to other users of the server's CGI scripts.","mistakes":"This is a particularly interesting case of finding a way to make the system fail gracefully. The issue - the process responsible for running CGI scripts hanging indefinitely - is an issue that occurs when a script fails to handle certain inputs properly. The failure to anticipate and handle this special case is what left open the opportunity for a DOS attack on the system.\nLack of unit testing is probably the most clear mistake here. The unit test suite for the project as a whole is relatively sparse, and an issue like this (a rare failure case) can be difficult to anticipate without thorough testing."},{"id":1707,"cve":"CVE-2005-3510","project_name":"tomcat","description":"","mistakes":null},{"id":1593,"cve":"CVE-2010-1623","project_name":"httpd","description":"When HTTPD processes non-SSL (unencrypted) traffic, the way they process that\ndata was flawed that allowed for memory to fill up. With carefully timed\npackets, an attacker could make the HTTPD process fill up on memory and cause\na denial of service. The logic has to do with how timeout policies are\nenforced across core multiple modules in HTTPD.\n\nThe subsystem, mod_reqtimeout, is designed to be \"a convenient way to set\ntimeouts and minimum data rates for receiving requests. Should a timeout occur\nor a data rate be to low, the corresponding connection will be closed by the\nserver\" (from https://httpd.apache.org/docs/trunk/mod/mod_reqtimeout.html).\nIt is a filtering module, which works with HTTPD's \"bucket brigade\" model of\naccepting and parsing network data into the HTTPD quickly.\n\nIn this vulnerability, the policy was loose by allowing 30 seconds to \"linger\"\nwhen a connection was scheduled for closing. This gives ample time for\nattackers to send crafted packets and fill up RAM. Instead, the policy was\nchanged to 2 seconds, along with a big rewrite of how the policies are\nenforced.\n","mistakes":"The fix to this vulnerability was a signifiant rewrite of the original\nfunctionality. The issue was not a small coding mistake, but a poor algorithm\nchoice and poor defaults. More integration testing would have helped with this,\nespecially with a memory management tool like Valgrind.\n"},{"id":1594,"cve":"CVE-2010-2068","project_name":"httpd","description":"This vulnerability is an information disclosure to unintended recipients. A timeout detection flaw can allow a response\nto be sent to a request belonging to a different user. This timeout flaw is where apache is connected with\na tomcat server and apache is configured to timeout before tomcat, putting the connection in a pool where it can be mistakenly given to another user.\n","mistakes":"This was an information disclosure vulnerability. The vcc code at low level did not have any protection from returning a response to an incorrect user. A lack of testing was also a mistake for this vulnerability. Most of the code had tests except for the proxy subsystem. \nA lot of changes were made in between the fix and vcc without testing which was likely the reason that the vulnerability did not get caught sooner.\n"},{"id":1595,"cve":"CVE-2010-2791","project_name":"httpd","description":"","mistakes":null},{"id":1596,"cve":"CVE-2011-0419","project_name":"httpd","description":"","mistakes":null},{"id":1597,"cve":"CVE-2011-3192","project_name":"httpd","description":"This vulnerability involves denial of service by resource exhaustion leading to a denial of service\ndue to improper handling of overlapping byte ranges in http requests. The eventual fix, nearly 7 years later,\ninvolved reducing the memory used by these requests, such that byteranges were \nvalidated to ensure that they were reasonable in the context of the request.\n","mistakes":"The main mistake here seems to be a result of both coding errors and design\nproblems. The ability to specify overlapping byteranges in a header allows for countless\nexhaustion issues. Further, lacking proper validation and restriction of inputs\nopens the door for major issues that could impact countless sites relying on httpd.\n"},{"id":1598,"cve":"CVE-2011-3348","project_name":"httpd","description":"","mistakes":null},{"id":1599,"cve":"CVE-2011-3368","project_name":"httpd","description":"","mistakes":null},{"id":1600,"cve":"CVE-2011-3607","project_name":"httpd","description":"","mistakes":null},{"id":1601,"cve":"CVE-2011-4317","project_name":"httpd","description":"","mistakes":null},{"id":1602,"cve":"CVE-2012-0021","project_name":"httpd","description":"","mistakes":null},{"id":1603,"cve":"CVE-2012-0031","project_name":"httpd","description":"Local users can cause a denial of service attack by modifying a certain field\nwithin a scoreboard shared memory segment. Resulting in an invalid free call.\n","mistakes":"This seems like a coding mistake. The CWE entry for this vulnerability\ndoesn't list mitigations.\n"},{"id":1604,"cve":"CVE-2012-0053","project_name":"httpd","description":"","mistakes":null},{"id":1605,"cve":"CVE-2012-0883","project_name":"httpd","description":"","mistakes":null},{"id":1606,"cve":"CVE-2012-2687","project_name":"httpd","description":"","mistakes":null},{"id":1607,"cve":"CVE-2012-3499","project_name":"httpd","description":"","mistakes":null},{"id":1608,"cve":"CVE-2012-3502","project_name":"httpd","description":"","mistakes":null},{"id":1609,"cve":"CVE-2012-4557","project_name":"httpd","description":"","mistakes":null},{"id":1610,"cve":"CVE-2012-4558","project_name":"httpd","description":"","mistakes":null},{"id":1611,"cve":"CVE-2013-1862","project_name":"httpd","description":"","mistakes":null},{"id":1612,"cve":"CVE-2013-1896","project_name":"httpd","description":"The http protocol has grown over the years, and has gained multiple extentions\nto serve different purposes.  One such extention is WebDAV (Web Distributed\nAuthoring and Versioning) which extends the http protocol to add request methdos\nsuch as COPY, MOVE, etc. to allow for remotely interacting with a servers\nresources or documents.  One place WebDAV is used is in version control over\nHTTP (as opposed to SSH).  Appache HTTPD is one of the few web servers that\nhave native support for WebDAV.\nOne thing that must be ensured when implementing WebDAV is that any URIs\nbeing modified in the context of WebDAV must be on a server that implements\nWebDAV.  Depending on your implementation, forgetting to check for WebDAV at\nthe URI you are trying to access can cause issues.  This could be used by an\nattacker to specifically try to make a request involving URI that does not have\nWebDAV and crash the server.\n","mistakes":"Although at it's core, the patch for this was just originally a coding mistake\nplaced in the wrong function, overall, this is an architectural design mistake.\nThe patch for this was simply adding a single if statement to check a specific\ncase, but there was a real possibility that more places to include URIs could\nhave been added in the future.  This means that all URIs that are being used to\nmake WebDAV requests should be checked, not just this one.  A much stronger\narchitecture would be one that has a subsystem dedicated to making WebDAV requests\nthat does not trust input from the subsystem that handles WebDAV requests.\n"},{"id":1613,"cve":"CVE-2013-2249","project_name":"httpd","description":"A mod_session_dbd had a session fixation flaw, and this vulnerability caused\nby incorrectly handling user sessions in a web application. A user's session\nis usually tracked by a cookie, which is assigned when the user visits the\npage with the web application for the first time. This flaw in mod_session_dbd\ncaused it to proceed with save operations for a session without considering\nthe dirty flag and the requirement for a new session ID.\n","mistakes":"The major mistake that led to this vulnerability was a design error. When executed save operations for a session, without considered the dirty flag and invalidated any exsit session identifier would gave an attacker the opportunity to steal authenticated sessions."},{"id":1614,"cve":"CVE-2013-4352","project_name":"httpd","description":"","mistakes":null},{"id":1615,"cve":"CVE-2013-5704","project_name":"httpd","description":"","mistakes":null},{"id":1616,"cve":"CVE-2013-6438","project_name":"httpd","description":"","mistakes":null},{"id":1617,"cve":"CVE-2014-0098","project_name":"httpd","description":"An attacker would be able to send a specific truncated cookie that would cause\na crash. This would only open a vector for a denial of service in a threaded\nMPM. This issue was in one of the cookie logging files that improperly\ntruncated the cookies.\n","mistakes":"While this seems like an edge case, mistakes were made in not implementing a\nfailsafe. The code that ended up fixing the bug were if statements, ensuring\nthat a cookie's name and value matched their addresses, and then properly\nperformed the truncation in a way that would not enable a denial of service\nattack. These types of vulnerabilities are very difficult to spot, as it is\noften one specific string that may break it; something that likely would not\nhave been thought of by the developer(s) testing the code.\n"},{"id":1618,"cve":"CVE-2014-0117","project_name":"httpd","description":"The HTTP Connection headers is left blank like 'Connection ;' so that the parser\nwill get an empty string and then it will skip over the semi colon and place it as the value of\nthe variable connection. This makes it so when the code for the proxy token is used it uses logic \nbased on whitespaces and deliniated by commas and semi-colons. This is a vulnerability because\nthey use an inherent assumption that the input being passed is already sanitized and compatible.\n","mistakes":"I think there was a simple error of not thorough enough tests. Having an empty\nConnection Header does not seem like an over-complicated input to test. I understand\nit was a more niche situation as it was while use of the proxy module, but proxy servers themselves are not\nniche at all. I think they just need to extend their unit tests to test data passing between modules as well.\n"},{"id":1619,"cve":"CVE-2014-0118","project_name":"httpd","description":"","mistakes":null},{"id":1620,"cve":"CVE-2014-0226","project_name":"httpd","description":"","mistakes":null},{"id":1694,"cve":"CVE-2002-2007","project_name":"tomcat","description":"","mistakes":null},{"id":1695,"cve":"CVE-2002-2008","project_name":"tomcat","description":"","mistakes":null},{"id":1622,"cve":"CVE-2014-3523","project_name":"httpd","description":"A flaw was found in the WinWT MPM in httpd 2.4.1 to 2.4.9 when using the default AcceptFilter for that platform. Because a buffer was not cleared after being potentially filled, an attacker may send requests that can leak memory and cause a denial of service.","mistakes":"The only mistake that was made for this vulnerability was a coding mistake. The developers did not remember to free up a buffer after it was full in a particular area of code, which led to memory leaks and denial of service. This vulnerability was fixed with a simple if statement that, when entered, freed the buffer. This followed the mitigation of ensuring protocols have specific limits of scale placed on them."},{"id":1623,"cve":"CVE-2014-3581","project_name":"httpd","description":"There was a flaw in how a module handled Content-Type headers. The service would crash\nand lead to a denial of service attack if attackers supplied an empty Content-Type \nheader, since it would be a NULL pointer dereference and lead to an application crash.\n","mistakes":"The mistake that lead to this vulnerability was most likely improper testing, \nand a lack of maintainability. Since the start of the project, the code that \nwas involved in the vulnerability was present, and it had not been caught for \naround 10 years.Content-Type headers were assumed to contain something, and\nhaving it deferenced in the code at a certain point lead to this vulnerability.\n"},{"id":1624,"cve":"CVE-2014-3583","project_name":"httpd","description":"Apache Description - An out-of-bounds memory read was found in mod_proxy_fcgi. \nA malicious FastCGI server could send a carefully crafted response which could lead\nto a crash when reading past the end of a heap memory or stack buffer. This issue\naffects version 2.4.10 only.\n\nWhen an Apache HTTPD server is sent a long HTTP header from a FastCGI server, there is\na potential for a buffer overflow error. Apache HTTPD will read long headers and end up\nreading memory past the end of the header that was sent in. This caused denial of service\nissues due to the potential for segmentation faults from buffer overflow.\n\nFastCGI is a protocol (similar to how HTTP is a protocol) that allows servers to execute\nCGI (Common Gateway Interface) scripts on a web server. CGI is used as middleware to \nallow servers to pass data to/from an application or web server. For example, CGI could be\nused to send data between a database and web server.\n","mistakes":"This was a coding mistake, and to an extent, a design mistake. When Apache was\ninitially writing this function, they assumed that any header coming in from another\nserver would include the buffer end character, '\\0'. This null character is the only\nmechanism that stops C from reading memory past the end of the string. \n\nIn C, every string allocated includes a null character at the end. However, the\nvulnerability specifically relates to large headers coming specficially from a remote\nFastCGI server. One good principal in secure coding is to not trust an input's validity\nif it is coming from outside a trust boundary. In this case, the Apache developers\nplaced too much trust on the assumption that any header would include a null character.\nIt lead to them writing code that relied solely on the existence of an end character in input\nto prevent overflow errors. The developers should have not trusted the validity of \noutside input and placed checks to prevent memory from being read\n\nThe fix is extremely simple - check the length of an incoming string and read only up to the \nlength of that string. This is a good fix, since there isn't a reliance on outside input - the\nheaders are checked after they are received. Another potential fix Apache could consider\nimplementing is to simply limit the length of the headers, since this vulnerability specifically\nappears on headers over a certain length. The drawback of this approach is that it may be temporary.\nBecause HTTP standards are always changing, longer headers may be the norm in the future and such\na fix will eventually have to be re-fixed properly in the future.\n\nThe mistake can also be considered a design mistake. It was interesting to see that the vulnerability\naffected this module specifically. HTTP headers are not unique to FastCGI - they come from everywhere.\nThe question becomes how many other modules are doing their own HTTP header parsing, and why would\nonly this module specifically be affected? It may be prudent for Apache to consider a single HTTP\nheader parser so that the entire code base can reference one uniform parser.\n"},{"id":1625,"cve":"CVE-2014-8109","project_name":"httpd","description":"The Apache http server did not support a configuration that contained a Lua \nauthorization provider that was used twice with different arguments for a different\ncontext. This would allow attackers to bypass intended access restrictions under \nspecific circumstances with multiple require arguments. By separating the auth\nprovider from the arguments that are passed with it the issue is avoided.\n","mistakes":"This is a common mistake of not accounting for a specific case of input data\nwith the same name as another input causing issues of acquisition. These \nare vulnerabilities that are hopefully thought of when considering defensive\ncoding practices and inputs like these are good canidates for unit cases to \ncatch potential edge cases like these.\n"},{"id":1626,"cve":"CVE-2015-0228","project_name":"httpd","description":"","mistakes":null},{"id":1627,"cve":"CVE-2015-0253","project_name":"httpd","description":"","mistakes":null},{"id":1628,"cve":"CVE-2015-3183","project_name":"httpd","description":"The HTTP server improperly parsed headers which allowed remote \nattackers the ability to execute a HTTP request smuggling attack.\n","mistakes":"From what I can tell the issue didn't directly stem from this code, this is\njust where the solution to something else happened to be implemented. \n"},{"id":1629,"cve":"CVE-2015-3185","project_name":"httpd","description":"","mistakes":null},{"id":1630,"cve":"CVE-2016-0736","project_name":"httpd","description":"","mistakes":null},{"id":1631,"cve":"CVE-2016-1546","project_name":"httpd","description":"This vulnerability effects The Apache HTTP Server 2.4.17 and 2.4.18.\nIt only is relevant when mod_http2 is enabled. The issue is that no limits on\nsimultaneous stream workers are put into place, meaning that any client that can\ncraft a request that results in high numbers of stream workers, can cause a denial\nof service for stream processing by starving the system of resources.\n","mistakes":"Lack of testing and review. The vulnerability was introduces to add a feature, but no checks were\nput in place (that I could see) to make sure that new features don't introduce new bugs.\n"},{"id":1632,"cve":"CVE-2016-2161","project_name":"httpd","description":"A remote attacker could write malicious input to a data stream that would cause\nthe server to crash. Once the server is crashed, subsequently valid requests will continue to crash\nthe server.\n","mistakes":"This vulnerability is the result of a coding mistake. More specifically, a missed edge case\nthat can be used maliciously for a dos attack. The vulnerability was created in a single commit but\nthe allocation functions had been rewritten a few times previously. It does not appear that prior functions\ncovered this edge case either.\n\nThis vulnerability falls under the Availability category in the CIA model and is classified as a High threat\ndue to it's ability to bring down the system. The fix appeals to an input validation strategy and distrusts the memory allocation of another function.\nIt does so by stepping through the memory to ensure that adequate space exists in the shared memory.\n"},{"id":1633,"cve":"CVE-2016-4975","project_name":"httpd","description":"","mistakes":null},{"id":1634,"cve":"CVE-2016-4979","project_name":"httpd","description":"","mistakes":null},{"id":1635,"cve":"CVE-2016-5387","project_name":"httpd","description":"httpd sets the environment variable HTTP_PROXY based on the proxy field in the received http request header. This is done to pass the proxy information to CGI scripts. This can be abused to execute a MITM attack or to cause httpd to send requests to an arbitrary server.","mistakes":"This was a design mistake. Environment variables probably shouldn't be used to pass the proxy information to CGI scripts. This is especially true if the proxy information is provided by any remote, unauthenticated user."},{"id":1636,"cve":"CVE-2016-8740","project_name":"httpd","description":"A specific module, the modhttp2 module did not offer data length restriction for the request headers. This means that malicious sources could potentially send through large amounts of information, and block out threads, stopping others from being able to use it. This could lead to a denial of service attack.","mistakes":"One of the biggest mistake is the lack of integration/unit tests that verify for strange inputs and weird situations. In addition, better coding practices like quality assurance testing would go a long way in resolving this issue. Overall better design to verify input size could have assisted."},{"id":1637,"cve":"CVE-2016-8743","project_name":"httpd","description":"Uncommon whitespace patterns are accepted in requests and included in responses.\n\nWhen the server is working with backends, proxies, or other servers that do not\nproperly handle this whitespace or have special meaning for such whitespace,\nmultiple responses could be generated. This can cause some backends to wrongly\nassociate one response with a different request, causing cache pollution or more\nserious problems down the chain.\n","mistakes":"This issue is primarily a design flaw in the original request parser.\nRather than simply ignore any combination of whitespace, it should have\nbeen validating that specific required and common patterns were used so that\ncollaborative components not controlled by the project could accept this input\nwithout issue.\n\nThe vulnerability is easily fixed by validating that the input meets the whitespace\ncriteria and in some cases sanitizing it for other components/servers. That is essentially\nwhat was done in this case, except that configuration modes were added so that\nstrict validation takes place by default, but an unsafe mode preserves the old behavior.\n\nBetween the time the parser was originally introduced to the repository in 1999 and when\nthe fix was applied in 2016, the parsing logic remained largely the same, with the exception\nof moving it back and forth between a few modules. (This is why no interesting commits are listed).\n"},{"id":1638,"cve":"CVE-2017-15710","project_name":"httpd","description":"","mistakes":null},{"id":1639,"cve":"CVE-2017-15715","project_name":"httpd","description":"","mistakes":null},{"id":1640,"cve":"CVE-2017-3167","project_name":"httpd","description":"","mistakes":null},{"id":1641,"cve":"CVE-2017-3169","project_name":"httpd","description":"","mistakes":null},{"id":1642,"cve":"CVE-2017-7659","project_name":"httpd","description":"In HTTPD, an open source web server for Unix-like systems, HTTP/2 requests\ncould be crafted in a way that could cause mod_http2 module to dereference\na NULL pointer and crash the server process. The code causing the\nvulnerability was attempting to dereference the pointer before checking\nit and ensuring it is not NULL, so a request with a NULL pointer crashed the\nprocess. HTTP/2 requests refer to HTTP/2.0 which is a revision of the HTTP\nnetwork protocol.\n","mistakes":"I am sure its not as simple as it seems but I think replacing a module that\nwas being reused could be a mistake. I am sure the development team had\nvalid reasons at the time for doing so but I cant help but wonder why they\nfelt the need to do it. The replaced module did not seem to belong to a\nthird party which meant they had control over it. In the future, to avoid\nthis kind of vulnerability, outside input must always be validated before\ninner components put it to use.\n"},{"id":1696,"cve":"CVE-2002-2009","project_name":"tomcat","description":"","mistakes":null},{"id":1697,"cve":"CVE-2003-0042","project_name":"tomcat","description":"","mistakes":null},{"id":1698,"cve":"CVE-2003-0043","project_name":"tomcat","description":"","mistakes":null},{"id":1699,"cve":"CVE-2003-0044","project_name":"tomcat","description":"","mistakes":null},{"id":1700,"cve":"CVE-2003-0045","project_name":"tomcat","description":"","mistakes":null},{"id":1643,"cve":"CVE-2017-7668","project_name":"httpd","description":"When parsing HTTP request headers, the ap_find_token() function in the Apache\nHTTPD server would overrun the string buffer when searching for a specific\ntoken. If line being searched contained a NUL (\\0) character in the last\ntoken of the string, then the function would continue to read past the end of\nthe string resulting in a buffer overrun.\nThis occurs because of how the ap_find_token() function searched for the\nbeginning of a token. If a NUL character was found, the function would skip\npast it and continue processing the memory beyond the NUL character.\n","mistakes":"A concious, documented decision was made to not check for NUL characters\nwhen searching for the start of a token in the input string. When working\nin C, where string parsing is a ripe target for buffer overruns, this\nshould have raised some alarms.\nNormal HTTP headers should never contain NUL characters, so when one shows\nup somewhere it isn't expected, the server should treat it as a malformed\nrequest and stop attempting to process it normally. Workarounds should not\nbe implemented in case a NUL character is encountered in the middle of a\nstring, because that's not something that should be happening in the first\nplace. Additionally, for software as widespread as Apache HTTPD,\nimplementing non-standard behavior only encourages nonconformity to the\nestablished standards.\n"},{"id":1644,"cve":"CVE-2017-7679","project_name":"httpd","description":"This CVE describes a vulnerability related to the mod_mime module, which itself\nis responsible for associating meta-data to a file requested from the server.\nMeta-data includes behaviors and attributes, such as the language, encoding,\ncharacter set or mime-type of the file.\n\nThe vulnerability states that this module is able to \"read one byte past the\nend of a buffer when sending a malicious Content-Type response header\". In other\nwords, if a user sends an HTTP request with some unexpected Content-Type field,\nthe Apache server will attempt to read up to one byte of additional memory next\nto the content requested by the user.\n\nThis leads to a buffer overread error, in the mod_mime module which (if not\nhandled properly) has the potential to impact availability of the server by\ncrashing it (DOS), or violating integrity if the data is read without error\nand returned to the user with potentially sensitive data. Currently, all\ndocumentation points to potential denial-of-services as being the biggest\nthreat.\n","mistakes":"After researching the purpose of the module and looking at the\nfunction where the vulnerability exists in the greater context of its file,\nI'm fairly confident that a simple coding mistake led to this vulnerability.\n\nAt the end of the day, the vulnerability was fixed simply by removing one\nnull check and adding another null check in.\n"},{"id":1645,"cve":"CVE-2017-9788","project_name":"httpd","description":"","mistakes":null},{"id":1646,"cve":"CVE-2017-9789","project_name":"httpd","description":"","mistakes":null},{"id":1647,"cve":"CVE-2017-9798","project_name":"httpd","description":"Users are able to corrupt the global methods table by setting the Limit\ndirective in their .htaccess file or if their httpd.conf has unexpected configurations.\nThis results in unpredictable behavior and allows attackers to read data from\nprocess memory that they do not have access to. An attacker can deliberately trigger\nthe  vulnerability and attempt to access data from freed memory.\n\nA good explanation can be found at: https://blog.fuzzing-project.org/60-Optionsbleed-HTTP-OPTIONS-method-can-leak-Apaches-server-memory.html\n","mistakes":"This vulnerability was caused by a design error. The CWE suggests choosing\na language that provides automatic memory managaement or freeign pointers \nand setting them to null during implementation. These were not applied in the \nfix. Instead the fix sought to prevent .htaccess exploits by only allowing \nmethods that were registered at initialization.\n"},{"id":1648,"cve":"CVE-2018-11763","project_name":"httpd","description":"","mistakes":null},{"id":1649,"cve":"CVE-2018-1283","project_name":"httpd","description":"","mistakes":null},{"id":1650,"cve":"CVE-2018-1301","project_name":"httpd","description":"","mistakes":null},{"id":1651,"cve":"CVE-2018-1302","project_name":"httpd","description":"","mistakes":null},{"id":1652,"cve":"CVE-2018-1303","project_name":"httpd","description":"","mistakes":null},{"id":1653,"cve":"CVE-2018-1312","project_name":"httpd","description":"","mistakes":null},{"id":1654,"cve":"CVE-2018-1333","project_name":"httpd","description":"","mistakes":null},{"id":1655,"cve":"CVE-2018-17189","project_name":"httpd","description":"","mistakes":null},{"id":1656,"cve":"CVE-2018-17199","project_name":"httpd","description":"","mistakes":null},{"id":1657,"cve":"CVE-2018-8011","project_name":"httpd","description":"","mistakes":null},{"id":1658,"cve":"CVE-2019-0190","project_name":"httpd","description":"","mistakes":null},{"id":1659,"cve":"CVE-2019-0196","project_name":"httpd","description":"","mistakes":null},{"id":1660,"cve":"CVE-2019-0197","project_name":"httpd","description":"","mistakes":null},{"id":1661,"cve":"CVE-2019-0211","project_name":"httpd","description":"","mistakes":null},{"id":1662,"cve":"CVE-2019-0215","project_name":"httpd","description":"","mistakes":null},{"id":1663,"cve":"CVE-2019-0217","project_name":"httpd","description":"","mistakes":null},{"id":1664,"cve":"CVE-2019-0220","project_name":"httpd","description":"","mistakes":null},{"id":1665,"cve":"CVE-2019-10081","project_name":"httpd","description":"","mistakes":null},{"id":1666,"cve":"CVE-2019-10082","project_name":"httpd","description":"","mistakes":null},{"id":1667,"cve":"CVE-2019-10092","project_name":"httpd","description":"","mistakes":null},{"id":1668,"cve":"CVE-2019-10097","project_name":"httpd","description":"","mistakes":null},{"id":1669,"cve":"CVE-2019-10098","project_name":"httpd","description":"","mistakes":null},{"id":1670,"cve":"CVE-2019-9517","project_name":"httpd","description":"","mistakes":null},{"id":1671,"cve":"CVE-2020-11984","project_name":"httpd","description":"","mistakes":null},{"id":1672,"cve":"CVE-2020-11985","project_name":"httpd","description":"","mistakes":null},{"id":1673,"cve":"CVE-2020-11993","project_name":"httpd","description":"","mistakes":null},{"id":1674,"cve":"CVE-2020-1927","project_name":"httpd","description":"","mistakes":null},{"id":1675,"cve":"CVE-2020-1934","project_name":"httpd","description":"","mistakes":null},{"id":1676,"cve":"CVE-2020-9490","project_name":"httpd","description":"","mistakes":null},{"id":1677,"cve":"CVE-2000-0672","project_name":"tomcat","description":"","mistakes":null},{"id":1678,"cve":"CVE-2000-0759","project_name":"tomcat","description":"","mistakes":null},{"id":1679,"cve":"CVE-2000-0760","project_name":"tomcat","description":"","mistakes":null},{"id":1680,"cve":"CVE-2000-1210","project_name":"tomcat","description":"","mistakes":null},{"id":1681,"cve":"CVE-2001-0590","project_name":"tomcat","description":"","mistakes":null},{"id":1682,"cve":"CVE-2001-0829","project_name":"tomcat","description":"","mistakes":null},{"id":1683,"cve":"CVE-2001-0917","project_name":"tomcat","description":"","mistakes":null},{"id":1684,"cve":"CVE-2001-1563","project_name":"tomcat","description":"","mistakes":null},{"id":1685,"cve":"CVE-2002-0493","project_name":"tomcat","description":"","mistakes":null},{"id":1686,"cve":"CVE-2002-0682","project_name":"tomcat","description":"","mistakes":null},{"id":1687,"cve":"CVE-2002-0935","project_name":"tomcat","description":"","mistakes":null},{"id":1688,"cve":"CVE-2002-0936","project_name":"tomcat","description":"","mistakes":null},{"id":1689,"cve":"CVE-2002-1148","project_name":"tomcat","description":"","mistakes":null},{"id":1690,"cve":"CVE-2002-1394","project_name":"tomcat","description":"","mistakes":null},{"id":1691,"cve":"CVE-2002-1567","project_name":"tomcat","description":"","mistakes":null},{"id":1692,"cve":"CVE-2002-1895","project_name":"tomcat","description":"","mistakes":null},{"id":1693,"cve":"CVE-2002-2006","project_name":"tomcat","description":"","mistakes":null},{"id":1708,"cve":"CVE-2005-4703","project_name":"tomcat","description":"","mistakes":null},{"id":1709,"cve":"CVE-2005-4836","project_name":"tomcat","description":"","mistakes":null},{"id":1710,"cve":"CVE-2005-4838","project_name":"tomcat","description":"","mistakes":null},{"id":1711,"cve":"CVE-2006-3835","project_name":"tomcat","description":"","mistakes":null},{"id":1712,"cve":"CVE-2006-7195","project_name":"tomcat","description":"","mistakes":null},{"id":1713,"cve":"CVE-2006-7196","project_name":"tomcat","description":"","mistakes":null},{"id":1714,"cve":"CVE-2007-0450","project_name":"tomcat","description":"","mistakes":null},{"id":1715,"cve":"CVE-2007-1355","project_name":"tomcat","description":"","mistakes":null},{"id":1716,"cve":"CVE-2007-1358","project_name":"tomcat","description":"","mistakes":null},{"id":1717,"cve":"CVE-2007-1858","project_name":"tomcat","description":"","mistakes":null},{"id":1718,"cve":"CVE-2007-1860","project_name":"tomcat","description":"","mistakes":null},{"id":1719,"cve":"CVE-2007-2449","project_name":"tomcat","description":"","mistakes":null},{"id":1720,"cve":"CVE-2007-2450","project_name":"tomcat","description":"","mistakes":null},{"id":1721,"cve":"CVE-2007-3382","project_name":"tomcat","description":"","mistakes":null},{"id":1722,"cve":"CVE-2007-3383","project_name":"tomcat","description":"","mistakes":null},{"id":1723,"cve":"CVE-2007-3384","project_name":"tomcat","description":"","mistakes":null},{"id":1724,"cve":"CVE-2007-3385","project_name":"tomcat","description":"","mistakes":null},{"id":1725,"cve":"CVE-2007-3386","project_name":"tomcat","description":"","mistakes":null},{"id":1726,"cve":"CVE-2007-5333","project_name":"tomcat","description":"","mistakes":null},{"id":1727,"cve":"CVE-2007-5342","project_name":"tomcat","description":"","mistakes":null},{"id":1728,"cve":"CVE-2007-5461","project_name":"tomcat","description":"","mistakes":null},{"id":1729,"cve":"CVE-2007-6286","project_name":"tomcat","description":"","mistakes":null},{"id":1730,"cve":"CVE-2008-0002","project_name":"tomcat","description":"","mistakes":null},{"id":1731,"cve":"CVE-2008-0128","project_name":"tomcat","description":"","mistakes":null},{"id":1732,"cve":"CVE-2008-1232","project_name":"tomcat","description":"","mistakes":null},{"id":1733,"cve":"CVE-2008-1947","project_name":"tomcat","description":"","mistakes":null},{"id":1734,"cve":"CVE-2008-2370","project_name":"tomcat","description":"","mistakes":null},{"id":1735,"cve":"CVE-2008-2938","project_name":"tomcat","description":"","mistakes":null},{"id":1736,"cve":"CVE-2008-3271","project_name":"tomcat","description":"","mistakes":null},{"id":1737,"cve":"CVE-2008-4308","project_name":"tomcat","description":"","mistakes":null},{"id":1738,"cve":"CVE-2008-5515","project_name":"tomcat","description":"","mistakes":null},{"id":1739,"cve":"CVE-2009-0033","project_name":"tomcat","description":"","mistakes":null},{"id":1740,"cve":"CVE-2009-0580","project_name":"tomcat","description":"","mistakes":null},{"id":1741,"cve":"CVE-2009-0781","project_name":"tomcat","description":"","mistakes":null},{"id":1742,"cve":"CVE-2009-0783","project_name":"tomcat","description":"","mistakes":null},{"id":1743,"cve":"CVE-2009-2693","project_name":"tomcat","description":"The vulnerability allows for an attacker to create, modify, or delete files using a specially crafted Web Application Resource (WAR) file. Tomcat fails to check for directory traversal commands in directory paths using ../ and that is what the attacker uses to craft the WAR file. When the WAR file is deployed on the Tomcat server, the directory traversal command can be used to modify files outside of the web root directory. The files can be created, modified, or deleted. Secure information from the web server could be moved out of sccope, or a key file for the server could be deleted which could cause a denial of service.","mistakes":"The mistake that was made here was simple. The developer neglected to consider that someone might try to navigate outside of the root directory and never put in test cases and exceptions for when that happens. Since there was a lack of unit testing, the directory traversal was never tested for and stayed in the code for a while unnoticed. This isn't exactly a mistake but more of an oversight on the developers part. The vulnerability was fixed by adding checks for \"../\" for any path that was being constructed."},{"id":1744,"cve":"CVE-2009-2901","project_name":"tomcat","description":"By default, Tomcat automatically deploys any directories placed in a host's appBase.\nThis behaviour is controlled by the autoDeploy attribute of a host, which defaults to\ntrue. In the event of any failure encountered while undeploying (cleaning up) files, any\nremaining files left to be cleaned up will be deployed as a result of the autodeployment\nprocess. Depending on circumstances, files normally protected by one or more security\nconstraints may be deployed without those security constraints, making them accessible\nwithout authentication. This issue only affects Windows platforms.\n","mistakes":"From the looks of it, this is a simple coding mistake. What the developers\nassumed was a solid undeployment strategy was not, and they were not doing\nany logging or validation to verify that the WAR was correctly stopping and\ngetting cleaned up until this fix. As this relates to CWE-212, I believe that\nthey are doing a much better job of verifying that all of their WAR-related\nartifacts are being properly cleaned.\n"},{"id":1745,"cve":"CVE-2009-2902","project_name":"tomcat","description":"This vulnerability allows a user over a network to create a specially crafted WAR (Web Application Resource, including JAR files, JavaServer pages, static files, etc.) file that could be deployed by an authorized user. The WAR could potentially overwrite files on the system running Apache Tomcat under the \"work/\u003cengine-name\u003e/\u003chostname\u003e\" directory. This vulnerability is an example of improper limitation of a pathname to a restricted directory because a user without access to the system can violate the integrity of files they should not have access to.","mistakes":"In my opinion this was a coding mistake. It could have been prevented by a thorough code review from a knowledgable Software Engineer that is familiar with common software security vulnerabilities. A seasoned engineer that is familiar with software security could have caught this vulnerability before it made it to production code."},{"id":1746,"cve":"CVE-2009-3548","project_name":"tomcat","description":"The Windows installer for Apache Tomcat uses a blank default \npassword for the administrative user, which allows remote attackers to gain privileges easily.\nThis is obviously aggergious because it gives anyone admin access without having to\nprovide any credentials.\n","mistakes":"This appears to have been a design issue. The way the engineers designed the system, this vulnerability\nwas inherent. They didn't keep in mind the core security principle of secure by default. It wasn't until \nsomeone who was investigating security found this issue 3 years later that it was patched. It even mentioned \nin the response to the vulnerability report that the system behaved contrary to how it was described in the docs.\nThe contrast between actual system behavior and the docs was clear midcommunication within the team.\nThe mitigation was to simply modify the default password to not be blank, so this mitigation seems sufficient \nwithin the scope of the vulnerability.\n"},{"id":1747,"cve":"CVE-2009-3555","project_name":"tomcat","description":"Regulation of the transfer of data within the network is open to \"man-in-the-middle\" remote attacks that allow the attacker to inject data into a secure communication between two parties. The remote attacker can masquerade as the original party that initiates this communication. This allows the attacker to execute requests on behalf of the victim. Sensitive data may be compromised due to the inadequate or inconsistent verification of identities. In relation to Tomcat, Tomcat encrypts data along a communication channel between two parties. Tomcat supports renegotiation, which allows the user to interact with a system before authentication, then change their status to an authenticated user while also saving the user's activity, data, etc. The vulnerability comes in when a remote attacker intercepts the renegotiation and poses as the user. The attacker is then able to modify the communication.","mistakes":"The vulnerability was the product of a variety of mistakes. There seemed to be\nlack of testing for both commits mentioned above. Testing in general would ensure\nthat something works the way it was intended to work. There were also coding mistakes\nthat resulted in either end of the communications channel to not be fully authenticated.\nThe design mistake that was potentially a factor could be that access for each entity \nwas not properly checked for authority.\n"},{"id":1748,"cve":"CVE-2010-1157","project_name":"tomcat","description":"A portion of Tomcat that handles http authentication via DIGEST and BASIC strategies had the potential to allow\nfor the viewing of the local name or IP address of the server running Tomcat. The header for the authentication \nvia these strategies includes a \u003crealm-name\u003e element.\nIf a \u003crealm-name\u003e element is specified for the application in one of the configuration files, it will be used. \nHowever, if a \u003crealm-name\u003e is not specified then Tomcat will generate a realm name and\nin some circumstances this can expose the local host name or IP address of the machine running Tomcat. \n","mistakes":"It seems that this vulnerability was an oversight with regards to how the configuration and authentication code\ninteracted. The fix was to provide a default realm name that did not contain sensitive data, instead of \ngenerating a string that used the actual hostname and port. What lead to this vulnerability was most likely\na simple ignorance to the value of a server's hostname information.\n"},{"id":1749,"cve":"CVE-2010-2227","project_name":"tomcat","description":"","mistakes":null},{"id":1750,"cve":"CVE-2010-3718","project_name":"tomcat","description":"In Tomcat, web applications are normally allowed access to a particular work\ndirectory on the user's system. The applications are granted both read and write\npermissions to that directory so that they are able to use temporary files. Tomcat\nhas an attribute that dictates the location of that directory. To prevent web\napplications from changing the work directory, they should not be able to modify\nthat attribute. However, as a result of this vulnerability, applications were\nable to change that attribute, which meant that malicious web applications\ncould read and write to any area on the user's file system.\n","mistakes":"The main mistake that lead to this vulnerability was a lack of testing.\nThe author was aware that it was necessary to set the work directory\nattribute to read-only. However, due to the way it was implemented,\nthe actual code that set the attribute to read-only was ineffective.\nA fairly simple test should have been able to catch this issue.\nOne of the potential mitigations for CWE-269 is to carefully manage\nthe handling of privileges. The fix created for this vulnerability\nseems to employ this mitigation in a proper way.\n\nFortunately, this vulnerability had fairly low impact and exploitability\nscores. Confidentiality and availability were not affected whatsoever as\na result of this vulnerability. However, integrity was affected since\nan attacker was able to modify the user's files. There were no known\nreports of this vulnerability being exploited. Since the Tomcat security\nteam discovered this issue themselves, they were able to fix it before\nit became a bigger issue.\n"},{"id":1751,"cve":"CVE-2010-4172","project_name":"tomcat","description":"","mistakes":null},{"id":1752,"cve":"CVE-2010-4476","project_name":"tomcat","description":"A method used in the Java Runtime Environment, the one responsible for parsing\nand converting double binary floating-point numbers, may lead to an infinite\nloop of estimations while converting. An example of this is attempting to convert\nthe number 2.2250738585072012e-308 with the method.\n\nThis exploit can enable a denial of service from a remote attacker using a\ncrafted string that will trigger this infinite loop by causing a hang or a\nrepeatable crash on the affected programs.\n","mistakes":"This was a very obscure vulnerability to find, as it only works in a very\nsmall range of numbers. The \"magic number\" may have just been found by chance,\nand it breaking PHP led to others trying it in other languages. If not for\nthat original bug in PHP, this potentially would not have ever been found.\nThe fix for this looks proper, as it avoids the infinite loop in checking\nhow good the quality of the parsed number is after parsing it.\n"},{"id":1753,"cve":"CVE-2011-0013","project_name":"tomcat","description":"An interface in Apache's software that controls the HTML Manager interface\nis vulnerable. It can be affected by someone injecting a script into the\nurl which alters the appearance or data of any manager page that was \nfollowed by a user with administrator privileges.\n       \n","mistakes":"It seems that filtering input was overlooked and forgotten while developing.\nIf security had been addressed during the design of the manager subsystem,\nthis could have been caught then. This may due to an agile development process\nwhich focused on feature implementation, rather than security. The fix does\nlook proper, since all raw input sent to the user now is filtered through a\nfilter function.\n"},{"id":1754,"cve":"CVE-2011-0534","project_name":"tomcat","description":"","mistakes":null},{"id":1755,"cve":"CVE-2011-1088","project_name":"tomcat","description":"Apache Tomcat is a Java Servlet Container system for helping run Java Servlets.\nJava Servlets are simple additions to a basic server that help exend functionality.\nTomcat uses two separete methods for allowing developers to enforce permissions\non urls, one of which is the @ServletSecurity annotation. For Tomcat 7.0 - 7.0.10\nthese annotations were ignored, allowing any user to access any route that should\nhave been protected by these annotations were freely accessable without any protections\nor authentication\n","mistakes":"This was mostly a coding bug, as the annotations were simply forgetten about\nfor version 7.0.0 of Tomcat. Security permissions were enforced if they were\ndefined in the XML. Tomcat did not properly parse the @ServletSecurity\nannotations within the code themselves Any security settings in these\nannotations were not enforced as a result. This shows that it was an\noversight when moving to Tomcat 7.0.0, as previous versions were unaffected\nby this bug.\n"},{"id":1756,"cve":"CVE-2011-1183","project_name":"tomcat","description":"The basic configurations for a Tomcat web application are set in the web.xml file. \nThis file includes a config called \"login-config\" which sets a level of security \nfor the application by whitelisting url's based on a user's role. This bug occurred \nwhen this configuration was not set and a configuration called \"metadata-complete\" \nwas set to true, unintentionally allowing users to \"bypass intended access restrictions\" \nthrough HTTP requests.\n","mistakes":"This mistake seems mostly to be a maintainability issue in the project. The reason I say this is because\nthe vulnerability was introduced from a fix of two completely seperate issues in combination with some old logic.\nGiven that the code can produce unexpected new problems from other bug fixes leads me to beleive that this code\nis difficult to maintain, especially given the size and number of contributors on the prject. \n"},{"id":1757,"cve":"CVE-2011-1184","project_name":"tomcat","description":"Attackers can look at all the messages being sent between the server and client, and get \nautheticated information. Then the attacker can use it by repeatedly sending the server the \ninformation. The server at this moment would authenticate the attacker because the message sent\nhas the correct username and password. The server should have seen the message was used already or \nold and dropped the message. In this case the server will give the attacker autheticated privlidges. \n","mistakes":"I think this problem comes down to a coding mistake. So it seems that\nnonce is usually sent and authenticated by default in security libraries. The \ndeveloper went around it and did not implement the functionality. This could \nalso be a design mistake because when the design of the authentication was planned\nthis idea of nonce never came up. We can tell it never came up because they added \na full function to check the nonce. But in the end this is a fix to the problem, \nsince the user will never be able to reuse an authenticated message. \n"},{"id":1758,"cve":"CVE-2011-1475","project_name":"tomcat","description":"HTTP piplining is not handled properly in this Apache Tomcat version. This\ngives remote attackers the ability to read responses intended for other\nclients and examine the application HTTP packets.\n","mistakes":"It seemed that this mistake was the result of simple coding mistakes.\nI personally believe that certain Agile methods of programming (like paired\nprogramming) and proper testing could have easily fixedthis issue before it\nstarted. It was interesting to see how a simply misplacing some processor\ncalls, and how leaving out some try catch blocks that should be implemented,\ncould leave a sufficiently sized vulnerability.\n"},{"id":1759,"cve":"CVE-2011-1582","project_name":"tomcat","description":"","mistakes":null},{"id":1760,"cve":"CVE-2011-2204","project_name":"tomcat","description":"In Apache Tomcat, you can use a MemoryUserDatabase to load defined users, groups,\nand roles into an in-memory data structure. The way Tomcat has implemented this\nfunctionality is through an MBean from Java Management Extensions (JMX). JMX is\na built-in Java technology that provides an architecture for dynamically\nmanaging resources by making the overall system more configurable. In this\ncontext, an MBean is a \"managed bean\" and is being used to represent an in-memory\ndatabase of users, MemoryUserDatabaseMBean. In older versions of Tomcat, when\nusing a MemoryUserDatabase to create users, an unauthorized local user can access\nsensitive user information (e.g. passwords) in local logs. This is because\nsensitive user data is not filtered out when logging error information. In fact,\nthe entire User object is being written to the log file in the event of a runtime\nerror. As a result, a malicious local user can obtain sensitive information by\ncausing a runtime error and then reading the log file. Though this vulnerability\nonly discloses sensitive information in logs on the server-side, if an attacker\nwere able to gain local file access to the server through some other means or if\nthey were able to exploit some other Tomcat file-reading vulnerability, they could\nfeasibly read from that log file and have unauthorized access to that sensitive\nuser information.\n","mistakes":"In my opinion, the mistake made here by the developer was a very simple and\nstraightforward coding and requirements oversight. Generally when logging,\nyou as a developer want as much useful information as possible to help you\ndebug. As such, it's likely the developer assumed it would be fine to write\nthe entire User object to log in the event of a runtime error, instead of\nonly writing out the username. I mean, how often would this exception be\nthrown? Who would even try to read the logs other than the developers? Who\nwould know to look? The developer likely did not think of these possibilities\nand went with the conceptually simpler \"print the whole object\" approach\ninstead of taking the time to consider logging only the information needed.\n"},{"id":1761,"cve":"CVE-2011-2481","project_name":"tomcat","description":"","mistakes":null},{"id":1788,"cve":"CVE-2014-0095","project_name":"tomcat","description":"If Content-Length is explicitly set to 0 in a particular type of request, the\nthread handling that request will hang.\n","mistakes":"As far as I can tell, this vulnerability is triggered by normal use of the\nsystem, not abuse or even misuse of it. It can simply manifest in normal\nuse, and it happens to be an accidental DOS. Thus, better application of\nsecurity checking would quite possibly not have prevented, discovered, or\nfixed the vulnerability.\nI can only see two mistakes here. The first is that the case of content\nlength being zero was apparently not correctly checked in the VCC. The\nsecond, and in my opinion more interesting, mistake is that a unit test for\nthat case was never made. While the first mistake is just a standard coding\nerror that's mostly unavoidable, the second seems like it was an important\ndetail that was overlooked. Perhaps a code review would have caught this\nmistake.\nThere are two preemtive mitigations for the CWE that could have been\nhelpful. If implemented, \"ensure that the program fails gracefully\" or \"use\nsystem limits\" would make the error more noticable while also making it not\nconsume an entire thread. It would still result in a bug that would need to\nbe fixed, but that bug would not be an exploitable DOS vulnerability.\n"},{"id":1762,"cve":"CVE-2011-2526","project_name":"tomcat","description":"Apache Tomcat 5.5.x before 5.5.34, 6.x before 6.0.33, and 7.x does not validate certain request attributes, which allows local users to bypass intended file access restrictions or cause a denial of service (infinite loop or JVM crash) by leveraging an untrusted web application.","mistakes":"Lack of input sanitization that didn't get caught for a while since it was an edge case."},{"id":1763,"cve":"CVE-2011-2729","project_name":"tomcat","description":"Jsvc is an abstraction layer that allows Java applications to run on UNIX more easily.  The vulnerablity in this service can allow applications to access files belonging to superuser (this could be password files, superuser logs, sysystem configuration, etc.).","mistakes":"The requirements for the wrapper were not clearly specified.  Had they been, proper unit tests could have been developed. The requirements should have the wrapper inputs and outputs and their associated data types and ranges. The requirements should also include how error are handled. The unit tests could include that type safety was guaranteed. The unit test could inject a broad range of bad data and bad data types to ensure that there are no unexpected behaviors. Bad data could include bad data types, out of range values, pointers that point to other sections of memory or routines, encapsulated programs, and malware."},{"id":1764,"cve":"CVE-2011-3190","project_name":"tomcat","description":"Certain versions of Apache Tomcat are vulnerable to a data breach, due to a lack\nof input sanitation when processing requests through AJP protocol connectors. An\nattacker can create another request within an existing message body, allowing them to\nbypass authentication. This occurs specifically when debug mode is enabled.\n","mistakes":"The developer did not test the code against edge cases that may put the system into an invalid state, which ultimately caused a design mistake"},{"id":1765,"cve":"CVE-2011-3375","project_name":"tomcat","description":"","mistakes":null},{"id":1766,"cve":"CVE-2011-3376","project_name":"tomcat","description":"Tomcat includes a component that provides administrative functions for\nweb applications such as deployment, reloading, and starting/stopping an\napplication called Manager.  Manager did not restrict untrusted web apps'\nability to access its servlets.  This allowed untrusted applications to\nuse the functionality of the Manager application to do things like run and\ndeploy additional applications without the consent of the server owner.\nThis vulnerability is primarily a concern for environments such as shared\nhosting, where clients' web applications are not considered trusted.\n","mistakes":"This vulnerability seems to be ultimately a design flaw in how the affected\nclass was designed.  Because it did not include any checks to ensure\napplications access it were trusted, there was no mitigation\nservers administrators could perform to resolve it and users of a shared\nhosting environment could execute arbitrary actions in the Tomcat Manager\nwithout any impediment.\n\nThis fix for this vulnerability appears to work as intended, as the code is\nnow creating a trust boundary for access between \"trusted\" and \"untrusted\"\napplications by explicitly checking the trust status of web applications.\n"},{"id":1767,"cve":"CVE-2011-5062","project_name":"tomcat","description":"","mistakes":null},{"id":1768,"cve":"CVE-2011-5063","project_name":"tomcat","description":"","mistakes":null},{"id":1769,"cve":"CVE-2011-5064","project_name":"tomcat","description":"","mistakes":null},{"id":1770,"cve":"CVE-2012-0022","project_name":"tomcat","description":"Apache Tomcat (An open source implementation of the Java Servlet) 5.5.x did not use a proper approach for handling a large number of parameters. There was no limit to the size of a request so attackers could utilize this to cause a denial of service via requests that contained many parameters which in turn caused a large amount of CPU to be used. The vulnerability was handled by making Tomcat parameter handling code efficiently process large numbers of parameters and parameter values.","mistakes":"From what I have seen, it seems like a design mistake led to this vulnerability. It appears that when created, the original code did not account for the possibly of large/excessive parameters.This could be due to the fact that the developer never anticipated that their system could be abused in such a way. I also found it interesting that the vulnerability was found from investigating another vulnerability. This shows that it is important to consider how 1 vulnerability may be applied or affect another part of a system."},{"id":1771,"cve":"CVE-2012-2733","project_name":"tomcat","description":"","mistakes":null},{"id":1772,"cve":"CVE-2012-3439","project_name":"tomcat","description":"This entry involved several issues that allowed the authenticator to be bypassed.\nPrior to the fix, client nonces (random number issued for authentication) were \ntracked instead of server nonces, allowing attackers to bypass authentication by \nreusing valid requests. Replay attacks (attacks where valid requests are repeated \nor delayed) were made possible because the system cached information about the\nuser in the sessision state and did not check for correct credentials and stale\nnonce values. \n","mistakes":"This vulnerability was most likely made due to a design mistake. This is \nan exploit with a high probability of occurrence and should have been considered\nin the design of the architecture. The mitigations listed suggest utilizing\nsequences or time stamping along with a checksum to ensure messages are only\nparsed once. The fix addresses this by using server nonce values instead of client\nnonce values as well as checking for stale nonce values and forcing reauthentication.\nThe fix appears complete in addressing all problem areas where the exploit can occur.\n"},{"id":1773,"cve":"CVE-2012-3544","project_name":"tomcat","description":"","mistakes":null},{"id":1774,"cve":"CVE-2012-3546","project_name":"tomcat","description":"","mistakes":null},{"id":1775,"cve":"CVE-2012-4431","project_name":"tomcat","description":"","mistakes":null},{"id":1776,"cve":"CVE-2012-4534","project_name":"tomcat","description":"","mistakes":null},{"id":1777,"cve":"CVE-2012-5568","project_name":"tomcat","description":"","mistakes":null},{"id":1778,"cve":"CVE-2013-1571","project_name":"tomcat","description":"","mistakes":null},{"id":1779,"cve":"CVE-2013-2067","project_name":"tomcat","description":"","mistakes":null},{"id":1780,"cve":"CVE-2013-2071","project_name":"tomcat","description":"The vulnerability stemmed from a lack of exception handling. \n\nSome objects would like to be notified when an event occurs and are therefore\n\"listening\" for an event. In the situation where one of these listeners threw\na runtime exception, the web request associated with the event would not be\nproperly recycled as it should be. This resulted in subsequent requests having\ninformation from that previous request. Such information is then present \nwhere it should not be available.\n","mistakes":"The mistake here was overlooking the potential for an asynchronous listener\nimplementation to throw a runtime exception. When the error handling was\nimplemented over the course of two commits, the only expected error was\nan IOException. This handling proved to be too narrow.\n\nFrom the discussion on the bug report, it is clear the implementer does not\nbelieve an asynchronous listener should ever throw a runtime exception. \nHowever, tomcat should protect against it in the case that an application\nchooses to do so.\n\nThe assumption of no runtime exceptions being thrown led to unexpected\nbehavior within tomcat. This behavior ultimately created a security\nvulnerability in the form of a leak of information.\n"},{"id":1781,"cve":"CVE-2013-4286","project_name":"tomcat","description":"","mistakes":null},{"id":1782,"cve":"CVE-2013-4322","project_name":"tomcat","description":"","mistakes":null},{"id":1783,"cve":"CVE-2013-4444","project_name":"tomcat","description":"This vulnerability allows attackers to upload and execute JavaScript programs\non a Tomcat server. The Tomcat security team views this vulnerability as\nimportant rather than critical because the circumstances required for it to\noccur are limited.\n\nThe implementation allowed unrestricted reading of files. It was not obvious\nthat files were checked for scripting. This may allow remote code execution by\nattackers using JavaScript files.\n","mistakes":"Even after doing the research, it is not very clear what happened that\nlead to this vulnerability other than not checking for edge cases that\nmight cause vulnerabilities such as outdated versions of languages and\nframeworks that might not be compatible with software being built.\n\nIn addition, it's interesting that the fix wasn't focused on fixing the issue\nbut instead it was an overall \"code cleanup\" that included the fix.\n"},{"id":1784,"cve":"CVE-2013-4590","project_name":"tomcat","description":"","mistakes":null},{"id":1785,"cve":"CVE-2014-0033","project_name":"tomcat","description":"","mistakes":null},{"id":1786,"cve":"CVE-2014-0050","project_name":"tomcat","description":"A software package offered by Apache Tomcat for hosting websites allowed attackers to consume near 100% of the host's CPU, creating a Denial of Service attack. This exploit involved an attacker crafting an HTTP Content-Type header when uploading a file to the server. Changing the boundary to be more than 4091 caused the system to enter into an infinite loop.","mistakes":"The mistake that led to this vulnerability likely occured during implementation. Looking at the code, the implementation failed to fulfill the design. During implmentation an edge case was missed in their software packages.\nThe fix was generally easy to make once it was identified, but for a time the vulnerabilty was present in their software.\nIn order to prevent a mistake like this from occuring in the future, Apache should invest in testing edge cases more often."},{"id":1787,"cve":"CVE-2014-0075","project_name":"tomcat","description":"","mistakes":null},{"id":1789,"cve":"CVE-2014-0096","project_name":"tomcat","description":"","mistakes":null},{"id":1790,"cve":"CVE-2014-0099","project_name":"tomcat","description":"","mistakes":null},{"id":1791,"cve":"CVE-2014-0119","project_name":"tomcat","description":"","mistakes":null},{"id":1792,"cve":"CVE-2014-0160","project_name":"tomcat","description":"","mistakes":null},{"id":1793,"cve":"CVE-2014-0227","project_name":"tomcat","description":"","mistakes":null},{"id":1794,"cve":"CVE-2014-0230","project_name":"tomcat","description":"","mistakes":null},{"id":1795,"cve":"CVE-2014-7810","project_name":"tomcat","description":"","mistakes":null},{"id":1796,"cve":"CVE-2015-5174","project_name":"tomcat","description":"","mistakes":null},{"id":1797,"cve":"CVE-2015-5345","project_name":"tomcat","description":"","mistakes":null},{"id":1798,"cve":"CVE-2015-5346","project_name":"tomcat","description":"","mistakes":null},{"id":1799,"cve":"CVE-2015-5351","project_name":"tomcat","description":"Apache Tomcat includes a web application called the Manager. This tool is used to deploy new web applications, to undeploy currently deployed web applications, to reload existing web applications, and to perform other operations to change and monitor the availability of the user's web applications.\nAnother web application included in Apache Tomcat is the Host Manager. The Host Manager is used to manage the different virtual hosts (server-sharing wesites) on the user's Tomcat server.\nCVE-2015-5351 refers to a vulnerability in the Manager and Host Manager web applications. An unauthenticated user attempting to accessing the index page of either of these web applications would be issued a redirect from the server with a valid CSRF token. An attacker may use this token to send requests to the web application which would have been considered invalid without the token's inclusion.\nIt is worth noting that because these applications are intended for managing the user's apache server, they are not usually exposed to the internet.","mistakes":"No changes were made to the file housing the vulnerability in the time between its introduction and its correction. When the vulnerability was finally fixed, it was done by the same person who had introduced it 5 years prior. It seems like one of the issues that may have lead to this bug was lack of eyes on the code. When a component does not have many maintainers, and when those maintainers do not interact with it often, any bugs it contains are likely to last a long time.\nThis bug is also a good illustration of the damage caused by a technology not being \"secure by default\" - in this case, JSPs which create a session with the client by default, regardless of whether one is needed."},{"id":1800,"cve":"CVE-2016-0706","project_name":"tomcat","description":"","mistakes":null},{"id":1801,"cve":"CVE-2016-0714","project_name":"tomcat","description":"","mistakes":null},{"id":1802,"cve":"CVE-2016-0762","project_name":"tomcat","description":"","mistakes":null},{"id":1803,"cve":"CVE-2016-0763","project_name":"tomcat","description":"A method that set the global context of the system was publicly available to be called from a web appliction, and could potentially set a malicious global context.","mistakes":"I think that this was simply an oversight. They likely ran into a scenario where they wanted to complete this action without authentication. So rather than do the legwork and properly authenticate, instead all authentication for the function was stripped out. I'd classify this as a coding mistake or a design mistake, not in the sense that it was a literal typo, but rather the system wasn't critically thought about. Security should not be an after-thought, and the scope of setting something called the global context should set off some alarm bells I'd hope."},{"id":1804,"cve":"CVE-2016-3092","project_name":"tomcat","description":"The multipart stream area of the system doesn't check the length of a boundary string. This\nmeans that a user can potentially use an extremely long boundary string to cause a denial of\nservice attack.\n","mistakes":"I think this was a coding mistake because, when getting string input, it is good\npractice to check the length of the string to make sure that it won't cause any\nproblems. I think the fix looks proper because it sets the buffer size to the\nboundary length times two if the boundary string is too large. This helps to prevent\nthe DoS vulnerability. I think that another good fix would have been to not\ndirectly append prefixes.\n"},{"id":1805,"cve":"CVE-2016-3427","project_name":"tomcat","description":"","mistakes":null},{"id":1806,"cve":"CVE-2016-5018","project_name":"tomcat","description":"","mistakes":null},{"id":1807,"cve":"CVE-2016-6794","project_name":"tomcat","description":"","mistakes":null},{"id":1808,"cve":"CVE-2016-6796","project_name":"tomcat","description":"","mistakes":null},{"id":1809,"cve":"CVE-2016-6797","project_name":"tomcat","description":"","mistakes":null},{"id":1810,"cve":"CVE-2016-6816","project_name":"tomcat","description":"","mistakes":null},{"id":1811,"cve":"CVE-2016-6817","project_name":"tomcat","description":"The HTTP/2 header parser was found to have entered an infinite loop if a header \nwas larger than the available buffer. This means a denial of service attack is possible.\n","mistakes":"In my opinion, this was a coding mistake. This specific vulnerability is based off an edge-case that, at the time, \ndevelopers did not think would ever occur. The founder of the vulnerability, barney2k7, discovered \nsuch edge case when trying to parse a header of about 30kb. The fix of this vulnerability involves \nincreasing the buffer size if the capacity were to be less than the size of the header. The CWE entry for this \nhas mitigations which the fix follows. The fix checks to make sure if the size is larger than the capacity \nand if it is, increase the capacity. \n"},{"id":1812,"cve":"CVE-2016-8735","project_name":"tomcat","description":"","mistakes":null},{"id":1813,"cve":"CVE-2016-8745","project_name":"tomcat","description":"","mistakes":null},{"id":1814,"cve":"CVE-2016-8747","project_name":"tomcat","description":"A regression was introduced when a Java class was refactored to use the standard ByteBuffer class rather than a byte array. The issue is in the cleanup code which prepares the buffer for the next HTTP request. Because of faulty cleanup logic, some information could leak between HTTP requests.","mistakes":"This is a coding mistake that resulted during a refactor from using a regular java array with the byte type to the ByteBuffer that was introduced in Java 7. There does seem to be sufficient justification for the change, as ByteBuffer has significant performance-enhancing features. Unfortunately, this seems to be a case where the developer was not well versed in the new technology before performing the refactoring. This is hinted to by follow-up commits from the same author. The author attempted to 'drop-in' the new code in place of the old but did not notice that subsequent operations were required to manipulate the ByteArray class pointers.\n"},{"id":1815,"cve":"CVE-2017-12615","project_name":"tomcat","description":"By adding a '/' onto the end of the file extension for apache tomcat, you can bypass the \nfile extension checks; therefore leaving a gap to exploit the vulnerability - the server would\nrun the code in the file that was appended.\n","mistakes":"In my opinion, there was a big coding and design mistake. When they were designing the \nsystem they should have planned for the impact that having an attack in one portion of the code\nwould not impact all portions. They should also have sanitized the urls and input so that a file \ncould not be put into the url; if the input would have been sanitized, it would have prevented this.\nThis was a very simple and fixable mistake in the code. \n"},{"id":1816,"cve":"CVE-2017-12616","project_name":"tomcat","description":"The use of the class VirtualDirContext, which is intended to expose\nmultiple directories of the filesystem under a single webapp, made it possible for\nan attacker to insert a specially crafted request that would enable them to bypass\nsecurity constraints and view the source code for JavaServer Pages.\n","mistakes":"Not enough testing to be able to catch the unexpected behavior. The fix\nis just to upgrade to the latest release, which seems like a reasonable\nsolution since the vulnerability patch requires at most a minor release\nupgrade. The thing that made this vulnerability particularly bad is that\nsince it gave access to source code it opened the JSPs to further attacks.\n"},{"id":1817,"cve":"CVE-2017-12617","project_name":"tomcat","description":"This was a vulnerability that affected people who used Apache Tomcat versions 70, 80, 85, and 90.\nThe vulnerability allowed people to upload a Java Server Page (JSP) file to a server if the Java servlet had HTTP put enabled and had a setting called readonly set to false. A JSP file is written in Java and it allows the web server to execute the code to produce HTML that the user sees. The file is only able to get uploaded to the servlet if it is sent through a specially crafted request.\nUsers who request that file intentionally or unintentionally will cause the server to execute the code on the JSP file which can be malicious.","mistakes":"I wouldn't really call it a mistake, but I find it strange that there is a setting for the readonly parameter since most, if not all, people would want it be set to true. I am guessing that it was relevant in the past and they need to maintain that setting for previous technologies. I would say this is a form of miscommunication since the people who are exposing themselves to this exploit don't have a complete understanding of what the settings do.\nThe lesson to be learned here is to always review the code when introducing new systems and to update documentation so that users can understand what each configuration does even if it may be considerd old or not as relevant."},{"id":1818,"cve":"CVE-2017-15706","project_name":"tomcat","description":"The documentation of the algorithm used by a module in the (Common Gateway Interface) Servlet did not match the existing functionality. This could cause some scripts to not execute as expected and caused other scripts may have been executed unexpectedly. This was caused by a previous fix to a bug in mapping requests to script paths where the documentation was updated incorrectly.","mistakes":"The biggest mistake seems to be simply not proofreading of the documentation to check if the documentation matches the functionality of the system. Rewriting the documentation is a quick and complete way of fixing this issue."},{"id":1819,"cve":"CVE-2017-5647","project_name":"tomcat","description":"","mistakes":null},{"id":1832,"cve":"CVE-2018-8034","project_name":"tomcat","description":"","mistakes":null},{"id":1820,"cve":"CVE-2017-5648","project_name":"tomcat","description":"While investigating bug 60718, it was noticed that some calls application listeners did not use the appropriate facade object. when running an untrusted application under a security manager, it was possible for that application to retain a references to the request or response objects and thereby acces or modify information associated with another web application.\nIn the error page mechanism in Tomcat's Default servlet. A crafted HTTP request could cause undesired side effects, possibly including the removal or replacement of the custom error page.","mistakes":"The major mistake that led to this vulnerability was design mistake that was exposes a resource to the wrong control sphere, providing unintened actors with inappropriate access to the resource. Resources such as files and directories may be inadvertently exposed through mechanisms such as insecure permissions, or when a program accidentally operates on the wrong object."},{"id":1821,"cve":"CVE-2017-5650","project_name":"tomcat","description":"This CVE describes a Denial of Service attack done through the network via malicious HTTP requests, which are responsible for enabling communication between the client and the server. More specifically, the flaw can be encountered in the HTTP/2 GOAWAY frame. This component is responsible initiating shutdowns betweeen connections. This was exploited because its associated streams that were waiting for closure before allowing the application to write more data. These waiting streams each consumed a thread. Therefore, an attacker could generate a DoS attack through a malicious client that constructed a series of HTTP/2 requests that would consume all available processing thread, thus bringing the system down.","mistakes":"This vulnerability could have been easily avoided by doing proper penetration testing and making sure to evaluate all the different edge cases and applications for this software. It is imperative for software of this caliber to have a security design that avoids this kind of attacks. Thankfully, the fix involved few lines of code that addressed the issue without any further concerns. A more strict testing approach would have avoided this issue."},{"id":1822,"cve":"CVE-2017-5651","project_name":"tomcat","description":"This vulnerability occurs when a http request results in a send file action.\nThe mistaken removal of the http processor cleanup step during refactoring,\nmakes it possible for a http processor to be re used for another request.\nThis could result in a user receiving a response intended for another user,\npotentially disclosing confidential information.\n\nWhen a request is received resulting in a send file action, an http processor\nis popped from a cache. Another thread then completes the send file action\nand pushes the http processor back into the cache. Milliseconds later, the\nthread that popped the http processor pushes it back into the cache, causing\nthe same http processor to be in cache twice. This may lead to unexpected errors\nor a response mixup which may disclose priviliged information.\n","mistakes":"This vulnerability was an oversight in terms of not preserving program\nbehavior during refactoring. The http processor recycle step was mistakenly\nforgotton in the VCC and then reimplemented in the fix. Considering the use\nof concurrency, extra caution should have been taken during refactoring.\n"},{"id":1823,"cve":"CVE-2017-5664","project_name":"tomcat","description":"","mistakes":null},{"id":1824,"cve":"CVE-2017-6056","project_name":"tomcat","description":"","mistakes":null},{"id":1825,"cve":"CVE-2017-7674","project_name":"tomcat","description":"Apache Tomcat does not add an HTTP Vary header with an Origin parameter to\nCORS responses, which could result in a \"cache poisoning\" attack where one\norigin could manipulate the cached response for another origin.\nWhen responding to Cross-Origin Resource Sharing (CORS) requests, Apache\nTomcat did not add an HTTP Vary header to the response that would indicate\nthat the response could be different based on the Origin header in the\nrequest. Since CORS requests can be made from multiple different origins, the\nserver could have a different response based on the origin that is making the\nrequest. For example, if the resource being requested is an image with text\nin it, the image returned in the response may be different for French and\nEnglish versions of the page. These different versions could be served at\ndifferent origins, such as www.example.fr or www.example.com.\nIncluding the Vary header in the CORS response tells a caching server that it\nneeds to cache different responses based on a specific parameter - in this\ncase, the content of the Origin header in the request. Without the Vary\nheader, a caching server will only cache a single response for all the\norigins. This will allow anyone making a request from one origin to load an\ninvalid response into the cache for all users from all other origins.\n","mistakes":"The major mistake that led to this vulnerability is a design error. When\nadding the new filter, the author did not consider the use of the Vary\nheader to make sure caching servers interacted with the server properly.\nThis oversight can be seen in the original Bugzilla report requesting a\nCORS filter be added (https://bz.apache.org/bugzilla/show_bug.cgi?id=55046)\nand in a linked diagram showing the operation of the CORS filter\n(https://bz.apache.org/bugzilla/show_bug.cgi?id=55046).\nWhile some bugs are difficult to find because of complex code, this bug was\ndifficult to find because of complex systems. In this case, multiple\ndifferent systems had to interact together in an architecture that the\nauthors may not have originally considered or intended.\n"},{"id":1826,"cve":"CVE-2017-7675","project_name":"tomcat","description":"This vulnerability involves the processing of an HTTP request\nwhere one of the path parameters is a URL with the ability to traverse outside\nof the folder where the module is pointing, depending on the URL string that\nthe user passes to the server.\n\nThis ultimately happens because, for that particular parameter (and maybe\nothers) a number of existing security checks were skipped over in the\nimplementation. \n","mistakes":"Based on the comments surrounding the original implementation, as well as\nthe brief history of commits revolving around the chunk of code containing\nthe vulnerability and the lack of targeted unit tests; this vulnerability\nwas most certainly caused by a lack of proper risk assessment. \n\nWith a comment like \"This is almost certainly wrong and needs to be decoded\",\nit seems like this part of the code didn't receive the proper amount of\nattention to determine that it may lead to some vulnerabilities if not\nproperly tested. \n"},{"id":1827,"cve":"CVE-2018-11784","project_name":"tomcat","description":"When the default servlet in certain Apache Tomcat versions returned a redirect to a directory (e.g. redirecting to '/foo/' when the user requested '/foo') a specially crafted URL could be used to cause the redirect to be generated to any URI of the attackers choice. The lack of validation and sanitization of the URL left an opening for attackers to exploit. They could extend the url to form a URL of their own to which the user would be redirected.","mistakes":"Overall this was a coding mistake and specifically an err in assumptions. It was a pretty simple fix which shows that it was something that could've been avoided had more extensive tests been written and/or executed."},{"id":1828,"cve":"CVE-2018-1304","project_name":"tomcat","description":"","mistakes":null},{"id":1829,"cve":"CVE-2018-1305","project_name":"tomcat","description":"Security constraints were only applied once a Servelet was loaded. That means \nthey were applied only to the URL pattern. So depending on the order the Servlets\nwere loaded you could cause some constraints to not be applied. This then leaves \nopen holes for exploits such as elevated privilege. You instead need the Servlets\nto all load first so all the security constraints are taken care of. \n","mistakes":"It seems their issue was both a design mistake and a bit of an oversight on \ntheir part. Initally back in 2010 they believed they wanted to be able to\ndeploy servlets at different times. This still is true. But what they didn't\nthink was that in the future the servlets would have secuirty constraints placed\non them and this order would be exploitable. They mitigated this risk by forcing\nthe servlets to run their security checks on web application start instead of on\ntheir own time. This solution seems wise to me. Now the timing doesn't really matter\nbecause it is all happening before the application launches. \n"},{"id":1830,"cve":"CVE-2018-1336","project_name":"tomcat","description":"Use of supplementary characters, such as those found on certain international keyboards, \ncan lead to overflow causing an infinite loop. This then causes denial of service.\n","mistakes":"This was an implementation mistake. CWE-153 says that all characters should\nbe manipulated to \"ensure only valid, expected and appropriate input is \nprocessed by the system\". The fix looks proper, it looks like rather than\nmanaging characters they are managing the overflow caused by the characters.\nI would say this falls under the \"expected\" portion of the mitigation advice.\n"},{"id":1831,"cve":"CVE-2018-8014","project_name":"tomcat","description":"","mistakes":null},{"id":1833,"cve":"CVE-2018-8037","project_name":"tomcat","description":"If an async request was completed the same time as the async timeout,\na race condition existed that could result in a user seeing a response intended for a different user.\nAn additional issue was present in connectors that did not correctly track the \nclosure of the connection when an async request was completed by the application and timed out by the container at the same time.\nThis could also result in a user seeing a response intended for another user.\n\nThere essentially was a race condition where if the timeout and request were the same,\nundefined behavior and other responses would be observed\n","mistakes":"The coding mistake was not accounting for the undefined edge case where an async\nrequest was completed at the same time as an async timeout.\nThe fixes are proper and account for async behavior.\nIt is interesting that most of the code for this bug/bug fix and the surrounding code\nis written by one man. He must of missed this condition. Making sure that other async code that exists\nin tomcat covers the async race condition is crucial to prevent similar bugs in the future.\n"},{"id":1834,"cve":"CVE-2010-1870","project_name":"struts","description":"This vulnerability allows remote attackers to modify server-side context objects.\nThis is allowed through a permissive whitelist for HTTP parameters, which are\nconverted to Java code using an open-source Expression Language. The whitelist\ndisallowed \"#\", which is a sensitive character for context variables. The issue\nwas that the whitelist did not account for the Java unicode representation of \"#\",\n\"\\u0023\".\n","mistakes":null},{"id":1835,"cve":"CVE-2011-1772","project_name":"struts","description":"Multiple vulnerabilities allowed attackers to execute XSS attacks, executing potentially harmful outside scripts by using an input that contains an existing action or method name.","mistakes":"Request parameters were used to dynamically generate an action name but were not being escaped, and when raw input is parsed into code in this way it leaves attack vectors very open to vulnerabilities.  In addition, this was a bug in the underlying XWork code added to the system, and that code should have been thoroughly tested and analyzed for vulnerabilities before it was added into the project."},{"id":1836,"cve":"CVE-2011-3923","project_name":"struts","description":"Apache Struts' ParameterInterceptor class did not properly handle specific \nuser supplied inputs from HTTP requests. The improper handling of requests \nallowed for a remote user to bypass security measures, and perform an exploit of \nthis vulnerability by using OGNL (Object-Graph Navigation Language) expressions \nto modify server-side resources and potentially run arbitrary Java code on the \ntarget system.\n","mistakes":"I feel as if the mistakes that were made that led to this vulnerability\nwere based in coding. The developers simply forgot to handle an edge case,\nwhich was the presence of parentheses to construct and make OGLN \ncalls. The chosen CWE for this vulnerability (CWE-94) marks input validation\nand testing as a couple of the possible mitigations, and in the case of this\nCVE, the struts development team were already doing both, just not to the \ndegree that was required to handle this vulnerability. Tests existed for this\narea of the code and some other characters were also blacklisted from requests,\njust not the characters that were needed to fully elminiate the possbility of\nmalicious OGLN code execution.\n"},{"id":1837,"cve":"CVE-2012-4386","project_name":"struts","description":"The validation which checks tokens in Struts was insufficient, allowing\na malicious user to craft a CSRF attack by adding a token of their choosing\nto the URL. This token would then be saved to the system without any error\nchecking.\n","mistakes":"The thing that stuck out to me about this vulnerability is that the attack\nvector does not come from a user parameter. The attack occurs when a user\ntakes a value set by the developer (the name of a URL query parameter) and\nhijacks it, setting it to a new, specially-crafted value which creates a\nCross-Site Request Forgery. It is important to note that even though the\ndeveloper chooses query parameter names, these can be modified with a few simple\nkeystrokes in a browser's address bar, and so should also be validated.\n"},{"id":1838,"cve":"CVE-2012-4387","project_name":"struts","description":"Request parameters handled by Struts 2 are effectively treated as OGNL expressions,\nwhich may take some time to process if they're sufficiently complex. A possible DOS\nattacker might craft requests to a Struts 2 based application with extremely long\nparameter names. OGNL evaluation of the parameter name then will consume significant\nCPU cycles, thus promoting the effectiveness of the DOS attack.\n","mistakes":"This was caused by not properly validating user inputs that were being translated\nto complex expressions with the potential for exploitation, which I would classify\nas a coding mistake. As this is critical to the overall function of the application,\nextra care needed to be taken to handle these sensitive inputs, and a number of test\ncases should be written to test different scenarios, which is was completed. Aside\nfrom a redesign that treats these inputs differently, this was an appropriate solution\nto the problem.\n"},{"id":1839,"cve":"CVE-2013-1965","project_name":"struts","description":"The vulnerability was in the XWork core library of Struts 2. OGNL code--an expression \nlanguage which can get and set fields and call methods in Java--could be injected \nas a parameter name.  Although this was partially handled in earlier bug fixes \n(S2-003, S2-005, and S2-009), these fixes did not account for a specific case in \nwhich the parameter name could still be evaluated as OGNL code during a redirect, \na sort of double-evaluation.\n","mistakes":"The problem which caused this vulnerability was one of design. The conclusion \neventually reached was that OGNL evaluation in XWork core simply cannot easily \nbe implemented in a secure manner. After multiple attempts to sanitize input, \nthe solution was to just disable OGNL evaluation by default.\n\nAdditionally, the multiple attempts at fixes show that testing may not have \nbeen thorough enough to push those fixes to production. New edge cases kept \npopping up and requiring small adjustments until this final solution was \nreached.\n"},{"id":1840,"cve":"CVE-2013-1966","project_name":"struts","description":"URL requests containing parameters were not properly handled and sanitized.  \nThis allowed malicious code in the Apache Object Graph Navigation Language (OGNL) to be executed by typing commands in the URL parameters.\n","mistakes":"There were two major mistakes that likely led to this vulnerability being created.  First was importing the XWork files without fully considering what vulnerabilities they may create.  Second, the input through URL parameters, which are very easily modifiable, were not being properly sanitized, which allowed code to be executed very easily, which is a major problem in software systems."},{"id":1841,"cve":"CVE-2013-2115","project_name":"struts","description":"A specially crafted request parameter could be used to inject arbitrary\ncode, which could then be used as request parameter of a URL or anchor tag.\nThen the URL/anchor tag tries to resolve every parameter present in the\noriginal request. This lets malicious users put arbitrary statements into any\nrequest parameter and have it evaluated to enable method execution and execute\narbitrary methods, which bypasses any library protections. This vulnerability was\nintroduced as a partial fix to a previously identified bug.\n","mistakes":"This vulnerability was due to a fundamental flaw in the design of the url rendering\nsystem and the subsequent fix in 2.3.14.1 did not fully address all possible attack\nvectors. Rearchitecting the url rendering subsystem to not pass any vulnerable\nparameters and changing the allowStaticMethodAccess property to be immutable seemed\nto completely fix the original vulnerability reported in 2010.\n"},{"id":1842,"cve":"CVE-2013-2134","project_name":"struts","description":"By using wildcard matching (using a generic case that will match if a specific case is not provided),\nan attacker can execute (inject) Java code that is not in the source code.\n","mistakes":"I think that the mistake that was made here was the lack of consideration for unsanitized inputs.\nIf there was consideration for the fact that a wildcard action would allow for attackers to send in unsanitized and unmonitored inputs,\nthe developers would have coded more defensively to begin with.\nSo in short it was a design mistake to allow this layer of code to be directly interacting with inputs that were not sanitized.\nIn the design phase, a defense layer where inputs could get sanitized before being sent to the rest of the code should have been brought up.\n"},{"id":1843,"cve":"CVE-2013-2135","project_name":"struts","description":"Struts was not performing adequate input validation when mapping requests to controllers. \nIn certain configurations, when a request URL included crafted input in the form of the templating \nlanguage used by Struts (OGNL), it would be unintentionally evaluated as such. This evaluation \nallowed arbitrary Java code execution to occur.\n\nThis vulnerability was made possible by a lack of input validation and a \"double evaluation\"\nissue in the templating language parser.\n","mistakes":"The two issues involved in this vulnerability seem to fall under two different mistake categories.\nThe lack of input validation is likely a design issue in not considering dynamic inputs.\nThe double evaluation issue falls under a coding mistake, as it was made possible by an implementation error in the parser.\n"},{"id":1844,"cve":"CVE-2013-2248","project_name":"struts","description":"A vulnerability in struts allowed an attacker to use certain URL parameters with special\nmeanings, redirect and redirectAction, to set their value to any website and automatically\nredirect the user to that website. The vulnerability was fixed by removing code that performed\nthe redirect actions entirely\n","mistakes":"There was a design mistake in the actions, allowing redirects from URL parameters without\nrequiring any authentication is dangerous. Given that the solution was to entirely remove\nthe behavior, it could be said that they reduced the attack surface. It's noted that\nany user could reimplement the behavior on their own by copy-pasting the pre-fix code\ninto a custom action mapper class, so the vulnerability fundamentally still exists in the\nsystem. However, it is likely impossible to remove that behavior without disallowing desired\nfunctionality.\n"},{"id":1845,"cve":"CVE-2013-2251","project_name":"struts","description":"The 'action' and 'redirect' parameters were added to streamline navigation to buttons within forms. However, these methods took unsafe client side input and executed it without sanitization. This allows for a malicious actor to execute arbitrary Object-Graph Navigation Language (OGNL) expressions. This is a remote code execution vulnerability.","mistakes":"Inputs were not sanitized and defense in depth was not applied. This lead to remote code execution and is completely unacceptable. The developers introduced additional inputs to their previous code, yet no sanitization was done such as was done with previous inputs. In the future, developers can look at the security practices implemented in similar portions of their project, or in other projects."},{"id":1846,"cve":"CVE-2013-4310","project_name":"struts","description":"Struts 2 controls actions using a special prefix parameter in the body of some\nrequests. This information is then read directly without validation. Providing\nthe correct information for the prefix parameter can lead to bypassing security.\n","mistakes":"Security should have been addressed more in the design of mapping actions,\nspecifically considering cross site scripting vulnerabilities. This may\nhave been caused by a lack of security requirements, or miscommunication,\nsince other parts of struts already had implemented filtering mechanisms.\nTo prevent this from happening again, developers could standardize reviewing\ncode for cross site scripting vulnerabilities, or enforce security reviews \nfor relevant commits.\n"},{"id":1847,"cve":"CVE-2013-4316","project_name":"struts","description":"Struts 2 introduced a new feature called Dynamic Method Invocation (DMI). This\nallowed developers to call specific public methods by passing them through the\nurl after an exclamation point. This opened up the possibilty for users to call\nother methods by abusing this feature. Abusing this was as simple a modifying the\nurl of the request. \"http://example.com/route!method1\" would call the function\n\"method1\", while \"http://example.com/route!method2\" would call method2 instead,\nopening many other potential attack vectors. DMI is defaulted to on for Struts versions\n2.0.0 through 2.3.15.1. Users were not warned about the potential security risks\nof leaving this enabled.\n","mistakes":"A big mistake that contributed to this was defaulting a potentially insecure\nconfiguration option to be on. By defaulting Dynamic Method Invocation to on\nusers did not have a prior warning on what vulnerabilities this potentially\nintroduced. If this were to be defaulted to on, a whitelist should have been\nincluded by default, so users would still have to opt into the insecure option.\n"},{"id":1848,"cve":"CVE-2014-0050","project_name":"struts","description":"This vulnerability allows for an infinite loop to occur, meaning the program is thus vulnerable for\na DoS (Denial of Service) attack. The exploit would come in the form of sending an HTTP request with a Content-Type header\nwith an extremely high length.\n","mistakes":"I would say that this would be a coding mistake. In the implementation of this piece of code, the author had mentioned\nin the Git log that he had attempted to account for all of the \"sneaky boundary cases\". This goes to show just how\nsneaky they can be in that there was a bug stemming from input being above a certain length.\n\nThat said, it is difficult to blame this on the programmer, given that the vulnerability could only be exploited by an attack\nvector specifically meant to be strange and unlikely.\n"},{"id":1849,"cve":"CVE-2014-0094","project_name":"struts","description":"Apache Struts could allow a remote attacker to bypass security restrictions,\ncaused by an error in the excluded parameters accessable by user input. An \nattacker could invoke a specific method on a remote Java server by specifying\nit in a URL. All Java objects have a getClass() method that returns the object's\nclass which an unauthenticated attacker could access and manipulate into \ndisclosing private Class information or possibly load a malicious class file.\n","mistakes":"The mistakes here were reported as a design flaw and the maintainability of that\ndesign flaw. Over years of development the parameters that users were able to access\nchanged and with that the security measures ment to protect from user input must \nstay up to date to avoid allowing users to have access to unintended functionality.\nThe users should only be allowed to input parameters that they are intended to use and\nmore importantly all other parameters should be blocked from being accessed at unintended times.\n"},{"id":1850,"cve":"CVE-2014-0112","project_name":"struts","description":"The excluded parameter pattern intoduced in an earlier Apache version to block\naccess to a getClass() method wasn't detailed enough. Special requests could\nallow an attacker to circumnavigate this blocker. Also a \"CookieIntercrptor\"\nobject is vulnerable for the same kind of attack when configured to accept all\ncookies. This exists because of an incomplete previous fix.\n","mistakes":"The biggest issue of this vulnerability was that a previous vulnerability\nfix was not tested thoroughly. This vulnerability (CVE-2014-0094) was the\ncause of multiple other vulnerabilties afterward (CVE-2014-0112,\nCVE-2014-0113, CVE-2014-0114 just to name a few). This showed that there was\na lack of unit testing and acceptance testing in the addition of this bug\nfix. Thankfully, from researching, it didn't take long once these\nvulnerabilities were started to be finished. To ensure testing is done\nthoroughly in the future having multiple reviewers of code could be\nimplemented to put multiple eyes on fixes, and thus, increasing the chances\nof bugs like this being caught.\n"},{"id":1851,"cve":"CVE-2014-0113","project_name":"struts","description":"CookieInterceptor in Apache Struts, when a wildcard cookiesName value is used, does not properly restrict access to the getClass method, which allows remote attackers to \"manipulate\" the ClassLoader and execute arbitrary code via a crafted request.","mistakes":"This seems like an inherent design mistake when the CookieInterceptor class was created. You have to keep a clear idea of permissions to possibly private methods when writing code. A mitigation, besides updating to 2.3.16.2, is replacing the previous class related pattern with '(..|^|.|[('|\"))class(.|('|\")]|[).*' on the list of excludeParams. In the future, testing permissions as well as the code being effected could help to mitigate a possible repeat of the mistake."},{"id":1852,"cve":"CVE-2014-0116","project_name":"struts","description":"A fix applied in a previous update didn't account for the wildcard (*) operator.\nBy missing this operator in the appropriate blacklist for disallowed inputs, this \nallowed attackers to bypass the safeguards in place and craft exploits for the system.\n","mistakes":"The correct sanitization regex pattern was present in another class \n(ParametersIntercepter) but was reimplemented (incorrectly) in CookieInterceptor. \nThis is a code-smell (Duplicate Code) and suggests that there was a lack of\ndue diligance by the developer to search for pre-existing solutions, and that\nthey weren't communicating effectively with their team members. The issue went \nunnoticed in large part due to there not being robust unit tests for bad inputs.\nVulnerabilities like this can be prevented in the future by following principles\nlike DRY (Don't Repeat Yourself) and by creating extra tests as vulnerabilities\nare discovered.\n"},{"id":1853,"cve":"CVE-2014-7809","project_name":"struts","description":"Due to an ineffective random number generator, observing a previous authentication\ntoken allows for attackers to predict the next authentication token to effectively\nbypass the cross-site request forgery protections.\n","mistakes":"I would classify this issue as a simple coding mistake. The developers\nlikely went with a non-cryptographically secure random number generator\nout of habit or perhaps they just didn't realize the potential risk associated\nwith using a normal pseudorandom number generator. I also think that the fix was\nproper, this was a simple issue and a simple fix was used.\n"},{"id":1854,"cve":"CVE-2015-1831","project_name":"struts","description":"The issue with this CVE was the input validation, checking what the user types, in Apache version 2.3.20. Specifically the excludeParams function, when added, overrode patterens in another function called DefaultExcludedPatternsChecker,\nthis allowed attackers to input their own expressions to gain access to excluded classes and package names that could compromise the internal state of the appliction.\n","mistakes":"The problem was caused by poor design mistake. For Example, the choice to have the excludeParams function override those patterens in DefaultExcludedPatternsChecker was what caused the issue. It was most likely missed due to lack of oversight. Code reviews would've helped catch this issue."},{"id":1855,"cve":"CVE-2015-5169","project_name":"struts","description":"","mistakes":null},{"id":1856,"cve":"CVE-2015-5209","project_name":"struts","description":"The Struts server was not performing adequate input validation on request\nparameters.  This allowed a remote user to create a request referencing a\nobject that represents the root of the execution context.\n\nA remote user could use this root object to bypass security restrictions \nand perform remote code execution on the Struts server.  This includes \nmodifying the internal state of the target application, affecting container \nsettings, or altering user sessions.\n","mistakes":"The mistake made that led to this vulnerability was likely a requirements \nmisunderstanding or omission, as the actual code for input validation\nappears to work as expected. Since the processing of request parameters \nallows for access to critical application state, a cleverly-made request \ncould access and modify this state.  The fix made for this vulnerability\nlooks proper, and has additional unit tests to check for that specific\nvulnerability.\n\nIn the future, this could be prevented by designing the system to only allow\nreflection from HTTP parameters on those explicitly specified in the code,\nrequire parameters to conform to a framework-defined whitelisted format, or\nhave a well-defined blacklist that contains all critical objects that could\nbe accessed.\n\nAs of now, the project is performing both input validation as well as \nattack surface validation by knowing to check both request parameters as \nwell as cookies.\n"},{"id":1857,"cve":"CVE-2016-0785","project_name":"struts","description":"This vulnerability allows remote arbitrary code execution. Apache struts uses\na language called Object-Graph Navigation Language (OGNL). OGNL is an open\nsource expression language that allows for easy manipulation of properties.\nWhen setting default properies for Struts, one property was assigned multiple\ntimes. This forced Apache Struts to perform a double evaluation of the value\nattributes assigned to certain tags. This allowed remote attackers to send\ncrafted attribute data that would be evaluated twice. This allows execution of\narbitrary  code. The code would have the same system privileges as the\ntarget service.\n","mistakes":"There were a few mistakes that led to this vulnerability. The first one was\na simple coding mistake. A line of code was written twice on different\ncommits. When the duplicate line was committed, the author most likely did\nnot see the first line. It could be a copy-and-paste mistake as well. The\nsecond mistake was not sanitizing the attributes associated with the tags.\nThis is a design flaw. The fixes for this vulnerability do not appear to\nhave fixed this error.\n"},{"id":1885,"cve":"CVE-2018-1327","project_name":"struts","description":"The Struts Rest plugin uses a library called XStream for serialization and\ndeserialization of Java objects. The XStream library is vulnerable to DoS\nattacks when a malicious request is sent with a crafted XML file. This\nvulnerability affects Struts versions 2.1.1 to 2.5.14.1.\n","mistakes":"The mistake that the Apache Struts developers made was not fully distrusting\nand isolating a third party library. When ever you implement a library into\nyour project, you inherit all of the vulnerabilities that the library has. In\nthe future it is important that input from other libraries is properly\nvalidated and sanitized.\n"},{"id":1858,"cve":"CVE-2016-2162","project_name":"struts","description":"The Apache Struts framework uses I18NInterceptor to allow users and developers\nto switch language used in the framework and an application built on top of\nit. The problem is that the interceptor doesn't perform any validation of the\nuser input while accepting arbitrary strings which can be used by a developer\nto display language selected by the user. However, the framework doesn't\nexpose the value directly in UI. This means that the vulnerability is only\nexploitable if the developer explicitly puts the string from the Locale object\nonto the page.\n","mistakes":"This seems like a design issue, as the developer did not account for the\nmethod contracts of Java's Locale library. Since Locale doesn't perform\nvalidation automatically, and the developers also did not do so themselves,\nthe user input was left unchecked and carried through the rest of the\nprogram. This led any developer using Struts vulnerable to XSS if they\naccess the Locale object directly for UI code.\n"},{"id":1859,"cve":"CVE-2016-3081","project_name":"struts","description":"A remote user is able to execute arbitrary code on a targeted system. This is\npossible when Dynamic Method Invocation is enabled and performed through \n\"method: prefix\". This provides an attacker the ability to pass a malicious\nexpression into user input to gain access to the system due to the lack of \nsanitization. In this case, dynamic method invocation is when HTTP parameters\nare prefixed with \"method:\". In other words, an attacker can specify what method\nthe system should execute specified in the URL. This vulnerability is classified \nas high severity and can be solved by disabling dynamic method invocation when possible.\n","mistakes":"I think this vulnerability is the result of a design mistake. This vulnerability\noccurs when attackers execute a command that gives them a capability that they \notherwise would not have. An attacker submits a malicious expression to the system,\nand if successful, could execute arbitrary code through dynamic method invocation.\nFor this particular problem, disabling dynamic method invocation will solve the\nproblem. In general, a mitigation is to assume that all input is malicious and use \nan \"accept known good\" input strategy. Reject input that does not conform to specifications,\nor modify it into something that does.\n"},{"id":1860,"cve":"CVE-2016-3082","project_name":"struts","description":"The application allows for the parsing of arbitrary stylesheet when provided\nwith a path to the stylesheet. The implementation allowed this sheet location\nto be included as a parameter to an HTTP request. Using the parameter from the \nrequest as the path to the resource allowed for potential remote code execution. \n","mistakes":"This vulnerability appears to be the result of a security oversight when\nproviding a way for an HTTP request to pass the location of a stylesheet.\nThis kind of issue can be mitigated in the future by validating the document\ntype and content of uploaded files. In this specific case, the ability to\npass the file location in the HTTP request was determined to be unnecessary.\nAs such, the code that blindly used the path provided in the location\nparameter of the request was removed.\n"},{"id":1861,"cve":"CVE-2016-3087","project_name":"struts","description":"Instead of writing an \u003caction\u003e for every method, a user could map the '*'\ncharacter with a method name with the same suffix or prefix. When this was\nenabled it allowed remote attackers to execute arbitrary code via vectors\nrelated to the '!' operator to the REST plugin.\n","mistakes":"A mistake was made during implementation. The developer simply did not validate\nthat user input wasn't sequential. Because of this remote attackers were allowed\ntoexecute arbitrary code via vectors related to the '!' operatot in the REST plugin.\n"},{"id":1862,"cve":"CVE-2016-3090","project_name":"struts","description":"This type of attack is specifically targeting the flexible nature of Expression\nLanguages to inject and execute arbitrary code on a system.  Expression Language\nis a scripting like language that allows you to access java methods in a similar\nway that you would normally, i.e. with the \".\" syntax.  Apache has made an\nExpression Language that is mainly meant to access data within an object using\ngetters and setters called OGNL (Object Graph Navigation Language).  OGNL is\nbuilt off of a framework called ANTLR which is a parser that can help you create\nsimple languages.\nThe issue with OGNL and other such Expression Languages is that they are very\nflexible and are prone to injection attacks.  The place these types of languages\nare used most often is in templating languages like JSP. JSP allows you to use\nOGNL to access internal object data that can be injected in the HTML created by\nJSP.\nTypically, this isn't an issue for injection attacks, becaues user input does\nnot affect the templating languages (or anything else using Expression Languages),\nhowever it is possible for a developer to evaluate OGNL with some user provided\nvariables through string concatenation.  If this is done, the sanitization of the\ninput becomes very complicated and hard to determine what should actually be sanitized\nbecause the precise sanitization depends on the project.\nAlthough it is hard to find an example of the type of injection used in this vulerability,\nit has to do with the underlying ANTLR framework.\nOGNL is a very exploitable language if it is not used carefully, and it even played\ninto the equifax breach (CVE-2017-5638).\n","mistakes":"This issue that is presented is mainly an issue due to adding more classes / sensitive\ninformation in the future without remembering to update the list of sanitized inputs\nfor a method that access this information based on inputs.  This is overall, a design\nmistake.  The list of sensitive data should not be updated separately and isntead should\nbe maintained when the senstive data is added.\nA way to do this might be through the use of annotations, the list of sanitized data can\nbe automatically determined based off of annotated fields of the object being accessed.\nThis could be a great feature of OGNL, ignoring any fields (or getters/setters) that are\nannotated with a certain annotation, then the issue of sanitization might not even be\nan issue.  This may however not fix the issue since it is hard to know exactly what type\nof input caused this vulnerability in the first place, this is just based off of the new\nunit tests added in the fix.\n"},{"id":1863,"cve":"CVE-2016-3093","project_name":"struts","description":"","mistakes":null},{"id":1864,"cve":"CVE-2016-4003","project_name":"struts","description":"","mistakes":null},{"id":1865,"cve":"CVE-2016-4430","project_name":"struts","description":"This vulnerability is a cross-site request forgery vulnerability which can allow attackers\nto perform arbitrary code execution. The regular expression used to validate the URLS given by user input \nallowed multiple \"/\" characters to be present.\n","mistakes":"The culprit was a character that was commonly used for xsrf that was not properly denied in the URL. \nThis could have been lack of knowledge or a condition that the developer forgot about. The fix was proper as it limited the character to only be used in a certain way.\n"},{"id":1866,"cve":"CVE-2016-4431","project_name":"struts","description":"","mistakes":null},{"id":1867,"cve":"CVE-2016-4433","project_name":"struts","description":"A properly made request to Struts will allow an attacker to bypass permissions\nand conduct a redirection attack.\n\nA redirection attack is where the attacker can control where a page will\nredirect the user to. It may for example redirect them to a fake login page\nintended to harvest their username/password. The user is likely to trust this\nfake page, given they just came from a trusted page.\n","mistakes":"Looking at the fix I notice they're disallowing arithmetic expressions, so\nperhaps plus symbols were being expanded to spaces later for example,\ncausing issues. Looking into the test added at the fix commit it expects a\nmethod call of \"#booScope=@myclass@DEFAULT_SCOPE,#bootScope.init()\" to fail.\n\nGiven that this syntax appears to allow arbitrary method calls from a remote\nsource it seems like the use of it is a design flaw, as Apache will be\nforever plugging holes in this system. Instead the app should be required to\ndefine its input paths, instead of letting the client do whatever it wants.\n\nThe only real way I can think of to avoid this in the future is to not have\na feature like OGNL, instead just require the app to define its endpoints\nlike in a Spring app.\n"},{"id":1868,"cve":"CVE-2016-4436","project_name":"struts","description":"","mistakes":null},{"id":1869,"cve":"CVE-2016-4438","project_name":"struts","description":"An attacker can execute code in the application. It is possible by passing \na malicious expression. If it didn't work a denial of service would ensue.\nA malicious expression could be added by chaining the expression to another,\nthis means the code would try to execute one of the expressions but ends up\ndoing both.\n","mistakes":"This is an input validation error. It is an input validation error because a user can\nenter code to excute arbitraury code and failure with code can lead to a denial of service. This seems\nto be a classic case of improper input validation because of the lack of input sanitization. The code \ndid have input validation before but it didn't account for chained expressions. This could be avoided in\nthe future by testing a greater range of possible expressions.\n"},{"id":1883,"cve":"CVE-2017-9805","project_name":"struts","description":"CVE-2017-9805 is a security vulnerability that could allow the execution of\narbitrary code when XML is read into the system. When the vulnerable module\nreceived an XML payload, it does not properly validate it. This means that it\ncould receive a malicious payload that could execute arbitrary code.\n","mistakes":"This vulnerability was mostly a design mistake. The developer\ndid not consider that the input could potentially be malicious and could be\ndangerous when deserialized. As such, the XML handler did not properly\nvalidate the input before the deserialization occurs, leading to the\npotential execution of arbitrary code. The page for CWE-502 suggests\nvalidating the input before creating a new object to store the deserialized\ndata. The fix for this vulnerability involved 1) upgrading the dependancy\nused for XML deserializing but 2) creating a whitelist of allowed class\nnames. This whitelist validates that the input is trustworthy before\ncreating the object. If the class instance attempting to be created isn't\non that list of trusted class names, it is not created. It is interesting\nhow this vulnerability was found (a demonstration of a security service that\nautomatically queries open-source repositories for security vulnerabilities)\nand that it was very quickly fixed. They also didn't annouce the\nvulnerability before it was fixed, and there were no public bug reports or\nanything to signify that it existed. They were also missing security tests\nthat could've prevented this vulnerability from occuring in the first place.\n"},{"id":1884,"cve":"CVE-2018-11776","project_name":"struts","description":"This vulnerability allows remote code execution in the Apache Struts framework.\nAttackers can inject their own namespace as a parameter in an HTTP request. The\nattacker can inject any string that complied with Struts' Object-Graph\nNavigation Language. Struts' OGNL language allows the behavior of Struts to be\nhighly customizable. Apache 2 versions before 2.3.35 and 2.5.17 were affected by\nthis vlnerbility.\n","mistakes":"I believe the biggest lesson that can be learned from this vulnerability\nis to take caution when merging outside code with your own. You should\ndistrust this code like you would distrust any other library or framework\nyou use. This means understanding how the framework/library works\nvery well and/or putting trust boundaries between the merged code and your own.\nAfter discovering the vulnerability, I believe the the fix was done properly.\nThe fix properly sanitizes and validates the namespace which prevents any\ninjection from taking place.\n"},{"id":1870,"cve":"CVE-2016-4461","project_name":"struts","description":"This vulnerability stems from improper input validation within Apache Struts\nin relation to OGNL, more formally known as Object Graph Navigation Language.\nOGNL is an expression language used to access and mutate Java Object properties,\nas well as interact with other forms of metadata.\nIn this instance, OGNL's expression evaluation operator \"%{}\" can be used to force\ndouble evaluation of a Struts data object attribute. Double evaluation is when an expression string is\nevaluated as code such that its output is also evaluated as code. Without a defined base case, this\nprocess can recurse indefinitely.\nWith respect to Apache Struts, a malicious actor can provide a string containing \"%{}\" that,\nwhen evaluated at a later point in time, forces double evaluation. In the event a malicious actor\nencodes program instructions within their provided string input, this vulnerability allows for\narbitrary code execution within the system.\nIt is important to note that this vulnerability stems from an incomplete solution to a prior issue\nin Apache version 2.3.28, classified as S2-029 in Apache's wiki (CVE-2016-0785). \n","mistakes":"Overall, this vulnerability stems from failure to consider the security principle of \"secure by default\".\nFailure to consider malicious use of the OGNL language, especially when forcing expression evaluations \nusing \"%{}\" syntax, shows that adequate threat modeling was not done in preparation for integrating with this feature.\nLikewise, failure to account for potential malicious inputs when executing expressions signifies a lack of\nconsideration for the increased attack surface that results from complex inputs.\nConsidering the predecessor issue \"S2-029\" was supposed to be fixed in the version 2.3.28 release, the\nfact that the same issue re-appeared as \"S2-036\" proves a lack of understanding in regards to the core issue.\n"},{"id":1871,"cve":"CVE-2016-4465","project_name":"struts","description":"In APACHE Struts 2, there is the potential for a denial of service attack due to\nan unhandled exception. The vulnerability occurs in the built-in URL validator, \nwhen an attacker chooses to input a null value for the URL field, it will \ncause the server process to overload and crash due to the unhandled exception. \n","mistakes":"This was definitely a coding mistake. Whoever created the regular expression to attempt\nto sanitize the input for URLs just forgot (or wasn't able) to check for all possible \nimproper inputs. The CWE recommended mitigation for this vulnerability is to sanitize \nall incoming input strings so that they do not allow null bytes and/or null characters \nto get through. The trouble with this originally is due to the very complex nature of possible\nvalid URLs, meaning that creating a regular expression to check for all improper URLs is a \nfairly daunting task. To prevent this issue in similiar situations in the future, I would \nrecommend to create a list of all blacklisted symbols, phrases, and/or possible malicious\ninputs, then test each one against the created regex to verify it sanitizes the input correctly.\n"},{"id":1872,"cve":"CVE-2016-6795","project_name":"struts","description":"The URL provided by the user was not fully validated which could cause the server to let an attacker go to locations \nnot permitted to view and even inject code to execute remotely\n","mistakes":"This looks like a coding mistake. Validating a valid secure URL is hard, but something as checking ../../.. should one of the first things the teams should have checked before upadating the validator. I can tell from one other commit that code is merged to master without being fully checked (commit can be found in interesting commits section)"},{"id":1873,"cve":"CVE-2016-8738","project_name":"struts","description":"This vulnerability may overload the server process with a specially crafted\nURL. If a special URL is put in a form field and validated using Struts' built\nin URLValidator, the validation may cause a DoS. The URL validation is done\nusing regular expressions. This vulnerability affects Struts versions 2.5 to\n2.5.5. Checkout CVE-2017-9804 and CVE-2016-7672 for similar CVEs.\n","mistakes":"I believe the biggest lesson you can learn from this vulnerability is make\nsure your unit testing is complete. While complete coverage of every possible\ninput is impossible, testing should cover as much as possible. This is especially\nthe case when creating a fix. This vulnerability was not fixed completely and led\nto CVE-2017-7672 and CVE-2017-9804. You should always create new tests to make the\nfix was done correctly. Another lesson that can be learned is be careful with regex.\nWhile regex can be exremely useful, make sure you know exactly what it does. This\ncan be difficult if it becomes long, like in the case of URLValidator.\n"},{"id":1874,"cve":"CVE-2017-12611","project_name":"struts","description":"An RCE (remote code execution) attack is possible when developer is using wrong\nconstruction in Freemarker tags. Freemarker is a template engine used to\ngenerate HTML.\n","mistakes":"This is a good example of how just because code is problematic, that\ndoesn't mean it is obvious. This code was implemented in 2006 but it didn't\nshow itself as problematic until 2017. This is a simple fix that could have\nbeen implemented in 2006 when the class was developed. Just because it seems\nsmall when you write it, that doesn't mean it can't become big later.\n"},{"id":1875,"cve":"CVE-2017-15707","project_name":"struts","description":"Struts was using an outdated library in order to read and process JSON files.\nAs a result, a special type of JSON file could be created that could cause a\nDenial of Service (DoS) attack. Since the library was outdated and no longer being supported, this\nproblem would never be resolved.\n","mistakes":"The main mistake that was made was keeping around old, outdated libraries\nand still using them, despite them not receiving any security updates. The\nteam began using this library in 2007 and didn't stop using it until it was\ndiscovered that a user could cause a DOS attack.\n\nThe team seems to have taken the proper initiatve of replacing the old\nlibrary with a new one (Jackson), that is still being worked on and\nreceiving security updates. It did take some time for them to switch things\nover to using Jackson though as can be seen in some later commits showing\nthem switching to Jackson up to two months after the initial switch was\nmade. It was also noted that instead of fully removing the ability to use\nthe outdated json-lib library, they instead leave it as an optional thing,\nwith Jackson acting as the defualt JSON reader. They seem to be making proper\nsteps towards preventing the vulnerability, but still have some work to do,\nas there was no mention of removing json-lib as optional.\n\nThe team does have a good reason to keep json-lib though. There may be some \napplications that other teams have developed that use struts with json-lib.\n"},{"id":1876,"cve":"CVE-2017-5638","project_name":"struts","description":"Apache Struts utilizes multipart parsers to handle HTTP POST requests, and there are \ntwo types available, Jakarta and Pell. The Jakarta Multiparser was the one that had \nthe vulnerability, and it generates an exception when parsing the Content-Type. It \nraises this exception and includes the invalid data in the error message, and does \nthis by parsing the input and treating the parsed result as an OGNL expression. \nThis is potential for remote code execution.\n","mistakes":"The coding mistake that lead to this vulnerability was introduced in one commit. The\nmistake was introducing new code but not testing against it completely. The quick fix\nwas to update to a different version of Struts. The code fix was implemented only after \nbeing exploited by attackers.\n\nThe original author that pushed code intended to improve error handling, by introducing a\nnew class to store and handle the error, the unit tests were updated by did not test for \npotential remote code execution.\n"},{"id":1877,"cve":"CVE-2017-7525","project_name":"struts","description":"","mistakes":null},{"id":1878,"cve":"CVE-2017-7672","project_name":"struts","description":"This vulnerability may overload the server process with a specially crafted\nURL. If a special URL is put in a form field and validated using Struts' built\nin URLValidator, the validation may cause a DoS. The URL validation is done\nusing regular expressions. This vulnerability affects Struts versions 2.5 to\n2.5.20.1. Checkout CVE-2017-9804 and CVE-2016-8738 for similar CVEs.\n","mistakes":"I believe that this is a mistake in the design. The unit tests were not\ndesigned well enough to cover some possibilities of DoS. See CVE-2016-8738\nand CVE-2017-9804 for more information.\n"},{"id":1879,"cve":"CVE-2017-9787","project_name":"struts","description":"A specific type of proxy could be used to make many connections and launch denial of service attacks on Struts.","mistakes":"I believe they just missed what looks like a simple check to prevent proxy connections. Rather than a coding mistake, it seems their design totally neglected handling proxies differently. You can't catch every vulnerability and this one must have slipped through risk assessment. CWE-284 mentions carefully handling permissions and trust boundaries, and it seems from this bug that a proxy user may need restricted access (or none at all) if DoS attacks are a significant risk."},{"id":1880,"cve":"CVE-2017-9791","project_name":"struts","description":"When using Struts' ActionMessage, the development team recommended to *not* use string concatenation to get a resource key. This is akin to OS Command Injection or SQL Injection where string concatenation leads to modifying the underlying instructions.\nThe vulnerability was never patched. The development team simply put out a bulletin, along with a code example, to educate their developers. So there is no fix, nor VCC.\nFrom their website - *\"It is possible to perform a RCE attack with a malicious field value when using the Struts 2 Struts 1 plugin and it's a Struts 1 action and the value is a part of a message presented to the user, i.e. when using untrusted input as a part of the error message in the ActionMessage class.\"*","mistakes":null},{"id":1881,"cve":"CVE-2017-9793","project_name":"struts","description":"This vulnerability is located in the REST Plugin of Apache Struts, which provides\nthe ability to interface with other web applications. The REST Plugin is using an\noutdated XStream library (provides serializing objects to XML) that is vulnerable\nto DoS. The DoS is achieved through a crafted XML payload. This vulnerability affects\nApache Struts versions 2.3.7 to 2.3.33 and 2.5 to 2.5.12. See CVE-2018-1327 and CVE-2017-9805\nfor similar vulnerabilities.\n","mistakes":"This vulnerability was exploited due to an outdated library dependency that the REST Plugin on this application utilizes. The ideal scenario to avoid this sort of vulnerability is to restrict the use of third party dependencies, this can be mitigated by either redesigning the architecture of the plugin or attempting to design an internal library that was thorougly tested before production. It is always important to be wary of third-party dependencies which are constantly targeted by attackers, especially for open source software like Struts. In addition, if trust boundaries were implemented where the application would validate input that affects critical system functions, and deny anything that is not trustful this type of vulnerability could have been avoided."},{"id":1882,"cve":"CVE-2017-9804","project_name":"struts","description":"This vulnerability is due to the uncomplete fix of CVE-2017-7672. A crafted\nURL can overload the server process when validated using URLValidator. See\nCVE-2017-7672 for more information. This vulnerability is also similar to\nCVE-2016-8738. Apache Struts versions 2.3.7 to 2.3.33 and 2.5 to 2.5.12 are\naffected.\n","mistakes":"I believe the biggest lesson you can learn from this vulnerability is make\nsure your unit testing is complete. While complete coverage of every possible\ninput is impossible, testing should cover as much as possible. Before the fix,\nno unit tests covered potential cases for DoS. Another lesson that can be\nlearned is be careful with regex. While regex can be exremely powerful, make\nsure you know exactly what it does. This can be difficult if it becomes too long,\nlike in the case of URLValidator.\n"}]