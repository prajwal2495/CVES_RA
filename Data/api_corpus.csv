id,cve,project_name,description,mistakes
912,CVE-2013-6665,chromium,"Heap-based buffer overflow in Chrome's resource provider in Google Chrome that
handles bitmap textures. The vulnerability allows remote attackers to cause a
denial of service or possibly have unspecified other impact via a large bitmap
texture size that triggers improper memory allocation in the software
renderer.

The fix for this vulnerability is to place a hard limit on the number of bytes
that can be allocated in a specific situation, regardless of different kinds
of hardware.
","The vulnerabliity here was a pretty simple oversight in terms of limiting resource constraints. The code would have handled a massive amounts of memory allocation differently on different pieces of hardware, leading to a buffer overflow in some situations. They didn't think of this early on. But, the way they fixed it was to hardcode a reasonable limit into the code.
The use of a magic number without a constant still seems fishy to me, but it's very good that they considered this situation and rectified it.
Interestingly, they did not trust the fuzzer on this initially."
1457,CVE-2017-5093,chromium,"UI spoofing in Blink, a browser engine used in the Google Chrome browser. This
vulnerability makes it possible to display a popup dialog in front of the
Fullscreen permission dialog, making it ""impossible"" to the user to know he/she
entered fullscreen mode, enabling the attacker to subvert the true identity
of the URL.
","In my opinion, there were coding and design mistakes due to overlooking a
potential use of incorrectly validated inputs to manipulate modals and the
fullscreen feature. The fix looks proper as it involved additional tests,
deletion of previous code, additional checks for input validation, and the
exiting of web-page initiated fullscreen when a dialog runs. It is interesting
how even developers at top tech companies overlook validating input and serves
as a prime example to always make sure to validate input, as it may violate
the users' confidentality.
"
1471,CVE-2017-5107,chromium,"User information leak via SVG. By rendering a FeConvolveMatrix SVG filter over
a target iframe and timing its execution an attacking page can extract pixel
values from a cross-origin page being iframe'd.
",
1425,CVE-2017-5060,chromium,"URL spoofing in Omnibox. Certain Cyrillic characters look incredibly similar
to standard Roman Alphabet characters, so much so that certain fonts don't
distinguish between the two. Registering a domain with ""punycode"" escape
sequences causes these characters to display in the browser.
",
957,CVE-2014-1748,chromium,"The scrollbar rectangles for images were not properly being clipped to the the
parent document that they interacted with (owning viewport). This non-limiting 
effect allowed for chiled documents to draw/cover over the respective parent
documents by passing extremely large dimensions to for the scrollbar elements.
An attacker could use this by creating a transparent child document that covered 
the parent. This could allow the attacker to spoof content or cause the 
user to click on malicious links.
","The main mistake that was made here was less of a mistake and more of an 
oversight. The vulnerability was introduced when ScrollView::paint() needed
to be clipped by the visible content (visibleContentRect), but it was never
checked that the scrollbar was also clipped as well, leading to an inconsistency
between the two parts of the feature.

This was most likely missed due to the issue being with extremely large dimensions
being specified for the elements. It is unclear how big these must have been to 
trigger the vulnerability, so to originally test it would have probably needed to be 
through manual (or possibly fuzzer) investigation. Tests were added specifically
to check for this issue when the code was fixed in order to prevent the same issue
popping up again.

The fix here appears to be a proper fix, as the scrollbar is now properly clipped
to the same size as the rect mentioned above.
"
1128,CVE-2015-1296,chromium,"You could place special unicode characters in the URL so that a padlock character would be displayed at the beginning of the URL which could fool the user into thinking that they had a secure connection over HTTPS. Attackers could post links anywhere on the web that include these special characters so when people click on them and see the padlock icon they'd think that they're safe. The padlock icon verifies that the server is in fact who they claim to be. If you go on Facebook.com and see the padlock then it verifies that there isn't a third party impersonating Facebook. They could hide them with a hyperlink so that the characters don't appear in the link visible to the user, but when they click on it the web browser would copy it to the omnibox and display the padlock character. The omnibox is the address bar in chrome, they just call in the omnibox internally.","This issue happened at the Requirements phase. They should have considered
all of the complex unicode inputs that people could use to attempt to spoof
URLs. In order for this type of vulnerability to be caught they would have 
needed to have someone who is very familiar with unicode to be on the team.
This person would have to know about the padlock character and know that 
there are RTL characters that can be used to move characters to appear at
the beginning of the string. Throughout all of development no one must have
thought of an attack like this. It's a really complex input so it's 
understandable that they never considered it originally though. They couldn't
remove all unicode characters though because people who speak languages whose
alphabet doesn't fit in ASCII need to be able to search for things with the
omnibox.
"
1334,CVE-2016-5157,chromium,"A Heap Buffer Overflow (out-of-bounds write) vulnerability was found in OpenJPEG, which is used in PDFium in Google Chrome. This would allow a remote attacker to arbitrarily execute code on a user's machine. After inspecting the code, it seemed that the vulnerability was due to casting arguments for method to a 32 byte integer, which could possibly cause the integer to exceed the boundaries. OpenJPEG is an open source library used to display JPEG images; this was a dependency in PDFium, which is an open source library which Google maintains. This is used to display PDF files through Google Chrome.
This bug in OpenJPEG was brought forth through a developer of the open source library attempting to close another Heap Buffer Overflow bug. I think that this vulnerability could have been stopped in its tracks if there had been unit tests for this section of code, as there are no unit tests in OpenJPEG.","The coding mistake that lead to this vulnerability was that the developer who
implemented this section of code had thought of the possibility of overflow, and
the very next commit provided checks to ensure that overflow couldn't happen before
as these variables were being assigned, but they didn't think about the possibility
that after casting the variables could possibly cause overflow later.

The vulernability was introduced as the developer was attempting to fix another overflow bug
which also had to do with casting. It seems like an oversight of the developer to not think
they had to recheck the output of these variables."
1154,CVE-2015-6583,chromium,"Google Chrome's browser does not display a location bar for hosted apps that
navigate away from an installation site. For example, when you install an app
from Google Chrome's web store, launch the app open in a new window, and the
location bar would disappear. This may make it easier for remote attackers to
spoof content via a specially crafted app. Therefore, this will allow an
attacker to perform a phishing attack and steal user's credentials.
","This vulnerability appears to be introduced due to a coding and design
mistake. The coding and design mistake made here was the location bar should
have been properly handled when navigating away into a new window. Also,
there may have been a requirements issue here as well due to the way a
hosted app was initially defined as a bookmark app. The fix changed how
the browser handled the visibility of the location bar and how the hosted
app was treated in the system. The fix corrects the unexpected behavior of
the location bar disappearing and validates the hosted app can be trusted.
"
1231,CVE-2016-1645,chromium,"Attackers could write the metadata for an image, or the information that makes up the image, in such a way that when  it was read in certain programs or 
tools, it had the potential to create Denial of Service attacks which would crash applications or machines. Google used this library to interpret and render the images inside of PDF for viewing,
in addition to getting the metadata for things like image tags for describing the photos, and alt-text for screen-readers and accessibility settings.  
The crash was caused by incorrectly converting integers to other types or from negative-to-positive, and would result in ""integer signdness errors"". 
These errors could lead to out-of-bounds index writing, where the attacker could inject or execute code where they're not supposed to be able to, or number casting
errors, which could violate the integrity of the data. 
This vulnerability was a problem for its potential to affect the Availability of systems and the integrity of the data. 
The solution was to upgrade to r3002 of OpenJPEG, which based on intuition and reasoning, added checks for the data to ensure it did not run over. 
","There was a combination of design mistakes, coding mistakes, and either laziness or constraints.

First, the team did not account for buffer overflows when they originally coded the method. This could have been avoided with 
input sanitization, and checking the input to handle any potential out-of-bounds problems. 

On top of failing to handle the problem originally, they did not write any unit tests to attempt to catch the problem before it happened. 
It is possible that even with unit testing, they could not have caught this, but no tests were written period. Not at the VCC, and not at the fix.
There were 4-5 commits between the VCC and the fix, which would make it seem like writing test cases would be a good idea, as so many others had failed to fix 
it previously. 

If the team had set up the method in such a way that it validated inputs and properly handled or expected buffer overflows, then this problem might have been avoided
from the start. I am sure there were some difficulties though, as it appears that OpenJPEG is just a library that Chromium uses, so they were not necessarily testing
or intending its use for the things that Google eventually utilized it for
      
"
905,CVE-2013-6657,chromium,"The code that was used to check for possible XSS attacks replaced blocked form elements with a blank internal page. Remote attackers could take advantage of this to bypass Same Origin Policy and instead force sensitive data to be submitted to the blank page, checking character-by-character which requests got blocked to determine the data's value through brute force.","The mistake made was most likely a case of not being able to anticipate every possible
vulnerability. There were multiple commits stating that usage of the internal blank page
was safe (ie, not vulnerable to XSS) over a span of several years and by a few different people.
Perhaps more familiarity with the specific implementation of the page could have prevented this
but ultimately, developers can't learn everything about everything or nothing would get done. Code
reviews by different people may help.
"
137,CVE-2010-3248,chromium,"A bug was found in chrome which did not retrict javascript from copying to the
clipboard from any context ( anywhere you can run JavaScript). The person who found the vulnerability,
wrote an exploit that would hijack the clipboard and constantly set the clipboard to
a malicious url.

Here's how his exploit works. First, you start off by creating an invisible iframe element
in the background and turning the design-mode/content-editable on. This gives the iframe
access to the ""execCommand"" in JS, which has a ""copy"" function which copies the current
selected content to the clipboard. The attacker can take advantage of this by adding and setting
a text element inside the iframe to a malicious url and then calling the focus(), select()
and finally the execCommand()'s copy function to copy to the clipboard. In his exploit,
he used setTimeout() to make an infinite recursive call on a function which would copy
his malicious url to the clipboard every 500ms.

Here's a link to the custom exploit: https://bugs.chromium.org/p/chromium/issues/attachmentText?aid=118061
","This bug was not present in Opera or Firefox, so it was a reasonable assumption that
someone couldn't access the clipboard outside dedicated clipboard events. This is one
of those important but very obscure vulnerabilities that are hard to actively defend against.
The only way to prevent these kind of vulnerabilities, would to be paranoid about every feature
and have unit tests out the whazoo. While testing your code into the ground is a good way to
ensure it's safety, I'd say it wouldn't be economical ( or sane ) to write software like this.
"
398,CVE-2011-2850,chromium,"Khmer characters were causing an out of bound error when being read. This out of bound 
error was even being caused by a file made up of just one Khmer character. Khmer is not 
a technical for certain characters, Khmer is actually the official language of Cambodia.

An attack taking advantage of this vulnerability would have remote attackers utilizing unspecified vectors 
to upload Khmer characters that would cause an out of bound error leading to denial of service.

The issue itself cropped up in the library they were using from Harfbuzz. Harfbuzz is used to convert unicode text to glyphs.
","This seems like an issue that could have been caught earlier with improved testing. Harfbuzz itself 
contains tests against a list of languages, Khmer originally not being one of them. Additionally, while 
it was eventually caught by their fuzzer, it existed for almost a year before a person or the fuzzer 
caught this. With properly bounding unit tests they could have discovered the ease for OOB errors much 
earlier, especially when they can be caused by just a single character in Khmer or Tibetan.
"
1222,CVE-2016-1636,chromium,"The code that handled subresource integrity checks was flawed in that if a resource was requested from the same origin a second time, a second check wouldn't be run. Instead the code checked to see if a test had been run, and considered it a success regardless of the result of the integrity check. This completely bipassed the SRI protection mechanism, which is a chromium subsystem that handles checking the integrity of fetched resources","This entire issue stemmed from a minor oversight in the middle of a revamp of subresourceIntegrity code. Not a major design failing, it seems like the developer overlooked the actual result of the check, and assumed that if it had happened, everything was kosher. This was in the middle of fixing another issue that also involved checking the cache"
388,CVE-2011-2840,chromium,"This bug allowed remote attackers to spoof the URL bar via ""unusual user
interaction."" In other words, URL bar may be stolen if user clicking on
chrome interface. Such as, user navigating to the 'view download page'
will leave url bar, which is filled with information, may be spoofed
","This issue was a coding mistake because the browser originally had the
function to kill the pending page, but the if statement was looking for
too many conditions to call the dedicated function.
"
79,CVE-2010-1505,chromium,"When opening a new tab, one could take advantage of a race condition and
start loading a page in that tab before the new tab process (NTP) completed.  
This resulted in the newly-loaded tab sharing the privileges of the new tab page.  
This vulnerability was the underlying cause of another bug (Chromium bug 12718) 
which saw form submissions being submitted as a GET instead of a POST since the 
page was loaded in the new tab process.  With the privileges of the new tab process,
an attacker may have been able to execute a CSRF or similar attack taking advantage of
the side effects of these privileges (such as the change of form submissions from POST 
to GET).
","At the VCC and between the VCC and fix, there appears to have been extensive refactoring
with moving functionality to new directories.  This was done in batches of massive commits, which
likely made it more challenging to identify issues and vulnerabilities in the files involved.  This
could be classified as a mistake made in version control practices.

As for the vulnerability itself, the fixes are simple and seem appropriate, and the developers
had the foresight to practice defense in depth by adding an additional safety check after the initial
fix was made.  Overall, the only fix that needed to be made was an additional check for DOMUIScheme; the
vulnerability appears to have been a result of a simple coding mistake.  

One could argue that a greater design mistake is implied by this vulnerability since it occurred
due to a race condition.  The condition could potentially lead to further vulnerabilities in the future; however,
the fix did not address this overall issue but rather the specifics of this vulnerability.
"
898,CVE-2013-6649,chromium,"A use-after-free vulnerability in an SVG rendering function in the
Blink engine in Chromium was found through unit testing.

This vulnerability allows for remote attackers to possibly cause a denial of
service (e.g., crashing the program) or other exploits by using vectors of an
SVG image that is zero bytes in size.  If the Blink engine attempted to
render this image into a buffer, unstable behavior or remote code execution
could occur by referring to that address space (via a pointer).
","There was definitely an overlooking of basic validation.  This can be
attributed to the complex functions in the rendering code such as nested
if statements which make it hard sometimes to accurately place validation
conditions.  Checking for null/empty values is a must, especially in a
low-level language like C/C++ which is what Chromium is written in.  These
kinds of mistakes are commonly associated with use-after-free and buffer
overflows due to memory mismanagement.  It is interesting to note tests
were added, but none of them appear to directly check for zero-size images.

The code was also reviewed on that VCC commit, so reviewing procedures should
probably be revised, especially to review edge cases and validation in and
around the changed code.
"
925,CVE-2014-1713,chromium,"Memory addresses were continuing to be accessed after being freed. This could
allow remote attackers to cause a denial of service or other unknown impact.

This vulnerability was the result of misusing C's built-in pointers.
","This was a coding mistake made by not properly handling pointers. When the
author added their code, they failed to recognize that their code would
continue to access certain resources after being freed. One way to resolve
this is to dig through the code and figure out where resources are being used
after free. However, that can be very difficult and time consuming, the simple
solution was to switch over to C++'s smart pointers which automatically handle
these kinds of errors.
"
63,CVE-2010-0664,chromium,"Certain URLS will cause the browser to crash due to stack exhaustion. The
URLs are parsed recursively, so if there are too many nested protocols in
the URL the stack will run out of memory before it can completely parse it.
This causes a denial of service as the browser will crash, or an OOM (out
of memory) message is thrown.
","Personally I wouldn't have expected anyone to have to plan for this
particular vulnerability since it involved a url call to multiple
protocols, which would exhaust the system resources. I would expect people
to test calling multiple protocols, but I wouldn't expect them to call
them as many times as it did to exhaust the stack resources. From my
understanding it took several calls to different protocols to cause the
issue.
"
1107,CVE-2015-1274,chromium,"This vulnerability took advantage of Chrome's feature to automatically open
certain filetypes upon download. If a user at any point downloaded an
executable file and checked the box to automatically open this type of file
in the future, then any website could initiate a download of an executable
file and the browser would immediately execute it.
","This can be described as a requirements mistake. By the original
requirements, it was perfectly valid behavior for any filetype to be
treated as auto-openable. However, an unintended effect of this was that
executables were also candidates for auto-opening. After updating the
requirements, it is now no longer correct behavior for any executable
filetype to be allowed to auto-open.
"
1229,CVE-2016-1643,chromium,"A function in Google's Webkit in Blink (a web browser Google introduced in
2013) that was used to ensure a resource, called a shadow DOM (Document 
Object Model) was synchronized properly with the current content on the page 
the user would be looking at, did not properly update the model when content
changed or was unavailable.  The out of sync resource would allow remote 
attackers to cause a denial of service or possibly have unspecified other impact
through arbitrary code execution (hackers could craft their own code which the
program would run blindly).  This is because the function, when it crashes, 
gives the attacker semi-reliable control of the stack of the chrome system.
The stack is the set of instructions the program will run in order.  
Control of the stack means the user has control over what the program will 
execute next. The reason for using a resource like a shadow DOM is allow 
for a controllable boundary between the actual implementation of various items
like a slider, and the use of them. Rather than requiring users to code every last
piece of everything on webpages, shadow DOMs are used to give developers access
to elements that the implementers of the framework want you to have access to,
without exposing the framwork itself.  Think of a shadow DOM as a way for
framweork developers to let webpage developers work with complex pre-built 
items like various kinds of input sliders or video frames, without exposing
the code for how those reach into the framework itself, all the while allowing
the user to both utilize, customize, and stylize those elements.  The problem
that was encountered here for this vulnerability is that the shadow DOM was
not being properly refreshed. When source images weren't loaded (the
<img> tag being the html component that is actually a secret call to items
in the shadow DOM that do some magic reaching into the framework), the DOM
would suddenly have a refernce to items that were not actually on the current
page (memory gets allocated for an image, then the image is never actually
loaded, the DOM thinks there is an image but instead points to other mermory),
which exposed the system to hackers.
","This bug was introduced in one fell swoop after a large code rebase.  The team seemingly decided it was best to
utilize the shadow DOM (Document Object Model) to silently take care of loading images in the background.  This is
an interesting choice for the use of a shadow DOM because it would have to be maintained properly for it to not
start pointing to areas in memory that were not secure.  Unfortunately that is what happened here.  One user worked
on implementing utilizing a shadow DOM for the first time and did not account for when the shadow DOM itself was 
missing or out of sync.  It was seemingly an oversight on the part of the user, and also all the users that 
reviewed the changes.  The change impacted many files.  It seems that the decision to utilize the shadow DOM 
framework is still in use today.  So this commit introduced the newly accepted framework into the system, 
and the bug that accompanied it.  The mistake could have likely been avoided had the change been smaller and 
split up over more reviews.  Coding and reviewing fatigue are a real thing, and as stated before, this was likely 
just an oversight."
132,CVE-2010-3118,chromium,"Chrome is a web browser, and supports some autocomplete functionality when a
user is entering a URL into the search-box. The search-box performs URL searching
as well as searching on google.com, and is referred to as the 'Omnibox'.
The autosuggestion appears to be performed by sending a http call to a server
containing the text the user has currently typed, and requests for possible
completions of that text. This call is in http and an attacker could concievably
sniff this information and see what text or partial URL a user is viewing.

This vulnerability (CVE-2010-3118) focuses on the case where a user includes
their username and/or password in an https URL they enter into the search-box,
something akin to ""https://user:password@host"". This will be included in the
auto-complete request sent to the server over unsecure http.
","The initial issue seems to best fall under a Design Mistake. The autosuggest
feature did not initially perform any comprehensive checks to see if
autosuggestion was appropriate for the current URL.

A fix was submitted that covered many different cases where autosuggestion
would not be appropriate, but still allowed it in some cases where it was
not appropriate. This could be considered a requirements mistake as it
relied upon a poorly defined requirement.

Some of the comments in the issue tracker noted the different ways that
URLs could contain sensitive information, and many of them are small edge-cases
that relied upon still developing technology (HTTPS). New edge cases could
be introduced as the standard grows, and these edge cases will need to
be updated once more. This file was curated in 2018, but I am unsure if
more edge cases have been found since this vulnerability was resolved.
"
164,CVE-2010-4039,chromium,"In one of the startup scripts for the linux build wrapper for chrome, a line to
import libraries uses an environment variable. If this environment variable did
not exist, then it there would be a hanging "":"" left over. This causes the system
to use the current directory for libraries. If malicious libraries are placed in an 
attacker-controlled directory, an unsuspecting user could have those libraries 
loaded into their chrome instance when they start it.
","I don't think there were really any mistakes that led to this vulnerability.
Developers should be aware of variables and making sure that they are set before
using them, which is the cause of this vulnerability. However, the application
still runs as expected even if the environmnet variable is null. It takes close
inspection and thought to realize that an attacker could place malicious libraries
in the directory that chrome is being run from, and being a build script, developers
aren't usually as concerned about checking for security vulnerabilities, just about
making sure that the program will always be able to run given all environment conditons
-- and in this case, it does.
"
150,CVE-2010-3413,chromium,"The vulnerability is in the browser's built-in popup blocker functionality.
The blocker will sometimes attempt to read from an empty list of blocked
contents. This results in the blocker reading from a NULL pointer and causing
the browser to crash.

One big exploit that could arise from this vulnerability is a denial of
service (DoS) keeping the popup blocker from protecting the user's browser
from potentially harmful popups.
","The vulnerability arose because the popup blocker was not checking the value
of the list of blocked items before trying to access it. This caused it to
try and read from the list, even if it was NULL. Checking for situations
like these are vital to every secure program's operation, because these
checks keep it from malfunctioning and causing unintended, potentially
harmful, consequences.

This was a vulnerability that was coded in right from the beginning when the
popup blocker was made. It was discovered by a common user who reported the
problem to the developers. This vulnerability isn't reported to have caused
any serious damage to other users, but had it been discovered too late,
could have frustrated others in the future.
"
1024,CVE-2014-7936,chromium,"There is a ""use after free"" error within this vulnerability. A ""use after free""
is an attempt to access memory when it's already freed. This can cause the software
to crash, or potentially execute arbitrary code or elevate privileges to perform
other remote executions. In this specific vulnerability, the ZoomBubbleView::Close
function allows for document input (or other input) that can cause a denial of service
attack from malicious parties. In addition, they could potentially utilize the document
input in ways that can violate the integrity of the system in other ways, such as
running malicious scripts at lower levels of Chrome without the user knowing.
Due to the nature of ""use after free"" as well, we could potentially see a vulnerability
with elevation of privileges to change parts of the application that should not be malleable.
","I think this was another artifact of an earlier used piece of code. This is
a simple problem that just requires not using a depricated piece of code to
be fixed.
"
1027,CVE-2014-7939,chromium,"If Harmony Proxy (a specific JS Proxy) in Google's JavaScript Engine V8 is
enabled (disabled by default), it allows remote attackers to bypass the Same
Origin Policy via JavaScript code with Proxy.create and console.log calls.

The Same Origin Policy is an immensely important concept in web, it means that
a web page cannot access data from another web page unless they are of the same
origin -- calculated based off of URI scheme, host name, and port number.

This allows access to the victim's URL as a proxy, and potentially committing
information disclosure of user/victim data right to the attacker's own console.
","This vulnerability seemed to be a widespread problem involving MIME sniffing.
This issue with MIME sniffing rised up against other browsers as well, most
notably Firefox. In the bug report, the Google employees are specifically
referencing the mozilla bug report forum and their proposed solution. It's
really quite interesting to see collaboration between the two giant browsers.
The Chromium team debated with other options for the fix, but ultimately ended
up going with Firefox's proposed solution of locking down the window's
prototype chain.

The fix for this originally ended up being quite simple, by adding a nosniff
option in HTTP headers, but eventually the bug was re-opened and a new, more
complicated, solution needed to be found (mentioned above). It seems the HTTP
header option was merely a step in the correct direction (this is now
default in modern browsers).

As for the CWE entry, I found it very diffiuclt to pin down exactly which
broad CWE category this fits into. After much silent debate, I decided to
categorize it as XSS because ultimately, external JS code was being executed
that was not meant to be executed (even if it was via a proxy, aka not via
the site directly). It also directly relates to a violation of the Same
Origin Policy. Even though it's a bit strange, and therefore doesn't
necessarily have the mitigations recommended for broad XSS, there are some
that are still aparent. For example, I think the most applicable mitigation
is actually Strategy: Attack Surface Reduction. This basically involves
keeping in mind all potential areas where untrusted inputs are possible,
including things read from the network, URL components, external systems, etc.
This relates to the fact that the Chromium team had to think about a Harmony
Proxy as an area with untrusted input.
"
1051,CVE-2015-1217,chromium,"The V8LazyEventListener listens for javascript events for a given type of event.
This vulnerability occurred in the prepareListenerObject function of this listener
class, which is responsible for binding DOM event types to listener objects.
Essentially, the V8 engine needs bindings/wrappers to interact with WebKit, which
then in turn interacts more directly with DOM content in the Chromium app.

The vulnerability category is ""type confusion"", where a variable or object is
previously declared as one type but is accessed as another type.  This causes
problems in mainly C-like languages because they do not have memory safety that
will check if something like a pointer is trying to point to allocated memory
of another type.  In this case, JavaScript code is constructed, compiled, and
then ran, partially based on DOM element input (what the listener should listen for).
The result is then cast to a function, although it is not necessarily a function,
causing type confusion that could cause a crash in the program or another DoS of
sorts for a malicious actor.

This was fixed by removing testing assert statements and replacing them with conditional
checks for whether a context object is a document, whether it allows
inline event handlers, and whether the internal script that is ran
has a result that is a function.  This ensures objects are of the proper type and are
not null, which could make the above exploits possible.
","This is definitely a case of quick development of code between commits leading
up to the vulnerability.  This code was overlooked, perhaps due to miscommunication
since it appears a different person was involved with each step of introducing and
fixing this vulnerability.  More rigorous code reviews for common security standards
(especially pertaining to C and how these subsystems are typically implemented in
Chromium) could add up in the long run to have a more fortified application build
with fewer common, easy to check for errors.  Make sure everyone reviewing understands
what the code is trying to accomplish and if it does that (Validate and Verify).

The fix of checking for certain conditions before preceding to create the listener
object seems appropriate for this kind of vulnerability.  In the future, do not
rely too heavily on asserts for runtime in the production environment.  These should
be converted to actual checks and handling of errors and exceptions.
"
880,CVE-2013-6627,chromium,"An attack can access information beyond the length of a buffer storing HTTP
response headers by having web server use pecially crafted informational
HTTP response codes (1xx). These HTTP response codes are incorrectly processed
and are nott removed from the front of the buffer. Other parts of the code
always assumes that the current HTTP response being parsed is at the front of
the buffer and the incorrectly processed 1xx response code produces a length
longer than the buffer of the responses. The attacker can use this to read the
main process' memory and change its execution.
","The vulnerability appears to mainly stem from design mistakes. This is
evident because the code shows that the developers did not know that 1xx
HTTP response status codes are different from the other classes of status
codes. Also, the developers made a lot of assumptions without considering
whether the code written actually fit their assumptions.

The vulnerability shows miscommunication issues regarding the
assumptions made (which influence which fix option was used). There also
seems to be little communication between people on the team. I believe this
based on the defensiveness in the bug thread and the fact that a developer
moved around code without knowing how that code actually works.

Overall, it appears that while the vulnerability was caused by a relatively
small number of lines of code, the vulnerability was merely the symptom of
larger issues including design mistakes, assumptions, and miscommunications.
"
1348,CVE-2016-5173,chromium,"In a regular webpage using Chromium and standard JavaScript, a remote attacker
is able to modify and add functionality to JavaScript's core Object.prototype,
the default prototype that all JS objects inherit properties and methods from.

Modifying Object.prototype is normally not an issue, but Chromium's extensions
subsystem also adds functionality to the Object prototype and does not restrict
access to it. This is a concern because Chromium's extensions subsystem has access
to lots of resources not intended to be invoked or loaded in to a client webpage.
An attacker's webpage (or otherwise executed JavaScript) can exploit this by
loading in additional Chromium extensions resources allowing them to do things
such as modifying what happens when objects are garbage-collected, executing
native functions that typically require user interaction without their
interaction, and otherwise calling native functions with attacker-controlled data.
","The mistake here was a design mistake. The developers used a standard
JavaScript implementation of directly binding properties to an object
prototype and so the vulnerability wasn't obvious. The main concern comes
from the fact that this code is in Chromium's extensions subsystem and has
access to many internal never-to-be-exposed resources and native functions.
JavaScript at its core is notoriously lax and doesn't do any kind of access
control by default on modifying object prototypes. As a result, an attacker
in this scenario is able to simply modify the base ""Object.prototype"" to
add their own functionality and carry out their exploit. The main takeaway
from all of this is to expect attackers to abuse the tools you give them.
Accounting for this and understanding more about how JavaScript works is
key to preventing something like this from happening again in the future.
In this case they solved this in all 50 files with better design, by
extracting out a new function to do the required property binding safely
instead of directly adding them to the Object prototype.
"
885,CVE-2013-6634,chromium,"An incorrect URL was used during user authentication in the Gaia subsystem. When a
user would login to some web application with credentials that were saved in Chrome,
the 302 response recieved from the web app was not properly validated. When attempting
to redirect a user following authentication, Chrome decides whether to follow
the given url based on the information given to it.

The conditional logic that would decide whether the redirect url should be followed
was flawed, not referencing the correct url from the object in question. This
enabled remote attackers to conduct session fixation attacks and hijack web
sessions by triggering improper sync after a 302 HTTP status code.

This vulnerability was present in the master branch of chromium's source
from around October 9, 2012 until a bug report was opened over a year later on
October 14, 2013. A fix was merged on November 21, 2013- more than another month later.
","At its core, CVE-2013-6634 was caused by a simple coding mistake. The programmer who
implemented the VCC accessed the wrong member of an object, therefor passing the wrong
value into a function call that was to approve or dissaprove the traversal of a 302
redirect. This could have been mitigatted with more testing- especially the use of a
code coverage tool could have identified the need for testing when a conditional like
this should resolve to true.

There do not appear to be tests in place to catch a regression of this issue. While
it's unlikely a regression would happen in this location in the code, a refactor of the
request object might be useful to prevent future similar errors.
"
396,CVE-2011-2848,chromium,"Forward button and backward button on a browser help user navigate to the previous
and the next page in the history easier. However, in some cases, after user goes
forward manually, opens and closes a new tab, the URL bar is spoofed.

The problem lies in the way Google Chrome updates icons and URL bar everytime
user commits a page. The SSL/EV icon in URL bar should only be changed after
navigation has committed, but Chrome changes it when the browser starts navigating
forward/backward, this means the icon changes even the actual URL may not be 
comletely loaded. The URL bar then doesn't reflect the page that it's loaded to user.
User could be redirected to a non-SSL site or a phishing site and still think they
are safe because the URL bar and SSL icons are good.
","I think this vulnerability is more of a design mistake, the developer 
clearly didn't come up with an ""ideal behavior"" for handling URL bar as well
as a complete test plan for user interactions. The actual fix and unit test for this 
vulnerability were quite simple. 
"
46,CVE-2010-0643,chromium,"Google Chrome before version 4.0.249.89 defaulted to a direct connection when
there were no proxies available which was different from how other web
browsers handled this issue. Other browsers such as Firefox and IE (Internet
Explorer) would display an error page if there were no available proxies.

Why is this an issue? When you have a direct connection remote HTTP servers
(the website you visit) can see your IP address, user agent information, and
cookies stored on your personal computer. This is a serious vulnerability
because with direct connections you lose the anonymity that proxies provide.
An attacker could exploit this vulnerability to obtain sensitive information
about the identity of the user.
","The mistake that led to this vulnerability was a design problem. Unlike, other browsers it was set up to use a direct connection when there were no proxies available. The main reason this was a problem because it exposed the user identity which could be used for malicious purposes. The system should have been designed to prevent a direct connection from being used without the user's knowledge. However, the design specification did not acknowledge that requirement.

The CWE entry I chose was Information exposure through sent data. With a direct connection, the user's sensitive data may be exposed to attackers. To mitigate this weakness you should define what data in the software is sensitive. This mitigation happens in the requirements phase to support the design. However, this is where the requirement was missed and evolved into a vulnerability.
"
1086,CVE-2015-1253,chromium,"Scripting was allowed during DOM tree parsing. As a result, an attacker could infect remote browsers
with malicious code via them visiting a website with malicious javascript files. Once the file was a
loaded into the browser upong page load a script tag could then beexecuted while the browser was accessing the HTML parsing
tree. Executing javascript during this process is generally unstable and bypassed cross-origin security policy, which
serve as a protection mechanism for a variety of other types of attacks.
","This vulnerability was very obscure and probably could not have been forseen except by seasoned, security-minded engineers. That being said, a lack of understanding and attention to the lifecylce of DOM parsing was probably the root cause that lead to the initial VCC. Paying attention to the vital points in code where the system becomes subject to script execution is key to preventing these types of vulnerabilities in the future."
17,CVE-2009-1413,chromium,"This is a vulnerability in Chrome 1.0.x where Chrome does not cancel timeout
functions when switching tabs, which makes it possible to execute universal
cross site scripting by using Javascript's setTimeout function to run code on 
a new page after the site has loaded.
","The biggest mistake was not killing timeout functions created on one page 
when navigating to another page. This is ultimately what allowed for the 
UXSS style attack to occur. The fix was that the problem protocol
was already on its way to deprecation for other reasons, to stop processing
ChromeHTML protocol in IE URIs. If the ChromeHTML protocol was not to be 
deprecated, a different solution would be needed.
"
1447,CVE-2017-5082,chromium,"Insufficient hardening in credit card editor. FLAG_SECURE is not used within
Chrome on Android when putting in prefilled credit card numbers. This would
allow another application on the same device to see the screen and capture
the numbers. By comparison Android Pay and Android Wallet use FLAG_SECURE for
credit card entry.
",
1054,CVE-2015-1220,chromium,"In Google Chrome, there were multiple occasions where after a memory location is freed,
the location is then attempted to be used again. In this specific vulnerability, a 
location used for a GIF decoder is attempted to be used again after a gif fails to be
decoded. If a remote attacker chooses to attempt to take advantage of this vulnerability, 
they could cause a denial of service for other users or other unpredicted behavior. 
The way that it is anticipated that an attacker would take advantage of this is by a 
""crafted frame size"" in a GIF. Any frame size larger than the screen size of a device 
could cause the broken GIF to triggers a bug in the decoding code for the GIF.
","One thing that I found interesting about this vulnerability is that it was found
two months before it was fixed or looked at. Once it was looked at and recreated, 
it was labelled high priority and had a larger bounty than other common vulnerabilities. 
This probably could have been done on a quicker schedule, but there might have been 
a release or some other thing more important in the employee's workload.

From reading into this vulnerability, this is a common issue that many services that
have gif loading have. On the Chromium team's internal comments, there was mention of 
this issue also occuring on firefox. I believe that this was created by a coding mistake.
The team also mentioned that there was a quick fix in place that did not cover the edge case
of this vulnerability-when the first frame of the gif is larger than the screen size.

The CWE associated with this vulnerability is concerned with memory use after a free, because
of the error that occurs after the before mentioned issue with gif frame sizes. There are two
suggested mitigatons in the CWE entry. The first mitigation suggests choosing a language that 
provides automatic memory management. For a engine such as blink that is quite large, it is not
realistic to rewrite the rendering engine in a new language. The second mitigation is to be sure
to set your variables to NULL after they are freed, but even the mitigation strategy mentions 
that this fix may not be very useful if there are multiple of complex data structures, and blink
is a very complicated engine.

However, considering they fixed the issue at its root cause(mishandling gif decoding), and changed
the quick fix, it seems like the fix was handled properly. 
"
722,CVE-2012-5152,chromium,"Extra memory was allocated if the playback rate of a video was higher 
than normal and the skip feature was used(think youtube).
The C++ language allows for direct references to memory even 
if that reference is outside of the intended buffer.
The extra memory could be used for out-of-bounds read access. 
","It was a coding mistake. The author did not correctly account for a 
change in playback rate properly when seeking would be applied. 
It was an interaction of two features (seek and increased playback) 
that had an unintended consequences. "
136,CVE-2010-3247,chromium,"Google Chrome doesn't properly restrict the characters in urls, allowing
remote attackers to visually spoof the url bar using sequences of characters that
are being used for a different purpose than their intended use (specifically homographic sequences)
","The common mistake that led to this vulnerability was the lack of internationalization
and localization for the URL. If it was considered, the url spoofing through the usage
of homographic sequenced japanese characters would not have been possible. The lack of testing
in regards to internalization and localization also contributed to this. If they tested foreign
characters in their test case for the URL, they could've caught this earlier on. The lack of
testing on Google's end meant that it had to take the outside testing of a security
company to happen to find this vulnerability for it to start to get addressed.
"
1120,CVE-2015-1287,chromium,"There was a bug in Blink, the webkit used by Chromium that allowed an external
resource to be loaded as CSS and interpreted with or without a correct MIME 
(media) type. This bug made it possible for an attacker to leak data by using
a CSS string injection. This bug was caused by the use of a method of interpreting
CSS called ""quirks-mode"" which allowed for the parsing of non-standard CSS. 
The bug had been encountered before in the past and an attempt was made to fix it
by using a ""strict-mode"" to parse CSS with an incorrect MIME type. However, it was
discovered that the attack was still possible if the attacker could change the
charset to UTF-16. From my research it looks like quirks-mode had been removed before
but it caused some issues with other tests and was added back in. Eventually it was 
removed for good, the browser refuses to load cross-origin resources as CSS if the
MIME type is incorrect. 
","It seems that the original existence of quirks-mode in the first place is for the 
purpose of parsing non-standard CSS. Non-standard CSS seems to be a sort of legacy
support. 
In the bug discussion one of the main arguments to drop quirks-mode was
that Firefox had already done it. This vulnerability is a design mistake, quirks-mode
was added in for compatibility purposes but it turned out that CSS with an incorrect
MIME type could open up an opportunity for an attack.
It is possible that quirks-mode could have been fixed to make it more secure.
However removing the option entirely fixed the issue with only a minor 
impact on compatibility
"
233,CVE-2011-1112,chromium,"
When displaying a type of graphic known as an SVG, a value of infinity could
be used as one of the attributes, causing a write to an invalid memory location.
This would result in a segmentation fault.
","This vulnerability was caused by a coding mistake. The coder(s) did not
consider the specific edge case that lead to this problem. Writing unit
tests for the code probably would have helped the team consider edge
cases such as this.
"
570,CVE-2011-3956,chromium,"The extension implementation does not properly handle sandboxed origins, which may allow remote attackers to bypass the same origin policy via a crafted extension. So basically an extension could gain permissions beyond what it was initially given by the browser.","This bug was caused by the fact that origin was not checked by the browser before granting permissions to an extension. This can be caught by using a fuzzer to try and spoof the origin of a request.
The fix looks sufficient because they implement the check and add unit tests to verify proper permissions are granted."
573,CVE-2011-3959,chromium,"There was a buffer overflow in the way Google Chrome implemented locale 
information. This vulnerability affects one of the dependencies that Google
copied into their own repository and edited to work with their code.
The overflow could have lead to potential denial of service attacks 
and more. A Fuzzer from someone who works outside of Google discovered
the vulnerability. The bug affected over seven hundred versions of Chromium and was likely
there since or very close to the beginning.
","There was a mistake in trusting the dependency and the way that Google handles
its dependencies. By cloning the dependencies and manually changing items when needed
(By Chromium), the project was missing out on bug fixed and other important updates. This also might have been an issue that could have been mitigated if the
way it was implemented. Also, because this was a dependency, this was likely
not unit tested by the Google team.
"
834,CVE-2013-2879,chromium,"This vulnerability occurs in a user signin process, where a user can be tricked into signing into an attacker's account, via Cross-Site Scripting, effectively phishing. This can cause the user's personal information to be revealed to the attacker. The attacker can then force an account sync with the victim, giving the attacker the ability to run code under the victim's privilege.
The vulnerability stems from the trust that the sign-in process has with the renderer process. There was trust between these two processes at points that the trust could be used against them in an attack.","The basis of this vulnerability was trust. When the file was changed to no longer support non web-based signin flow, certain trusts were not verified, leading to a trust between the sign-in process and the renderer process that opened up the subsystem to threats. Trust boundaries are important and should be reviewed when doing things like removing features.
The vulnerability was not found on a single or small set of lines, but rather within the overall design of the subsystem after the non web-based signin flow was removed. The fix involved removing very few lines and instead adding in the new logic that was needed after the loss of the previous feature. While a design may be fine before, this shows that it is good to re-verify a design after removing a decently sized feature."
964,CVE-2014-3159,chromium,"This vulnerability allows for a malicious site to spoof the URL of another
site through phishing attacks because the origin of requests were not properly 
checked.

A malicious person could write a short script. In this script, the URL location
of a link could be changed. After it is changed, future clicking on that URL
will navigate a user to the new (malicious) URL.
","Input from chrome for Android did not validate the origin of URLs,
which is listed as a mitigation for this CWE. The fix looks proper as it
ensures that a URL is from the renderer before POSTing. I do not believe that
there was miscommunication or design mistakes, merely a vulnerabiltity left
from improper code review.
"
960,CVE-2014-3154,chromium,"This vulnerability was in Chrome's shutdown sequenece. If Chrome is running
JavaScript in a window, some of the valid commands are to write to files and
to close the current window. 

When the window is closed, the window thread did not properly remove the thread
writing to files, even though the memory that writer was targeting had been freed.
The code that closed the window thread assumed that any files it had accessed would
no longer be used.

The fix ensured that the shutdown sequenece of a window also properly shut
down the file writing component.
","This mistake was two-fold. There was an erroneous assert statement, along
with a case where a thread was not shut down properly.

The unneeded assert statement was primarily due to a miscommunication, where
a developer did not consider all the cases where a particular error could be
sent out, or the code was later changed and the tests for that code were not
changed along with it.

The shutdown error was due to a design problem, where a thread was planned to
be shutdown, but it did not have it's components properly planned out, and an
attached child thread was left running after the parent was shut down. More
rigourous documentation could have prevented this problem. The parent thread
should have a list of child threads to ensure they are terminated at the same
time as their parent thread.
"
935,CVE-2014-1723,chromium,"This vulnerability is actually a really cool one. Malicious actors could insert a right to left
(RtL Character) into a url using their keyboard to create very misleading urls. The RtL reverses
characters after it in a string in the GUI. This character is completely insivible to the users of chromium, 
so it was almost impossible to detect. For example, a malicious user could use this character and create 
a url like ""coolcamsj.png"". However, due to the RtL character in the url, the browser would actually read 
the string as ""coolcamgnp.js"" and load that, which has the potential to be malicious javascript. 
","Personally, I think that requirement mistakes were made that led to this vulnerability. The original
coders either didn't have knowledge of this character or how it could lead to problems in the future,
but it eventually came up. Luckily, it was reported by a good samaritan, hopefully before any malicious
users had the chance to use it against other users.
"
797,CVE-2013-2839,chromium,"When a user attempts to copy and paste an image via dragging, the image is typecasted into a HTMLImageElement without
proper checks being performed to make sure that the cast is legal. This allows illegal types of image elements,
such as SVGS, to be casted as a HTMLImageElement.

Right after the casting is performed, the cachedImage() method is
called on the casted HTMLImageElement. Since the HTMLImageElement has a larger virtual table than a SVG file, the
adjacent memory around the casted SVG is used as part of the virtual table.

These values in memory could be
controlled if heap manipulation was performed before triggering the bug, allowing for arbitrary code execution.
","The mistake occurred because the developer did not properly validate his inputs, which would be a coding mistake,
although an argument can be made that the developer may not have followed the design correctly. All user input
should be validated to ensure that what the system receives is what it expects. Also, directly casting user input
into another form of data is also a fairly large risk and can lead to the issues with memory. In this example, the
casting of the illegal types into a HTMLImageElement allowed access to parts of the heap that could be manipulated
by the user, which is highly dangerous.
"
1050,CVE-2015-1216,chromium,"An implementation for custom bindings related to windows in Google's V8 
JavaScript engine left a potential vulnerability where an attacker could trigger
a denial of service attack or cause other issues due to an entity not being freed
properly.
","The CWE only gives a few brief mitigations for use-after-free. One is to use
a language with automatic memory management, and the other is making sure to
set pointers to null after freeing them. The entire V8 module of Chromium is
built mainly with C++, and it would be incredibly difficult to move everything
over to a different language, not to mention the fact that it would probably
create some noticeable inefficiencies.

This vulnerability is a bit different than a conventional use-after-free,
seeing as the exploitable entity in is actually set to null, but can then be
modified by code later in the function. The main mistake seems to be in the
original implementation, when the programmer did not put a check for this null
value that would have prevented it from leaking into code later on.

Use-after-free is one of the harder vulnerabilities to catch, because it is often
overlooked by unit tests and can show up in places you wouldn't expect. This case
of use-after-free is unconventional and was not as clear as more textbook examples.
Luckily, the fix was fairly simple and properly mitigated the vulnerability.
"
1293,CVE-2016-1707,chromium,"On iPhones, remote attackers can make malicious web sites look safe by masking the URL with a trusted website like https://google.com.","I believe this was primarily a logic error that did not expect the url to be invalid. The first time the iOS web controller was included into Chromium, it was only making sure that the URL was as expected, but it did not really do anything if the URL was not as expected.
Furthermore, this is an interesting case of a spoofing attack. This is an Improper Input Validation vulnerability instead of what is commonly a URL Redirect bug because the exploit works by inputing an invalid URL to force an error on Chrome."
998,CVE-2014-3803,chromium,"Blink, the rendering engine used by Chromium, has a feature which
allows for attackers to enable microphone access and obtain speech-recognition
text from users. This can be done by using an INPUT element which uses a
deprecated attribute.
","This vulnerability could have been prevented if the x-webkit-speech
feature was removed shortly after becoming deprecated. When they decided to
deprecate this feature, there was mention that it would later be removed,
but with no specific deadline or date to do it by. The fix was to disable
this deprecated feature, which was successful in fixing this vulnerability.
"
1099,CVE-2015-1266,chromium,"Attackers were able to bypass restrictions in chrome to access GUI components
that should have only been accessible with certain permissions or through a proper
route. They could do this by attempting to visit a malformed url into the chrome
URL bar.
","The major mistake in this vulnerability was not thinking ahead to how the input
could be spoofed. They trusted the input from the user and expected that the only match
for that string would be for the valid route.
Simply having a distrust for input from all users could have accounted for this.
"
346,CVE-2011-2783,chromium,"In Chrome's developer mode, when using the extensions interface at
chrome://extensions, it does not prompt the user with a dialogue box when
loading an unpacked extension (an extension that is not available through Chrome's
store) that contains an NPAPI (Netscape Plugin Application Programming Interface,
an interface that allows for plugins such as browser extensions to be developed 
directly for web browsers) plugin like it does with other extensions. Without
this prompt, it is easier for a malicious user to modify Chrome's functionality
via something like a Trojan horse attack.
","The vulnerability was an oversight in the types of extensions that could be
loaded. Ideally, assuming there are restrictions in place on the types of
extensions that can be loaded (which there should be, otherwise you risk breaking
the distrust input protocol), there should be a list of those extensions
that is tested through incremental testing when anything related to the extensions
loader is modified.
While it is nice that they're ensuring that NPAPI extensions will now correctly
prompt the user, it does leave a bit to be desired, specifically that there may be
other extensions left that have the same problem; again, the best course of action
should be to ensure that every type of extension prompts the user when loaded, as intended."
1209,CVE-2016-1623,chromium,"Due to the implementation of the HTML parser, an unapproved frame component 
could attatch itself to the page at the same time an approved component was detatching.

This allowed remote attackers to piggyback off the current state of the approved frame 
to execute commands remotely on the system.
","This is an example of a design mistake. The system was designed to check
against a method that it was possible to never advance and skip the guard altogether.
If it was designed to use a different guarding method, the exploit may not have occurred.
"
1095,CVE-2015-1262,chromium,"A width field, m_totalWidth, was not initialized, but was used in other areas of the code. This could have caused denial of service or other unspecified impact via Unicode text.","The mistake was mostly a design issue. They initialized the variable, but it was initialized after a condition was checked. If the condition passed it would return and the value was never set, so the value just needed to be set at an earlier point in the code, which is what they did to mitiigate. To prevent against this issue , or mistakes similar to this, they could have code reviews to catch design/coding flaws that have the potential to harm the system such as this one. Another way to prevent against something like this would be to use TDD (test driven development). This way, when going through the conditions in the HarfBuzzShaper::shape() function, they could check for what the values of certain fields are, or if those fields were even set at all, and correct the issue if anything was not what it should be."
1342,CVE-2016-5165,chromium,"This vulnerability allows an attacker to send a specially crafted url that
makes use of the settings parameter in the chrome devtools to inject
malicous javascript. The script is executed the next time that the user opens
the developer tools in chrome. The attacker can write javascript to modify or
exfiltrate data from whatever site the user opens devtools on. The url would
look something like the following: ""chrome-devtools://devtools/remote/serve_rev/@180642/devtools.html?settings={%22watchExpressions%22:%22[\%22alert(document.domain)\%22]%22}""
","I think the main take away from this vulnerability is that you should think
carefully about what exactly your are allowing a user to do when you are
implementing a new feature. It is important to consider the abuse and misuse
cases that will be possible with the feature are adding and how you could
mitigate those, especially if you are accepting user inputs.
"
447,CVE-2011-3045,chromium,"Lack of a controlled space for use in an added image library allowed for certain
PNG images to expand to 3 or 4 Gigabytes in size, triggering a 32-bit signed
integer overflow leading to a Denial of Service.
","I believe the mistake made that resulted in this vulnerability occurred due
to the team's acceptance of the third-party library, it appears they assumed
the library would take care of the vulnerabilities within without checking 
if it did. When they first introduced this bug, they probably didn't realize
a PNG file can unpack to overflow a 32-bit integer.
Additionally, there doesn't appear to be any unit tests related to the library,
which means they assumed its open-source nature would result in security issues
being fixed without much hassle. While this is true, there was a length of
time between the issue and the fix where special PNG images could DoS Chromium.
"
878,CVE-2013-6625,chromium,"This vulnerability is an example of a use-after-free bug. This
means that a chunk of memory in the program was given back to the operating
system to be used for other things, but then the refernce to that memory was
used later in the program's execution. When the reference is used again, the
program will attempt to use whatever data was put there as the original value.
This could be hazerdous if the memory is now being written to or read from by
other code.
In this case, the the use-after-free occurs during the rendering of the of the
html DOM. The bug happens when a child node of an object dom is removed but a
reference to that node is still kept, despite the fact that the memory is
freed. Child nodes can be removed after mutation, or blur events that occur in
the DOM. If another reference to that child node is kept somewhere else, then
a use-after-free can occur. This fix was to change the scope of the
nodeChildrenWillBeRemoved to be the entire document instead of the document
within the container. This ensure that references to the child node that are
outside the scope of the document within the node being modified.
","The fact that this vulnerability existed in code that was reintroduced, and
the fact that there was so much refactoring going on in this area of the
code leads me to believe that the primary cause of the vulnerability was
miscommunication.
"
1168,CVE-2015-6768,chromium,"When stopping an HTML frame and its children, there is a point where
a loader for the frame is stopped. At the point where a frame loader is stopped,
there is an instance where a URI is called in order to replace the action of
stopping the frame. Once the URI is called, the action suppresses the final step
of fully closing the frame. Due to the frame never being fully closed, an
attacker may now load whatever elements they desire.
","There was a coding mistake that involved not accounting for an edge
case scenario within an edge case scenario. The developers could have
taken extra measures to ensure when the code fails it does so securely
so an attacker cannot take advantage of a vulnerability like this.
Otherwise, if you don't realize it from the beginning it won't be caught
for a while.
"
145,CVE-2010-3256,chromium,"Google Chrome did not properly limit the number of stored autocomplete
entries, which has unspecified impact and attack vectors. It was possible
to overflill the system by creating a form with thousands of hidden fields 
that are all added to list of autocomplete fields.
","The mistake here was design mistake. The autocomplete feature did not limit
the amount of items it could store per form. This was not a coding mistake
because it was not in the design to limit the input. The solution of limiting
it to a set number of items seems like a patch but it will eliminate the issue.
"
68,CVE-2010-1231,chromium,"The vulnerability was in Chrome's SafeBrowsingResourceHandler which controls a
chain of ResourceHandlers that, when browsing in safe mode, do processing 
on a url or a resource and decide whether it can be loaded or not.

The implementation of SafeBrowsingResourceHandler simultaneously did protective
parsing of a url and retrieved the resource's HTTP headers. This caused the headers
of the resource to possibly be processed before identifying if the url was safe
to load or not. Once the headers were processed, ResourceHandlers further down the 
chain could use the post-processing header response to do a number of actions such
as load the requested url, load a url from the header response, tell the DownloadManager
to download a file from the url location, apply cookies to the browser, etc.

This could be exploited by using custom HTTP headers to start a download of a malicious 
file that could exploit a program on the OS (ex. a .pdf file that exploits a know Adobe
Reader bug) or just be straight malware.
","The mistake was attributed to mostly a design flaw. 

At the point in time of development, SafeBrowsing was a generally new feature 
of Chrome 4.0 (released Jan 25 2010) when the vulnerability was discovered (Jan 29 2010).
The team had only recently set up the process for checking blacklists, blocking cookies,
and parsing urls before loading partial resources for the page. Most likely the specific
steps of the process were disjoint and not easily extendable or easily added to. There 
was just a miscommunication of what had to get done when and steps ended up out of order.
"
59,CVE-2010-0660,chromium,"Chromium sends an HTTPS URL in the Referer header to an HTTP site when redirecting
from a secure HTTPS site to an unsecure HTTP site. 

The 'Referer' header is the address of the previous web page from which a link 
to the currently requested page was followed. An unsecure HTTP site may obtain 
sensitive information embedded in the HTTPS URL such as password reset links.

Even if the security of the site is not compromised, the user of the site may 
not want the information shared.
","The mistake was essentially not handling an edge case where a request
was made from a secure site to an unsecure site using a redirect. The fix
itself was only 2 lines of code to check to see if the referrer header should 
be cleared before redirecting. It was clear that the developer's knew from the
beginning of the repository that the referrer should not be sent from an HTTPS 
site to an HTTP, and did not in other cases, but this was not implemented in 
redirecting.

The CWE vulnerability mitigations suggest that this could have been avoided
in the Architecture and Design phase by drawing unambiguous trust boundaries.
It would be interesting to see if there were updates to security related
design documentation to show how a redirect can be used to leave a site
secured by HTTPS. 

The fix itself appears well enough, but it is hard to tell if there was a lesson 
learned by the developers from this mistake since it is unclear why this case
was missed (other than just complexity). It is not even safe to say that all
instances of the referrer crossing trust boundaries are handeled or that future
functionality will not repeat the same mistakes.
"
950,CVE-2014-1741,chromium,There are a couple cases in lower level code that handles rendering characters where an offset was not handled in a overflow-sensitive manner. This might have had unspecified impacts via vectors related to ranges or open up to DoS attacks.,"This is another example of a minor coding mistake overlooked in a huge commit. The offending code subtracts an offset without accounting for a possible overflow, which is only a minor part of a major rewrite of the subsystem to fix another bug. The fix accounts for this, and handles it in a way that's consisitant with the DOM spec"
141,CVE-2010-3252,chromium,"If a program opened a notification through Chrome and then terminated before
an actively running notification closed, then the notification would try to
detach from the no-longer-existent program it came from and cause a corruption
of memory.
","The reason that this vulnerability occurred was because the Software Engineers
working on it never covered the case where a notification from Chrome outlives
the program that spawned it. The actual problem was that memory was freed before
it was done being referenced but it wouldn't have been an issue had the team
working on it paid more attention to covering unlikely but possible scenarios
for their use cases to end up in, like in this race condition. It is probably
uncommon, and maybe even unlikely, that a program that makes notifications won't
last at least as long as those notifications themselves. But it's not unreasonable
and only required the simple fix of adding a method that gets called when a
notification provider terminates, simply going through and detaching it from all
live notifications first. A little bit more effort planning ahead could have
helped their system's overal integrity.
"
1102,CVE-2015-1269,chromium,"Attackers can bypass HSTS restrictions due to a lack of canonicalizing DNS hostnames before comparing them to the HSTS list. HSTS is the security policy that declares to web borwsers they should only interact with the page via HTTPS connections. Before the fix, attackers could add a dot (.) character to the end of the connection string or use a string that isn't completely lowercase, which would then be compared to the HSTS and HPKP entries already preloaded on the system. These comparisons would then allow the attacker to bypass this secure connection and gain access to content not initially intended for users.","The mistake that was made was that the developers tried to rely on whiteboxing alone and didn't attempt to normalize any inputs. They may have originally felt that by whiteboxing, any unlisted inputs wouldn't be able to be used, therefore making the inputs secure.
The fix implemented looks proper, according to the CWE, now incorperating normalization methods along with the original whiteboxing method."
1473,CVE-2017-5109,chromium,"UI spoofing in browser. JavaScript-related functionality causes the
notification window for another domain/page to be displayed. This was caused
by improper unload handler handling, which allows a permission request to be displayed
from a domain after navigating to a new domain. For example, a malicious website can
have a button that takes you to Google Maps and request your location.
","The fix was to close the permission bindings when the render frame host changes
so that messages are no longer received to run code in the permission service.
This was a design oversight that may have been prevented by considering the
flow of permissions when switching frames, and considering invalid states prior to implementation.
"
1085,CVE-2015-1252,chromium,"The vulnerability was in Chromium's common utility functionality, specifically
a new implementation of a ""PartialCircularBuffer"" which was basically a buffer
that could wrap around *n number of times to have a continuous write of data.

The implementation, which was in C++, didn't handle the wrap around buffer write
case for large amounts of data properly. This had the possibiliy of resulting 
in data being written to memory that it was not intended for (an ""invalid write""),
corruption of data, crashes or most significant to the security aspect of the
issue allowing for arbitrary code execution as it was functionally a ""buffer 
overflow"" scenario.

The way that this could be exploited would be if an attacker found a way to 
access the web logging that was being utilized and pushing any very large amount of
data to the target log write buffer which would result in a denial of service
attack on the system. Since this particular issue was a common utility the potential
attack possibilities while being more widespread would also depend on how the
""PartialCircularBuffer"" was being used in the different modules.
","The chosen CWE is 787 (Out-of-bounds Write) has no mitigation strategies
listed however there are mitigation strategies in CWE-119 (Improper 
Restriction of Operations within the Bounds of a Memory Buffer) which is
what NVD lists as the class of the CVE issue. I have chosen CWE-787 as
that is the exact issue that occured but the NVD listed CWE-119 has what
I would consider applicable, specifically the mitigations in the
implementation stage. The fix is specifically addressing the mitigation
of checking the buffer boundaries if accessing the buffer in a loop
to make sure you are not in danger of writing past the allocated space.
Since the issue at its core is a lack of checking proper space checking
on the buffer size vs input size when handling the wrap around case, the
fix moves the wrap around content out of the initial write loop to ensure
safety when writing the given input. The initial implementation simply did
not include thorough enough testing to catch this edge case.
"
1218,CVE-2016-1632,chromium,"Attackers can bypass intended access restrictions using JavaScript code.The attack
causes an incorrect cast.
","With the limited information about the vulnerability, we can only say it was 
probably a coding mistake. Potentially more testing could have been done beforehand.
"
589,CVE-2011-5319,chromium,The application does not restrict access to accelerometer data at high rates. This allows attackers to capture the keystrokes and moitor speech from the website without a permissions prompt.  The keystrokes and speech are a part of the website interaction.,"I think that for this bug there really wasn't too much that could have been done before hand if the team did not know about the attack.  However, they could have had something around their events to try to always prevent attackers from getting their data.
They had a few different ideas for how to resolve this issue, a few did not work out for them.  They appear to have a proper fix by limiting how fast the data can be read."
758,CVE-2013-0891,chromium,"An integer overflow in Google Chrome in blob url request leads to a buffer overflow
allowing an attacker to control a specific function of what bytes to read. This attacker
can lead to a denial of service, information disclosure, and other unforeseen issues.
","The mistake that was made was the improper checking upon the limits of input
with the number value and testing the boundary conditions. The mistake and 
vulnerability was within a sub system of chromium but had the ability to release
sensitive information.

The mistake was the lack of unit testing and so when someone realized that the
boundaries could be exploited, another author went back to input the proper
the proper checking to fix the mistake. The vulnerability seems to be resolved
as boundary checking was inputted and the variable types changed to be the proper
type. However, since there didn't seem to be any change in testing or lack of
testing, there's no sure way of seeing if the issue is totally resolved.
"
681,CVE-2012-5108,chromium,"A design problem in the way Chromium handled multi-threaded audio output
use of audio output devices resulted in a race condition.  When an audio
output device was first created and initialized, it could be interrupted
and potentially deleted before startup finished, resulting in the pointer
to the callback function being null.  This use of memory after it had been
freed allowed for arbitrary code to be executed.
","Mistakes were made in considering the design of how the audio output device
thread stopped execution and was deleted.  The developers did not count for
multiple flows of execution in separate threads, where execution may be 
interrupted and the audio device may be deleted before it finishes 
starting.  Another mistake here was not checking for null in the pointer
before trying to use it.
"
135,CVE-2010-3246,chromium,Google Chrome's pop-up blocker could be bypassed if a form submit opened window _blank; this would allow a site to gain the ability to open X number of chrome tabs.,"It's hard to say someone shouldn't trust a third party tool that is as widely trusted as WebKit. This definitely should have been tested for, however. A strong negative path test case would have been the abuse case for this bug. The test that's been implemented now appears sufficient mitigation. The fix looks proper."
1227,CVE-2016-1641,chromium,"An image downloading function in a file related to web content could potentially
grab info that was freed out of order in such a way that an exploiter could
cause a denial of service attack. This was demonstrated by a fuzzer with a
favicon download.
","The CWE only gives a few brief mitigations for use-after-free. One is to use a language with automatic memory management, and the other is making sure to set pointers to null after freeing them. The majority of the web contents subsystem built mainly with C++, and it would be incredibly difficult to move everything over to a different language, not to mention the fact that it would probably create some noticeable inefficiencies. The fix actually involved just rewriting the function to avoid the problem area in the third party service entirely.
The main mistake made with this vulnerability was not realizing how the third- party service was touching other pieces of code. Working with a codebase this large, it can be near impossible to cover everything. However, special attention must be made to anything not kept within internal systems.
Luckily, these mistakes were handled quite well once found. Unlike the other vulnerability I had (CVE-2015-1216), this one was actually picked up by a test of some sort (in this case a fuzzer). Along with this, even though the developer working on the bug couldn't reproduce it, they realized that the code still appeared unsafe and went through with assigning it to be fixed. It's important to not just brush off bigger vulnerabilities like this just because you cannot recreate it at first."
886,CVE-2013-6635,chromium,"This vulenrability is located in the editing implmentation of Blink
(the underlying web browser engine). During editing it is possible to
attempt to use a previously freed DOM node and cause a denial of service attack,
or other impacts using Javascript code that results in the removal of said node
during the processing of the Document Object Model tree. The Document Object
Model is a language and platform independent interface that allows scripts and
programs to access and modify the style, content, and structure of a document.
The DOM tree is usually created using the HTML tags and their hierarchy in the
document.
","The main mistake that was made was a coding mistake in the implmentation
of the web engine (Blink) and it's interaction with Javascript code. The
authors of the code base did not ensure the node pointer was correctly
protected and removed from reference after it was expected to be freed.
The authors of the code mitigated the vulnerability by switching from a
pointer, which does not have automated memory management, to a smart
pointer, which is an abstract data type that acts as a pointer but can
also come with automated memory management.

Someone with more experience may have knew that Javascript code could be
executed between the allocation of the pointer and the freeing of the pointer
but the authors implmentated the smart pointer without undue trouble.
"
1189,CVE-2015-6790,chromium,"Chromium did not properly use HTML entities upon saving a page, allowing
offline XSS. Anchor tags with escaped HTML characters following ""#"" in the href
attribute would render as regular HTML entities. This could also be exploited
by a double-quote character inside a single-quoted string. This made it possible
to steal content or CSRF tokens by making a victim save and open a page that
included a crafted anchor or mixed quotes.
","The mistake made was a basic lack of santization. This vulnerability was in a
third party tool and it seemed to recieve little review or testing due to not being
their own code. The vulnerability was quickly and easily fixed once reported, but
the vulnerability existed for a long time.

The fix they applied of sanitizing the data before saving satisfies the standard
mitigation. They could have improved the mitigation by adding unit tests to make sure
it does not regress.

The largest mistake they made was trusting the third party tool. It recieved little
review and the vulnerability was overlooked the few times it was modified. They could have
improved by adding unit tests or conducting a security review of the tool before
integrating it.
"
563,CVE-2011-3925,chromium,"This vulnerability comes from how Chrome handled ""interstitial"" pages which
are the pages that load before or after an expected webpage that have an ad or
ask if you're older than 18. Trying to reload a page when you were on an
interstitial page caused memory corruption in the browser process and crashed
Chrome.
","The actual mistake that was made in the code was that they freed a link
from memory but continued to try to access that memory if an interstitial
page was refreshed. That's a classic example of freeing a variable before
you're actually done with it but that mistake was caused by a number of 
other, larger factors. The code that led to the vulnerability had been
refactored a large number of times and that includes extracting classes,
combining classes, shifting responsibilities, and redesigning how to
internally handle interstitial pages. All of that led to inconsistent and
confusing documentation and small pieces of code that only made sense prior
to their refactoring.
"
725,CVE-2012-5155,chromium,"Chromium doesn't check if Mac OS Xs sandbox successfully initializes,
which means that if a malicious attacker compromises Chromium, the
damage isnt contained throughout the system. This has privilege and
restriction implications. If an attacker uses Chromium to hack the
system it's run on, they could gain access to private files on the
system and possibly run arbitrary code.
","The mistakes that led to this vulnerability were not considering
sandboxing for OSX, when it was considered and used for Windows and Linux.
This could have just been a simple misunderstanding or overlook on the
developers side of things.

The lesson learned from this vulnerability is to check the initialization
of important subsystems/components that could compromise the integrity of
the system if they aren't initialized properly.

The mitigation for the CWE entry is being used,
since if sandboxing on OSX isn't initialized properly, Chromium will shut
down so it can't be compromised.
"
1275,CVE-2016-1689,chromium,"A Heap Buffer Overflow vulnerability was found in Google Chrome's implementation of
Media Capture from DOM elements. DOM (Document Object Model) elements is an object that
includes how the HTML/XHTML/XML is formatted.  Media Capture from DOM elements is essentially just
capturing more information about the users actions on a video, image, etc. which is streamed
back to the application and can then be used for various things. When Google Chrome
added this feature they had a bug where if the HTML media element's given size parameters
were wrong it would not check them, and would just attempt to use them, resulting in the
Heap Buffer Overflow.
","This vulnerability seemed to stem from a lack of design around the desired feature. This
lack of design then caused the software to be implemented to trust inputs which shouldn't
have been trusted. It also seemed that this software was created for temporary use, due
to the fact that the team was waiting for a specific library (libyuv::ARGBToA) to become 
available for use.  This is understandable to an extent, as companies cannot always wait
around for new functionality.  However, this does not excuse the poor design around the 
problem and the lack of awareness of potential input disparities.
"
1181,CVE-2015-6781,chromium,"Integer Overflow that allows remote attacker to cause denial of service or
possibly have unspecified other impact via modified values in font data.
","Looking at the issue report it seemed that it stemmed from a coding mistake
since part of the fix was to make sure that the value in question does not
wrap around when it reaches the maximum integer. When getting the
vulnerability fixed, there was a lot of miscommunications on which team
is responsible for fixing the mistake, which led to the vulnerability to
exist longer than it needed to.
"
161,CVE-2010-4036,chromium,"This is a url spoofing related vulnerability that occurs when the user navigates back but the current page interrupts the action. The browser commits the previous url in the omnibar but the current page is still the second website. For example, if a user goes to www.google.com then goes to www.hack.me, when they attempt to go back chrome will put www.google.com in the omnibar but www.hack.me can interrupt this action with an alert that cancels the navigation but doesn't update the omnibar.
",
857,CVE-2013-2914,chromium,"In the color chooser dialog on Chrome before 30.0.1599.66, 
the listener in ColorChooserDialog did not properly dereference when the 
color chooser dialog was destroyed because of a page destruction (page 
close). This led to a stale reference that attackers could use to cause
denial-of-service.
","The coding mistake was a pretty simple one. The original author simply did
not kill the reference when the page was closed (destroyed). This is essentially
a XSS vulnerability; through this stale reference, attackers can cause 
denial-of-service or attack using vectors through this reference.

The vulnerability was introduced in the initial commit, and was only exposed
after Chrome tried to initially make Aura, an obsolete client meant to provide
notifications and notification details in a client outside of Chrome. The 
original author must have forgotten he needed to destroy the reference so it
couldn't be used, or he didn't notice that he was leaving a stale reference.

For this color chooser dialog, this vulnerability could have been prevented,
but it's an easy thing to overlook. Next time, I'm sure the author will make
sure something like this won't happen again.
"
1253,CVE-2016-1667,chromium,"Web pages are constructed using a tree structure of both nodes and objects.
This tree structure constantly updates as different events occur. One of the
updates that happens to the tree stucture is called a ""node adoption"", when
nodes are assigned ownership (not inserted) to a document.

During node-adoption operations, script execution was not disabled. Since the
document is being modified, attackers may violate the Same Origin Policy.
The Same Origin Policy should only allows script execution between web pages
if both web pages originate from the same origin. When this policy is broken,
an external web page may execute scripting on the web page that is trusted
by the origin. This allows attackers to send data to their web page, from the
trusted page the user is on.
","I believe this vulnerability was caused due to poor design. I don't believe
it should be the programmer's responsibility to think about all scenarios
where something could go wrong when adopting nodes to the dom. I believe if
the Chromium team had used something like a state pattern, where whenever
dom manipulation would occur, the system would be in a state where no
scripts can be executed.

Without this state pattern, it is the programmer's responsibility to think
if the operation might need some sort of disablement of script execution.
As the system scales, and as proven by a similar vulnerability mentioned
in the developers comments to each other, this sort of relaince on the
developer to think of scenarios will just lead to more of the same
XSS vulnerability.
"
185,CVE-2010-4490,chromium,"A malformed video could cause the application to crash by creating an
indexing error.  A malformed video stream could have a stream index that is too
large.  An attempt to index by this stream index would cause a buffer overflow.  In
this scenario the buffer overflow was causing a denial of service because it was
causing a segmentation fault resulting in the tab crashing.  A buffer overflow is
also potentially vulnerable to data corruption or malicious code execution.
","The mistake they made was a logic mistake in which they did not include an edge case
to check for malformed streams which allowed for the buffer overflow vulnerability to exist
due to indexing that may be bigger than the stream size. It was understandable that this 
would be overlooked because the module is complex. In the bug log, they discussed their 
concerns whether a malformed stream could have cause this vulnerability or if it got into
a bad state due a previous root cause."
1273,CVE-2016-1687,chromium,"This vulnerability in Chromium involved the exposure of private 
classes related to Chrome extensions. This vulnerability can be 
exploited and lead to attackers obtaining sensitive information
related to extensions.
","This vulnerability seems like an accidental leakage. From the history of the code
you can see that the initial code was beleived to be hidden but did not end up so. 
The fix that solved this mentioned ensuring ""privates are private"" leading me to beleive
they initially thought it was private. Possibly a misunderstanding of the technology and how
to actually hide information from public. The feature originally was used to hide internal state
of Javascript classes using utils.expose. This ended up having the opposite effect and allowed 
extensions to see private information. 
"
77,CVE-2010-1503,chromium,"A cross-site scripting (XSS) vulnerability in Google Chrome allows remote attackers 
to inject web scripts or HTML using Chrome net-internals. Users can access net-internals
by typing 'chrome://net-internals' in the URL field of the Chrome web-browser, which in return,
displays the network log event stream. This vulnerability occured because user input 
was not HTML escaped. 
","The coding mistake that was made seems to be a simple programming error. 
The programmer in the same commit as the VCC used the function EscapeForHTML 
multiple times prior to the vulnerable line of code. It seems as though he 
then neglected that the string argument ""key"" needed to be HTML encoded as well. 
"
258,CVE-2011-1196,chromium,"The OGG container allows for the streaming and presenting of digital multimedia to users. A OGG 
container is made up of a byte sequence where sections of the sequence represent a different component 
of an OGG page header. Failure to track the index operations are working on can lead to buffer (in this case, heap) overflows 
which can cause a multitude of problems.

The vulnerability starts when an HTML page loads another HTML page in an iFrame. A .ogg file is loaded in the iFrame HTML page and then 
the whole iFrame HTML page is replaced with a different .ogg file. This leads Chrome to crash due to heap corruption.
",It is not entirely clear what the root cause of the vulnerability is. There is a comment in review 6598004 stating that a stream index is mysteriously becoming invalid. This leads me to think that there is some shared mutable data which is not being mutated in a thread-safe manner.
382,CVE-2011-2834,chromium,"A vulnerability where a memory address is freed twice, called a ""double free"". 

Found in libmxl2, the XML parsing library that Chromium is using.

This vulverability can allow attackers to cause a ""denial of service"" attack, where some set of users is no longer able to use the browser. It is not known what sequence of activities could lead to an exploit of this vulnerability.
","The reason this vulnerability existed was a coding mistake. Objects were being freed twice, but in separate locations. This made it very hard to detect the double free vulnerability in the first place. The developers should have been extra cautious when freeing the objects and spent more time tracing through the code to identify the issue. A static analysis tool could have also been utilized to search for double free instances.

Another, perhaps better mitigation would have been to set the pointer to the object to NULL after freeing it to ensure that it was not freed twice.

The fix does not look proper. Error states were added to prevent the code from entering the code block that causes the double free. But, the fix doesn't remove the possibility of the double free. If an attacker was able to manipulate the state of the system and avoid entering the error state, the double free would still be possible.

The developers fixed multiple related double free issues within the same source code file. It would have been smart for them to check the rest of the file for any other double free vulnerabilities when they were fixing the first issue instead of fixing the issues one by one."
280,CVE-2011-1305,chromium,"This vulnerability affects only Linux and Mac OSX users. An attacker can
cause a denial of service via certain aspects that use linked lists and
databases. This is caused from a race conditions found in a WebKit patch
that eventually lead to crashes. Mutexes that were originally in place to
prevent agianst race conditions were removed because they thought the WebKit
 code interacting was SQLite was single threaded and would not need to
 worry about race conditions.
","The way this came about was using a faulty patch of WebKit interacting
with the rest of the code that interacts with sqlite. This could have been
avoided if there was a more thorough analysis of the patch before moving it
in. Since the fix was to revert to how things were beforehand, this all
could have been avoided if there was a comprehensive test with the new patch
before integrating it.
"
1062,CVE-2015-1228,chromium,"There is an update counter method being called with a text updating 
method. The bug-causing method updates the counter, but does not set the node
for layout or reset. As a result, some stale text boxes may be left behind 
after the program is complete. This causes variables to initialize incorrectly 
(or fail to initialize at all) on following sessions, causing 
the program to crash when it tries to use the variable (denial-of-serivce).
Attackers aware of this vulnerability could work to trigger the crash
intentionally. A different text updating method that marks the node
for layout is used as a replacement, making sure all the right 
validations are made and no stale/uninitialized text boxes are left behind.
","The mistake was a simple design mistake at the start of the project.
The team used a method that didn't clear the stale data of certain
text boxes. The mistake was probably due to not testing that area and
proper unit testing would have found likely found it early on.
The mitigation, build and compilation, was used via a change of
method once the vulnerability was found through fuzzer testing. 

Note that this may also have been an implementation error, as the
initial method they used is very similar to the fixing method
except that the original method does not perform validation
checking. It is possible that the initial method used simply did
not do what was expected.
"
43,CVE-2009-3934,chromium,"A function in the WebFrameLoaderClient allowed for remote attackers to cause a
denial of service from a page-local link. A page-local link is a link that
redirects back to the same page when interacted with. This is directly related to an
""empty redirect chain"" which allows attackers to endlessly redirect urls. For
this vulnerability to be taken advantage of, the attackers abused the page-local
link which would redirect back to itself endlessly.
","A coding mistake was at fault for the cause of this vulnerability. There was
a piece of logic ""ds->hasRedirectChain()"" that was always assumed to exist
in the vcc. By not checking to see if the logic existed, it allowed attackers
to take advantage of a denial of service vulnerability by redirectly urls
without a limit.

Essentially only a single line of code was missing to fix the vulnerability.
Before running through the logic, an if statement was required to make sure
that ""ds->hasRedirectChain()"""" existed before continuing on with the logic.
"
182,CVE-2010-4487,chromium,"This CVE affects OSX and Linux.
An attacker could create a page that would serve a response with a 
'Content-Disposition: attachment' for a file with an HTML extension. The 
'Content-Disposition: attachment' forces the download dialog to appear, and it 
auto-selects the attacker's malicious HTML file. If the user clicks the file name 
in the download dialog, the malicious HTML file loads and downloads a SWF file to 
the user's downloads directory. 'setTimeout()' can then be used to delay the 
loading of the SWF file until after it's finished downloading (~5 seconds). Once 
the SWF file is downloaded, the attacker loads the SWF file which is written to 
grab the contents of /etc/passwd and displays the contents of the file to the 
screen. Now that your sensitive information is written to the browser, it can be 
easily transmitted back via JavaScript.
","I believe this mistake happened because the developers finally finished the download_exe.cc file, and forgot to fill out a complete blacklist for non-Windows operating systems.

There are two mitigations provided for this CWE.
The first is to use both a blacklist and a whitelist, but that wouldn't be a good idea for this scenario because you can't predict exactly which file extensions people want to pass in a 'Content-Disposition: attachment'.
The second is to not rely exclusively on blacklist validation. For this particular CVE, I believe a blacklist is just fine.

They did not use either of these mitigations. They only had to add more extensions to the file extensions blacklist in order to fix the vulnerability.
"
160,CVE-2010-4035,chromium,"There was a bug in the autofill and translation features which could allow attackers
to cause the application to crash remotely, therefore introducing a 
denial of service vulnerability. This crash is caused by accessing a pointer
after it was freed. The reason this was possible is because of the way the chrome team
was using a scoped pointer for management of an 'infobar' delegate pointer. Scoped pointers
have automatic memory management, which seems to have cleaned up the pointer while it was
still in use.
","This problem seems to be caused by a coding mistake. For both the subsystems
that the vulnerability existed in, the problem involved incorrect usage of 
pointers. Low level languages where memory management has to be done manually
can be tricky, it would be shocking if no such errors ever occurred inside a
project as large as chrome. What's interesting about this bug is the fact that
automatically managed pointers (which are supposed to make things easier) actually
caused the bug to happen. Because of this, the team decided to do their own memory
management, which they could have more explicit control over.
"
1233,CVE-2016-1647,chromium,"The navigation implementation in Google Chrome causes use-after-free vulnerability
and allows remote attackers to cause denial of service, the bug allows
unauthorized disclosure of information, allows unauthorized modification
and allows disruption of service.
","The mistakes that led to this vulnerability were coding and design mistakes. When a fullscreen
widget is created, a WebContentsImpl stores its routing id in fullscreen_widget_routing_id_.
WCI assumes that this widget belongs to the process of the current main frame:
GetRenderManager()->current_host()->GetProcess(), which it normally does. A compromised
renderer can swap the process of the main frame, while keeping the fullscreen widget alive.
Normally, the fullscreen widget would be deleted as the renderer navigates, but there
is an exception. If the navigation was within the page, then the fullscreen is kept alive.
This happens for example when only the url fragment changes.  In such case, renderer sets
FrameHostMsg_DidCommitProvisionalLoad_Params::was_within_same_page = true and the
browser mostly trusts that, even if the the navigation wasn't within page and the
process was swapped. If the renderer swaps the process and sets was_within_same_page = true,
the fullscreen_widget_routing_id_ will end up pointing to a wrong widget in the new process.
If the renderer now closes fullscreen, this wrong widget is deleted. It is deleted manually
in RenderWidgetHostImpl::Destroy(), because fullscreen widgets aren't owned by a smart pointer.
Normal widgets are owned by a scoped_ptr render_widget_host_ in RenderViewHostImpl though.
If such a widget is manually deleted by an attacker, the scoped_ptr in RVHI ends up holding a
dangling pointer.
"
322,CVE-2011-1813,chromium,"A piece of data is created on the heap, and there are multiple pointers which can point to this data. While the browser is used, JavaScript allows certain parts of the webpage to be adopted by others. In this particular case, an iframe is being 'adopted', and the pointer that points to this iframe is not being adjusted. The pointer now points to an invalid piece of data which crashes the program.","The developers should have written better comments so that maintainers and other developers can catch where pointers are pointing to, and be able to tell when a pointer is left dangling. It's quite difficult when one is writing C++ code of this complexity, especially in the case where pointers are being passed around as a result of JavaScript code. I have a feeling Valgrind, or another internal test should be able to look for data on the heap that has pointers to it, and should check for when that data is freed if there are any pointers that could be in danger of growing stale. Also it seems like there was a test that might have been enabled at some point that ended up catching the crash, perhaps disabled in another commit before the VCC and not reenabled until after, although I couldn't find out which commit did so."
411,CVE-2011-2864,chromium,"The vulnerability was Google Chrome before 14.0.835.163 in the way the 
third-party software Harfbuzz handles Tibetan characters. 

HarfBuzz is a software development library for text shaping, which is the process
of converting Unicode text to glyph indices and positions.

The implementation didn't handle the case when the character is out of the Tibetan
characters table's bound. At best, this causes a crash. At worst, this kind of 
vulnerability can lead to arbitrary read or write operations to be performed on
unauthorized memory locations as it is a ""buffer overflow"".

This is possible in a Cross-Site Scripting (XSS) scenario. An attacker may be able 
to execute arbitrary code or unspecified vectors, alter the intended control flow, 
read sensitive information, or cause the system to crash.
","The coding mistake that was made in a third party software that led to index out
of bound error.

The coding mistake was made in a piece of third party software that led to an 
index out of bound error. This approach is important because it is hard to 
investigate and manually debug third-party codebases for memory corruption errors."
894,CVE-2013-6643,chromium,"Improper Authentification handling in Google Chrome's signin popup. The
vulnerability allowed remote attackers to send a malicious URL to a victim and
insert his/her account to the victim's Google Chrome to sync the victim's
private data without the victim's knowledge. The attacker could close an
untrusted signin confirm dialog which would sync the user's data.

The fix for this vulnerability is to cancel the signin when the untrusted
signin confirm dialog is closed without the user clicking 'ok got it'.
","The vulnerability here was a simple oversight on what to do when the
untrusted signin confirm dialog is closed without clicking 'ok got it'.
Originally continued the signin as if 'ok got it' was pressed'
The fix was to abort the signin if the untrusted signing confirm dialog
was closed without clicking 'ok got it'.
"
1343,CVE-2016-5166,chromium,"Using the 'save page' feature that saves the web-page and web 
resources also saves locally uploaded files to that page.  
","This seems to have been a case where at the start this wasn't a vulnerability but as other 
technology got layered on top of it like chrome extensions and web-workers it became a
potential vulnerability from using this newer technology to exploit older ideas.
It started out as just a normal feature but later on in the programs life, due to expanding functionality 
it became a vulnerability later in time and would probably now be considered a design mistake. 
"
1211,CVE-2016-1625,chromium,"Due to a lack of checking against intended target web addresses, malicious 
extensions are capable of changing where suggested links brought users when 
clicked on. This allows extensions to navigate users to malicious websites, 
or run Flash programs on the host device. Remote attackers could then use 
this to grab any file from the host device.
","This vulnerability arose from the new functionality added to the NTP,
where Chromium provides the user their most-visited sites and some suggested
ones, without checking that the target of the link was the same as the link itself.
Ultimately, this was a design mistake, because the developers never
thought that such an attack would be possible, and while no exploit of this
bug was ever created, it could have had huge consequences if it ever was.
Additionally, between when the vulnerability was introduced and its fix,
the subsystem was moved around, allowing the bug to hide longer than normal.
"
152,CVE-2010-3415,chromium,"The Geolocation module was causing memory corruption to occur
due to it being able to write to a location outside the intended boudaries
given.
","A few design mistakes lead to this vulnerability happening. The issue was storing an object
in an inccorect place, then when they were to be accessed they had old values. This
could be prevented by a simple code or design review.""
"
393,CVE-2011-2845,chromium,"An attacker can use this vulnerability to spoof the value in the URL bar. This means the victim could be rerouted to a different website, but still see their intended address in their URL bar.  This only occurred when navigating to a different area of the same page, known as a page fragment.","The mistake here was that there wasn't proper communication between the NavigationController and the Renderer.  Since the NavigationController needs to communicate with the HistoryController to figure out where to go when the user presses the back button, this allowed time for a race condition to form that confused the NavigationController into allowing stale entries."
1226,CVE-2016-1640,chromium,"When a chrome user tries to install an extension from a website, that
website could redirect to another website and still show the extension installation
dialogue started from previous website.
For example, a crafted website could show a link to install an official
extension from some service say Google, and when user clicks on it, the chrome
will take you to the Google support page and will be prompted with an extension
installation dialogue initiated by the crafted website. The presented extension
could be a fake extension intended to be an attack. The user would think it's official
one given that user is on the official support website. The dialog doesn't show
the origin, so it gives even more credibility to the attack.
Poor design decisions led to this vulnerability. This vulnerability would not have occurred in the first place
if they had thought about showing the origin of the install dialog and considered killing the dialog when redirected to different website.
","I believe this vulnerability has to do with design and requirements mistakes.
If requirements had mentioned that this behavior shouldn't have been allowed, the code
could have been implemented that way. However, I can understand it's impossible
to think about all the scenarios on requirements. So, that's why if proper design
decisions were made regarding how to handle such scenario when user navigates to different
page or when user is redirected to different page.
Based on bug report, it seems like they had made better design decision for next version of Chrome.
This vulnerability needed medium-level security attention because the install dialog
didn't show the origin and users could be tricked into installing malicious extensions. So, the initial fix seemed like a hack,
where they were simply trying to mitigate this problem for now. Second fix improved the previous fix however.
The final solution for this was to redesign the architecture of how the dialog is shown. A comment on the bug report indicated that
they were planning to redesign the dialog, so looks like they knew the proper mitigation for this problem.
"
1254,CVE-2016-1668,chromium,"The custom layout web framework that chromium (Blink) creates a global proxy
objects which changes its type during runtime. When it changes, it
bypasses Same Origin Policy (allows one web page to access data/resources from
another webpage as long as they have the same origin), which can allow
malicious attackers to run arbitrary JavaScript code to access private
resources.
","This vulnerability occured when the original creator of Iterable.h had a
simple coding mistake, didn't fully understand software engineering
security, or didn't fully understand how to work and code with v8 objects.
It was a line of code that got the job done but came with security
implications if used correctly by a malicious attacker.

The lesson learned from this vulnerability is fully know and understand
the objects that you're working with, and to have defense in depth.
"
1023,CVE-2014-7935,chromium,"The tts_message_filter.cc file in versions of google chrome before 40.0.2214.91 had a vulnerability that would
try to use memory immediately after it had been freed. This would allow attackers to
use the text to speech utterances to crash a user's current tab in google chrome and possibly
execute other attacks such as executing remote code.
","After looking at the fix in the code, this is obviously a coding mistake. It is a coding mistake
because they used the weak_ptr class to prevent a UAF, but the weak_ptr class was the part of the code
that was allowing the use after free vulnerability to occur. If the team had done more thorough
testing with their unit tests and their automation tests, I believe that they would have found this
vulnerability a lot sooner. Looking at the possible mitigations for the CWE and the fix for the code,
they didn't change their code language or set their pointers to null after being freed. The second one
can be excused though because it uses a complex data structure.
"
492,CVE-2011-3092,chromium,"The vulnerability was in Google's Javascript Engine, *V8*, in the way they
handled regular expressions (""regexes"").

The implementation, which was in Javascript but called native C code, didn't
handle ""capture overrides"" properly. This resulted in data be written to
memory that it was not intended for (an ""invalid write""). At best, this causes
a crash. At worst, this kind of vulnerability can lead to arbitrary code
execution as it is a ""buffer overflow"".

The way that this could be exploited would be if an attacker had access to
writing Javascript. This is possible in a Cross-Site Scripting (XSS) scenario,
or if someone simply went to an attacker's page with Javascript that exploited
this vulnerability.
","The coding mistake that was made was essentially an integer overflow that
led to miscalculating memory buffers. The mistake was not in the underlying
native code, rather, it was misusing the C API. So the fix was actually in
the Javascript implementation of regexp.

The vulnerability was introduced over two commits, but really by one person
who was working on trying to fix this boundary condition. He wasn't
working on a vulnerability per se, but they were working on a boundary
condition and still missed this one condition.

For this part of V8, a lot of decisions have been made about changing what
is handled natively and what is handled in Javascript itself. Navigating
what exactly are the responsibilities of native code versus the built-in
Javascript libraries is going to be the key to preventing vulnerabilities
here.
"
131,CVE-2010-3117,chromium,Chrome crashes on shutdown due to the notification UI manager not being closed early enough.,"The issue ultimately stems from not having kept track of the lifespans of an object's dependencies when modifying the object's own lifespan. Additionally, the impact of the issue was enhanced by it providing a potential sandbox escape for an attacker, which didn't need to be the case.
"
1284,CVE-2016-1698,chromium,"The function that allows an extention to create a custom type,
createCustomType, doesn't actually validate the module type. 
Since the type isn't ever validated, there's the risk of 
loading in arbitrary modules and disclosing sensitive 
information to the attacker because the definition of the module
was not handled properly.
","There was a big design mistake in allowing the use of multiple types 
without validating what types are actually safe when initializing. 
Other parts of the code depend on the setup to work exactly as intended,
and, without this validation, other parts of the code won't work in
the way that they should. While this fix is hard-coded, the addition
of a whitelist is a huge step in the right direction. There could be
a better way to implement this whitelist rather than a hard-code 
within the type creation, however, although keeping that data
secure is very important.
"
1043,CVE-2015-1209,chromium,"A crash can be forced from crafted java script that can be exploitable. The
crash occurs in Chromium's underlying c++ code when freed data is accidentally
read. The JavaScript causes this crash by adding an element to the DOM,
altering certain fields, removing it from the DOM, and then trying to
access or modify certain fields after the element has been removed. This last
step can occur in the process of removing it from the DOM without any additional
javascript code written by a user depending on the previous steps. In other
words, a html file uses javascript to dynamically add an elelement to itself,
remove it, and then continues to modify it. Once it is removed and
you try to access an old element, Chromium will access memory that has
already been freed using a bad pointer. This will trigger Chromium's
AddressSanitizer which will then stop Chromium before something even worse
happens. AddressSanitizer may not have always caught the error and arbitrary
code execution was possible.
","The mistake was not considering all of the possibilities. It was first and foremost, a design  and requirement mistake,
but also a coding mistake since it was designed with the possibility of freed memory being accessed.
Additionally, this vulnerability touched two different people through its lifecycle. One committed the original bug 
and another person fixed the bug after 11 years. The fix did not set the freed element to null, but 
the added checks did satisfy the mitigations mentioned in the CWE.
"
1055,CVE-2015-1221,chromium,"The vulnerability found in Google's Blink Engine allows attackers to remotely
impact service by referring to finalized objects using the misordering of
database thread shutdown operations. This could lead to denial of service or
other unspecified impacts.
","This vulnerability was the result a small coding mistake that create a
large security impact. The fix was very simple, involving just adding a new
function and function call to terminate a thread.
"
1058,CVE-2015-1224,chromium,"An image decoder does not ensure that alpha-plane dimensions are identical to image dimensions. This allows a remote attacker to cause a denial of service attack through an out-of-bounds read.
","This vulnerability was a bit of a miscommunication and design mistake. Initially, they did have support for video streams with alpha buffers larger than the image buffer, but the library changed a year after the first implementation and introduced this vulnerability. They didn't account for that and this vulnerability was introduced.

The code written to copy video data from the buffer assumed that the image and alpha plane had the same dimensions and stride (buffer width). According to the video format, the dimensions must be the same, so the writer of the code assumed valid input without doing a check. When a video plane's dimensions differed from the alpha plane, the stride was also different. The code to copy the alpha plane used the stride from the video plane, so the incorrect amount of data was read, causing the overflow. Interestingly, the strides of the video and alpha planes can differ even if they have the same dimensions. This means that a buffer reading issue may occur even with a valid VP8 video. The reviewers of the bug noticed this issue, and it was fixed along with the dimension check.

To check for malformed VP8 data, they added a check that threw an error if the alpha plane dimensions were different than the image plane. This fix adds input validation, which is the primary mitigation listed on the CWE-125 page.
"
191,CVE-2010-4575,chromium,"A program extension created with malicious intent can close windows if installed by another user. This is
considered a Denial-Of-Service and may cause an application to crash if the user completes a specific set of tasks in a
certain order.
In the case of Chromium, the user could install an extension that serves they believe serves another purpose,
but is meant to exploit this vulnerability.
","It looks like it was simply a coding mistake that was made.
"
1068,CVE-2015-1234,chromium,"This vulnerability was a consequence of how the GPU and the native client application
interact with each other. Essentially, they communicate using threads and shared
memory to send commands and receive return values. The problem was in a specific
block of code that accessed a specific resource in untrusted shared memory.

There was a race condition where multiple threads were trying to access and/or
modify the size of a shared resource, so if the timing between the threads was
not perfect, it would be possible to access this resource, validate it, and then
later modify it to cause a buffer overflow, which means that an attacker could
potentially execute their own piece of code. So while there is a buffer overlow
issue here, it is mostly the race condition that allows for this vulnerability.
","I feel that this vulnerability was more of a design mistake, followed by maintainability
issues. There is quite a bit of reliance on untrusted shared memory here because of the
way that the different processes communicate with each other, and this is part of the
architecture for this application, which means it is very difficult to change. This
reliance, combined with the complexity that comes naturally with concurrent processes,
exposes the application to a myriad of issues that may be very difficult to identify.

Moreover, there were multiple code design flaws that overlooked the atomicity of certain
operations in the code. In other words, by looking at the VCC and comparing it with the
fix, it seemed like the original code was using the ""easiest"" path to retrieve data in
shared memory, even when these operations were not atomic and introduced the possibility
of race conditions. And since this code had been present for years before the fix, it
propagated to other parts of the system. In fact, there was even some discussion in the
bug report about volatile memory in other parts of the code that was not identified as such,
so this vulnerability exposed other maintainability issues that required more time and effort
from the developers.

Finally, the fix seems to implement some proper ways to deal with the race condition issue,
specifically the use of volatile type modifiers in the code to indicate the use of untrusted
shared memory. In addition, the fix also introduces a better use of atomic operations by avoiding
having to calculate, access, or write to shared memory more times than is necessary.
"
897,CVE-2013-6646,chromium,"The implementation of a database observer causes Chrome to crash due to an invalid
pointer error when multiple databases are opened in the observer at once due to a
script continuously reloading from the multiple shared worker methods (scripts)
created by the multiple databases. Specifically, a variable is being passed into the
observer after the worker's thread has already ended. This opens up a User After Free
(UAF) vulnerability, a type of memory corruption bug that, in this case, opens up the
possibility for malicious users to cause a denial of service attack by shutting down
the worker processes related to the worker methods.
","Although most crashes can be attributed to questionable coding practices,
this one was ultimately caused by what I believe to be a design mistake:
allowing multiple shared worker events to occur simultaneously without
understanding the potential problems that could present. The fact that not
one, but two issues came up involving UAF vulnerabilities regarding shared
workers showed they overlooked elements of their design. This is corroborated
by the fact that one of the developers didn't realize that the bug was
occurring at the process exit, causing them to think the priority of the bug
should have been lower than it realistically was. There's even a point where
a ""class of worker bugs"" is mentioned, implying it could have been even larger
than just these two issues.
With that said, the fix does seem to be proper as the developers have fixed
the core issue which was understanding when the proper point to kill a 
worker process was."
192,CVE-2010-4576,chromium,"Improper handling of certain code calls allow for a denial of service (DOS)
type vulnerability. In this case, the DOS vulnerability is caused by a null
pointer exception which could be triggered by using crafted JavaScript code
that creates a web worker.
","This vulnerability was the result of a simple coding mistake. The writer
did not include a null check. This could be avoided by more thoroughly
checking the input. Code reviews could also help prevent simple coding
mistakes like this.
"
1326,CVE-2016-5149,chromium,"To understand this vulnerability it is important to understand what an iframe is.
In HTML pages, there is a tag called ""iframe"" that essentially loads a different
web page and embeds it in its ""parent"" page, which is the current HTML document.
These iframes can be used for a variety of things, like embedding media into a
web page or embedding applets into a document.

This vulnerability is related to iframes in that it allows attackers to exploit
the slow loading times of an iframe to run arbitrary content scripts in the iframe's
parent page. More specifically, this vulnerability is only related to Chrome extensions.
If the source URL of an iframe is set to be ""chrome-extension:// URL"", the attacker
can inject javascript from the parent page before the frame has loaded and essentially
spoof chrome extensions. For instance, one would be able to access chrome extension APIs,
steal authentication cookies, bypass security measures, and even send fake messages to
other extensions under the name of a legitimate extension.
","I think that the biggest issue that came up during this vulnerability's life span was,
by far, how long it took to react to it. According to the bug report it took over
6 months to resolve this bug, which is an unbelievable amount of time for a
high-severity and high-priority bug like this one.

The fix involved some simple validation and some new tests, which may indicate an oversight in the
original VCC, although this vulnerability would have been difficult to predict
since it relied on a race condition. However, it was a severe lack of communication
that lead to this vulnerability living as long as it did. There were long periods of time
where there was little to no effort being put into resolving this bug, which exposed
this application to really dangerous spoofing attacks.
"
248,CVE-2011-1186,chromium,"Chrome on Linux had a bug where if two calls to open the print dialog to choose a printer were made in parallel, it could crash.  
If a bunch of print commands were issued at the same time, they might be executed in parallel.  This was a potential DOS flaw.
","This one was tough to call a mistake because it was highly unlikely to occur except during debug.  Printing almost never happens concurrently, and 
it was only occasionally reproducable anyway.  The mistake was assuming that the printing was always thread safe.  They chose not to fix the issue 
because it would have required more work than it was worth.  Instead, they just fixed the particular issue so that it would go back to looking like it worked.
"
919,CVE-2014-1700,chromium,"This involves a use-after-free vulnerability in the modules/speech/SpeechSynthesis.cpp
file of Blink, a component of Google Chrome. This vulnerability allowed remote attackers
to cause a denial of service using the utterance data structure contained in the module.
An utterance is a continuous piece of speech without pause. This is fitting since it is used
in the speech module of the Blink project.
","Utterances weren't properly being ended before starting another utterance.
This created a use-after-free vulnerability since the utterances could still
be accessed even after the memory was freed. Attackers were able to take
advantage of this to cause a denial of service attack.

The system was supposed to be asynchronous, so that only one utterance was
being used at a time. However, the next utterance in the queue would
sometimes be called before the previous one was removed from the queue. The
fix for the mistake involved changing the logic, so that it was ensured that
the system would be asynchronous.
"
922,CVE-2014-1703,chromium,"A piece of memory in the WebSocketDispatcherHost::SendOrDrop function was used after it was freed. This file primarily deals with the creation of web sockets between the server as well as sending and recieving messages. The function in question dealt specifically with sending the message.
By comprimising this function, it could have allowed remote attackers to control arguments of the DeleteWebSocketHost if the memory is reallocated.","The issue here is pretty clearly an issue with not allocating memory correctly. This is something
that could have been avoided by implementing proper unit testing. The issue only really would have
been detected by a fuzzer, which is how it was found. However, it doesn't appear that any effort
was made to make sure that the issue would never happen again; That is, no new unit tests were created.
"
800,CVE-2013-2842,chromium,"When a frame was removed from its parent frame, it could still be referenced.  This could lead to a use-after-free error.  
It could cause a DOS or potentially give an attacker the ability to interact with the user's computer by breaking out of the
assigned memory buffers into other memory locations on the computer. 
","The mistake was that they freed a portion of memory that went along with a frame in the renderer, but they did not remove all references to it.  
The fix was to check the frame before it was used to make sure that it had not been freed yet.
"
1117,CVE-2015-1284,chromium,"This vulnerability is caused by the blink functionality of Chrome not checking
for exceeding the maximum frame amount after the amount has been set. This allows
an external attacker to create a denial of service attack by creating more than
1024 frames which reads from memory after being freed.
","The mistake that lead to this vulnerability was checking the value in the
input then storing the value in the input, instead of the other way around.
This allowed an attacker to create a script with more than 1024 frames which
is more than the system allows for and would try and access memory after it
had been freed and crash. This creates a denial of service. This is a coding
mistake which should be caught with code review. The fix looks proper because
it adds a check with security consequences rather than just checking the input.

The potential mitigations for this CWE are to choose a language that provides
automatic memory management, which isn't really an option in this case. The
other mitigation is to set pointers to NULL after freeing them, however, the
fault that results from this is part of the vulnerability.
"
1127,CVE-2015-1295,chromium,"When opening a PDF file into chromium, the client would pause for the few seconds and give a message. Upon hitting OK or escape, chromium would crash. This was due to the program not handling ICP correctly.","The vulnerability seemed to be caused by a lack of managing input. Because the file didnt' correctly handle nested ICP people were potentially able to cause crashes by printing out messages. The vulnerability alone was already causing issues alone just by a user loading up a specific file. In short, always make sure your design is able to handle any potential input it may recieve.
"
813,CVE-2013-2858,chromium,"There is an vulnerability in versions of Google Chrome before 27.0.1453.110 where
the HTML5 implementation of audio would try to use memory immediately after
it had been freed. This would allow attackers to crash a user's current tab of Google
Chrome.
","I believe that this was a design mistake on the part of the team, after looking at the fix and the vcc and what was changed.
It seems as if the team never thought that someone would try to programatically change the audio source, so they had to redesign the client implementation of the web media player to
include a mutex and other states to make sure that the memory is not being used immediately after it is freed.
"
18,CVE-2009-1414,chromium,"Google Chrome 2.0.x allows for global objects to persist across page transitions, allowing for easier Univeral XSS attacks. Launching Chrome with a URI doesn't overwrite gobal variables on asynchronous load of pages
","Coding mistakes in conjunction with code rot resulted in improper argument parsing allowing for code injection. The use of URIs for launching Chrome required a URI parser that allowed for misuse of Chrome though the lauching of unspecified pages by an outside script. Due to this unintended access the use of Chrome URIs was deprecated and removed in the fix
"
1140,CVE-2015-1361,chromium,"This vulnerability was in Chromium's third party tools for image decoding.
It consisted of an uninitialized variable being utilized in a constructor
and was found automatically by a ""fuzzer"", a static code analysis tool
that analyzed the code and identified the issue.

In a general sense this vulnerability can lead to things like crashes when
trying to utilize a segment of code that calls upon the unitialized value.
However, in this case the uninitialized value was initialized in the
constructor of the class it was being used in making this functionally
an optional variable in its usage. There was literally no impact in
operations the only thing is that any static analysis tool would have been
unhappy.
","This vulnerability is simply a coding mistake and a very simple one at
that. Any static code analysis tool should have picked it up and I assume
the only reason it was not fixed for so long is because it literally had no
effect. The uninitialized value was initialized in the constructor of the
given class making this functionally an optional variable in its usage.
There is literally no impact in operations the only thing is that any fuzzing
tool will pick this up and be unhappy. The developer of the fix even says its
simply to prevent tools from picking on it in his comment ""initialize m_hasAlpha
to some value before calling the operator lest any tools complain about using
an uninitialized value"". There are no mitigations beyond pay attention when
coding and be sure to initialize all variables.
"
212,CVE-2011-0485,chromium,"Speech data input not properly handled. When unspecificed speech data is processed with speech input disabled,
arbitrary code can be executed, creating pointers to freed memory, aka stale pointers. Attempts to use stale pointers
can crash the system, and cause unexpected behavior.
","The mistake here was not handling the case when a feature was disabled or not intended to function, and accepting
any input when at least part of the input can be expected to be finite. Part of the solution was to whitelist a portion of the input,
as recommended as a mitigation strategy.
"
9,CVE-2008-6998,chromium,"Google chrome had a problem when a user typed in more than 128 chars in the url, 
then hovered over the url. The url preview should show up but the backend array 
that held the url typed in would overflow and shut the system down. It could also 
lead to users getting a pointer to the current method. Then telling the code to go 
somewhere the attacker's code is planted and run arbitrary code after the system crashes. 
","This was both a design and coding mistake. I think this was a design mistake because they 
had other overflow problems that followed with the commit of the url overflow problem. So 
they were missing a crucial check of array size in their code. Which means they were overlooking 
the problem entirely. This could also fall into the category of coding mistakes because nit pick
errors don't really belong in the design phase.

Some extra fixes they should add are making sure the user inputs are always checked with white 
and black lists. This will solve problems before they even come up. Solving the problem as they 
show up when the system is released is much harder to spot all the errors. Implement the checks 
and input validations as they were programming. 
"
216,CVE-2011-0779,chromium,"Google Chrome does not properly handle a missing key in an extension, which
allows remote attackers to cause a denial of service (application crash) via
a crafted extension.  When an extension is packaged, the extension is assigned
a unique key pair. The extension's ID is based on a hash of the public key.
The private key is used to sign each version of the extension and must be secured
from public access.  A variable that gets initialized in the extension unpacking
service is sized based off of the extention's header signature size, so if a hacker
removed the signature (by providing an empty key), it would get initialized to zero
and cause a crash of the system since it was unexpected, leading to a denial of service.
Basically, the bug was introduced in the process of refactoring the code to pull the
logic for unpacking extensions out of a service that was too complex, and the writer of
the new file to handle the new logic forgot to check to make sure that a variable being
initialized would not be initialized to 0 bytes.
","There were many other tests being performed in the code around the header size, a
test to check if the header was size zero was never included however.  As far
as I could tell the author of the code was refactoring a large portion of the
system.  What they could have done better was to not assume user provided
content was not any range of unpredictable values (like 0) (the header is
attached to an extension which can be developed by users).  However, because
other checks were in place in the code to check the header size, I think that
this edge case should have been considered by the team too.  Especially when
initializing a variables size, some checks should always be if the size is based
on some kind of user driven input.  If the size is driven on user based input,
could the user find a way to provide a huge value (overflowing a buffer), or
could the user provide a negative value, or even a zero value.  The team should
have checked all three use cases rather than just the max size case.
"
1165,CVE-2015-6765,chromium,"An attacker could have the url that is being accessed
to be deleted hence causing the browser to crash. If a user is accessing
a url/link, in this case, it would crash due to the same. This is caused by an error in storing
entries and fetchers allows attacker to overload the pending list of entries and crash the browser,
while running fetcher allows for UaF (user after free). This vulnerability is also known as the browser
crashing bug.For example, referencing memory (say a link) after it has been freed (deleted/destroyed)
would cause the browser to crash.
","This seems to be another one of those mistakes that developer forget to have a complete
test plan on. I would say more of a design mistake with a mix of requirements and coding.
This is a critical vulnerability and the developer should have been more aware of these
cases when thinking about the tests plan and the design of the system. This can lead to
some serious issues.
"
969,CVE-2014-3166,chromium,"Provided with this vulnerability, attackers would be able to leverage multiple
domains to access sensitive information. Pooling with multiple domains allows
an attacker to bypass Public Key Pinning (PKP) on sites. By bypassing PKP on
sites this opens up an information disclosure vulnerability. Examples given 
show that it was possible for a malicious actor to pretend to be any website 
by exploiting this vulnerability. For example, the reporter provides a 
screenshot, demonstrating that www.twitter.com was displaying their own
content rather than the real twitter site.
","The main mistake that lead to this vulnerability appears to be an oversight
in a check to allow invalid certificates to become pooling candidates. There
are two levels at which this mistake could have likely taken place. Firstly,
there these checks, it seems, had been thought about before, but nonetheless
overlooked. Poor documentation of risks/requirements at the team management
level could be to blame here. And secondly, at the coding level if the
developers had had this issue in mind, they would have likely accounted for
it when it came up, before.

The fix for this vulnerability follows the CWE potential mitigation. That is
to say, in separating/centralizing the checks that is separation of
privilege. However, this isn’t exactly directly significant to this specific
vulnerability.
"
972,CVE-2014-3169,chromium,"A piece of data in core/dom/ContainerNode.cpp, which is used in Chromes blink web engine, 
could allow remote attackers to cause a denial of service under certain conditions 
as well as have other effects by messing with script execution before the node removal. This
file is used as a part of Blink's Domain Object Model, which incorperates the brower's logic when
storing amd displaying HTML/CSS.

The team never really seemed to pinpoint the actual issue here. They only pinpointed the
solution it seems. That is, they never were able to reproduce the actual bug.
","As I said above, its hard to discern what actually caused the issue since they never really pinpointed where the actual bug was. This was a simple coding mistake though, one that likely could have been avoided with proper unit testing. However, it did provide a useful enough error message that it was able to be fixed.
I think the biggest issue here would be that it seems like this bug was identified beforehand, but was not inserted into the proper workflow to get it fixed and so it never was. This bug could have potentially never been found had the fix been submitted as separate issue when it was originally found."
179,CVE-2010-4484,chromium,"There is an improper closure of WebSQL databases
(a web page API for storing data in databases that can be queried using a variant of SQL.)
in incognito mode which allows the attacker to write
a script that opens the databases well over the quota limit thus causing a denial of service.

An exanple script would look like this:
<script>
    function runTest() {
        try {
            var db = openDatabase('OverQuotaOpen', '', '', 10000000);
        } catch (err) {
        }
    }
  </script>
  <body onload=""runTest()"">

The fix for this was to simply close HTML tables in incognito mode once finished. The original issue in the code
was that the author was actually negating the line of code for closing databases.
","The mistake was not severe but it did lead to crashing the chrome browser in incognito. The mistake was
primarily a coding mistake by forgetting to take off a negation applied to closing an HTML database after use.
The fix was very simple and the vulnerability was mitigated by freeing up the memory. In this case the freeing
was more so ""closing"" the database after it was called. The issue was more of a human error by including a
negation where there was not one needed.
"
1183,CVE-2015-6784,chromium,"Chrome offers a feature that allows you to download web pages to your local
machine, and later open those webpage files off of your local machine. When you
download a webpage to do this, chrome adds a comment at the top to show the
url that the page was downloaded from. This url is not escaped when it is
added to the document, therefore an attacker can construct a url that contains
code that can modify the page or exfiltrate data from the page.
","The major mistake made is that input was accepted from a user and added in
to a document without being sanitized. It is important to think about what
types of input could cause problems and sanitize for those. Always consider
abuse and misuse cases when you are dealing with inputs that are coming from
outside of the boundary of trust of the application.
"
183,CVE-2010-4488,chromium,"This bug involves an unhandled case in which the user is behind a proxy and the
page they are requesting returns a 407 error (proxy authentication required).
Chrome did not handle this situation, causing the app to crash. Exploitation of
this could ultimately cause a denial of service on the chrome app.
","This could be a coding or design error, there was obviously no
system designed for handling this case. However, when coding this, the developer
did not see the possibility of failure and all it took to fix this was an if condition
to test whether the connection behind a proxy succeeded. The fix does adhere to the
CWE mitigations and the fix does appears to be correct. However, in more recent
versions of the file, the original fix is not present. Handling this scenario
is still present, just in a differnt form, this makes it seem that the original fix
was not as rock-solid as it should have been.
"
986,CVE-2014-3190,chromium,"A use-after-free vulnerability present in the currentTarget function on Event objects with the core/events subsystem in Google Chrome allowed remote attackers to cause Chrome to crash or have unspecificed other impacts via Javascript code that would access the source of this vulnerability. An attacker would be able to construct vectors and infect Chrome user's browsers remotely via download of a simple javascript program from a visited website. The result would be a Denial of Service attack, preventing the user from accessing any functionality in Chrome.","The coding mistake that was made was essentially returning a raw pointer to memory, rather than a reference.
Using the raw pointer to access the corresponding object after that memory had been freed resulted in a
memory violation and application crash. This mistake could have been avoided by having a stronger sense of awareness
for the existing functionality of the subsystem being worked in. Simply knowing that the value being returned was a raw
pointer to memory could have inspired a more defensive programming approach.

There seemed to be a bit of an issue in terms of team communication. The original author of the code that
contained the vulnerability was still on the team at the time of the commit, but seemed reluctant to admit
that the vulnerability that was reported could be a cause of their code. A different team member took
over the bug fix after a supervisor had asserted that someone needed to claim responsibility for the bug fix.
The supervisor seemed irritated that a major security vulnerability took over a month to fix after being
first reported.
"
987,CVE-2014-3191,chromium,"An object called RenderLayerScrollableArea called into method updateWidgetPositions, which
performed various layout and style updates to render.
During this process, an object called RenderLayer was destroyed; this object was the parent of the RenderLayerScrollableArea
and another object (ScrollAnimator).  After the layout and style updates finished, the code
attempted to have the now destroyed RenderLayerScrollableArea object call a method 
(updateCompositionLayersAfterScroll), causing a memory error since the render tree had been destroyed.  Exploitation of this
vulnerability may have resulted in DoS due to program failure.
","Based on the discussions between the developers in the bug reports, it sounds like this
vulnerability was not considered initially because it occurred so far down the call stack.  The
failure to consider what might happen if the render tree is able to destroy itself from the inside
out was probably a design failure; consideration of misuse/abuse cases may have helped catch this
vulnerability earlier.

The initial fix for this vulnerability (in the first bug 322891) was insufficient, as the developers
simply added an assert to attempt to catch the use-after-free.  In the notes on that bug, it seems
the developers intended to improve this solution in the future, but did not get to it until this
vulnerability occurred a year later.  The new fix moved the call causing the destruction of the object
in the use-after-free, which was more appropriate.
"
391,CVE-2011-2843,chromium,"Chrome wasn't handling media buffers correctly. The media buffer was reading out of bound values. 
Attackers were able to cause denial of service through vectors. The avcodec_open
method read past the allocated memory. This was fixed by over allocating the source buffers. This fix
would cater for the chunked nature of the get_bits() function. Developers acknowledge
this as an ugly solution but was necessary for the function.
","A design and coding mistake resulted in this problem. If they accounted for the size of FFPmeg videos 
then they could have predicted the possibility of a buffer overflow. In order to prevent
this vulnerability they could've done a detailed review of the FFPMeg data. Such review
would forsee a possible buffer overflow.
"
1295,CVE-2016-1709,chromium,Attackers could cause a Heap-based buffer overflow in sfntly. sfntly is a program that lets users create and edit custom text fonts. The buffer overflow could be used for denial of service attacks.,"A very basic coding mistake caused this vulnerability.

The 'Get' function did not check if the index was within the array bounds.

Other functions check if the index was in array bounds
but the developers forgot to add the check to the 'Get' function

This caused the Buffer Overflow errors in the sfntly subsystem.

This vulnerability has been in the sfntly subsystem since its first release, but
it looks like the developers had bigger bugs to fix and new features to add
"
1349,CVE-2016-5174,chromium,"On a browser window, toggle requests go unprocessed which allows attackers (remote sites) to create unsuppressed popups causing a DOS (Denial of Service) by spamming the browser and causing it to crash. Fullscreen mode would also get stuck and you are unable to leave it.","The origin of this vulnerability is the lack of input validation from the remote target site. In certain conditions, the remote site was able to push popups on to the user's browser, and have them open without asking for user's consent. This, lack of input was due to improper handling of a particular use case in that Flash objects were not filtered for popups and therefore they opened forcibly. By doing this, the user is let vulernable to DOS attack (by spamming the host browser) and redirects to malicious sites. This is likely due to missing security requirements of ""Flash"" popup handling or the following of yagni principle. The fix, follows the mitigations by CWE. However, I noticed that the fix is only partial. It has resolved the issue of the fullscreen being stuck but popups remain unhandled, which leads me to believe that proper mitigations were not followed and the fix is not proper.
"
1220,CVE-2016-1634,chromium,"A JavaScript script creates an input element inside a form element and adds them to the DOM (web page),
then forces a style recalculation and removes the input from the form element. Due to the
synchronous order of execution that should have been asynchronous, it would cause a use-after-free
error. This occurs becausehere a memory address that has been freed is attempted to be accessed, because the style
recalculation and element removal are executed in the wrong order.

This vulernability exists in the third party WebKit source.
","There seems to be a design/code mistake in the processing of the DOM operations.
Ooperations that should be handled in the correct asynchronous order were handled
synchronously which allowed for operations to occur in an invalid order that caused the
use-after-free error. The mitigations offered on the use-after-free CWE suggest using a
language that offers automatic memory management. For WebKit, performance is key so the use
of C++ makes sense, whereas using a language that manages memory automatically would
hinder performance too much. Therefore, it's not a valid mitigation or one that the WebKit team
practices. The second mitigation suggests setting pointers to NULL after freeing them.
Based on the results of the vulnerability's exploit case, it seems that this was not being
practiced in the code. I was not able to find a concrete example in the code
due to its complexity.
"
1307,CVE-2016-5130,chromium,"A third party dependency doesn't properly handle the forward behavior in their
browser (""->""). This vulnerability gave attackers the ability to hijack the
button, and send users to a link they didn't retreat from using the back
arrow (""<-"").

This was an interesting problem because in a way, the spoofing vulnerability
leads to a denial of service, because whatever chrome is supposed to forward
to, it is not. The website it is supposed to navigate to is not reachable
through that method, or you can forward to a page that you didn't previously
visit.
","The mistake was simply that they used a third party dependancy that had a
bug that could lead to spoofing from falsifying the forward button. The
mistake occured because the developers didn't have an understanding thorough
enough to know the consequences of using the Blink package. I would consider
it to be a design/coding mistake.

The mitigation provided was for the design/architecture section; the
mitigation is to carefully address permissions for users of the system. It
seems that the approach of chromium's solution is to more carefully manage
the behavior of the forward arrow itself, by resetting it, and clearing
children when appropriate.
"
1257,CVE-2016-1671,chromium,"Google Chrome on Android mishandles / (slash) and \ (backslash) characters,
which allows attackers to conduct directory traversal attacks via using a file
containing URLs.
","To begin with, it was a coding mistake where the developer did not check for
specific escape characters (i.e. slash and backslash). The fix was pretty
straightforward in the escape.cc file.

The vulenrability was introduced when some new logical checks were being
implemented. The developer mishandled / (slash) and \ (backslash) characters.
"
190,CVE-2010-4574,chromium,"The pickle function in google chrome and chrome OS perormed pointer arithmetic
improperly on maliciously crafted pickle data.  This allowed an attacker to 
modify some system files without control of what they were modifying or execute 
a denial of service attack.
","Coding mistakes.  The issue that caused this is easily overlooked in the
difference between 32 and 64 bit systems.  there was a hardcoded offset 
for pointers that worked in 32 bit systems however tis offsetwas larger
in 64 bit systems.
"
406,CVE-2011-2858,chromium,"The vulnerability was in a function called HandleDrawArrays inside the gpu 
subsystem, which handles rendering. The function HandleDrawArrays was not handling 
properly triangular arrays. Triangular array is where the length of each row is one 
more than the last. The problem was caused by not properly handling conversion between
types that can only hold positive integers (unsigned) to types where the integers can be 
both positive or negative (signed). This caused the function to access values in the arrays 
that was not there, which is an out-of-bounds read on the array. This caused an error that
prevented services from running.
","The vulnerability was caused by an improper conversion from unsigned to signed. This 
resulted in an out-of-bounds read on the array that was given, which gave an error and 
led to the code crashing. 

First, I noticed the class the vulnerability was in is massive. They started migrating classes that were inside the 
class to outside classes. Additionally, I also noticed that one person worked a lot on features that was related to 
this class and ultimately caused the vulnerability. There was unit tests, but it did not catch this vulnerability. 
Therefore, having better tests might have caught this bug. 

They mitigated the vulnerability by updating some functions and casting the values inputted to ints.
"
1131,CVE-2015-1299,chromium,"There was an issue with timers being removed and the reference to the timer being used.
Timers were set up so that they lived in a heap. The problem with this is there
was logic that ended up freeing/removing a timer, due to a bad conditional. This conditional
attempted to compare an 80-bit integer with a 64-bit integer. This would cause
the program to update the heap and make a duplicate timer. Eventually, the timer would
be deleted but the 'duplicate' (which is a pointer to the original) would be used.

The fix was a complete overhaul of the timer file. Remove all references of a heap
to use a more reliable scheduler.
","The vulnerability was a complex issue that never really led to a defined solution. It
started with the fact they made the decision to create a heap and use that for a scheduler.
This is an issue because it was not needed and added a good amount of complexity which makes
security more difficult. In addition, it was in a relatively unpopular area with only a few people
being familiar with the section. This allowed for the bug to exist for quite sometime after it was first found.
The next issue was the fact there were no unit tests until AFTER the solution was found. This allowed
for plenty of findable mistakes to pass through (as many as three). Lastly the way they came about a solution
was very problematic. It looked like from the git history they did not properly test their solution in the
system. as a whole. so it led to four reverts. This could stem from the fact that instead of investigating
for the specific solution, they just wiped the entire subsystem.
"
47,CVE-2010-0644,chromium,"In Google Chrome when a SOCKS 5 proxy server is configured, DNS queries should
be forwarded through a SOCKS 5 proxy. In this specific version, DNS queries
were performed from the local network instead. This could allow for remote DNS
servers to obtain sensitive information about the identity of the client user
via requets logging.
","When a user sets up a proxy like SOCKS 5, they expect to send all their data through
that secure line. Google Chrome didn't configure itself correctly to use it by default
resulting in users believing they set it up, but in reality they were still sending their
ip to the DNS servers.
"
1217,CVE-2016-1631,chromium,"The vulnerability was in Google's Flash Player module, *Pepper*, in the way the
Flash Message Modal (basically windowless pop-ups) handled nested modals.

The implementation did not suspend script callbacks or resource loads inside
the nested modal box. As a result, cross-origin documents could be loaded from
an arbitrary Javascript execution point. This vulnerability bypasses the Same
Origin Policy and could be used to cause denial of service, loss of sensitive 
information, and execution of arbitrary code.
","The vulnerability was essentially a design mistake that gave nested modals
the privledge to bypass the Same Origin Policy. It is interesting that the
two methods used to mitigate this vulnerability were in the repository for 
six years before it was discovered. 

It's possible that there was a similar vulnerability that was found in the 
past. It's also possible that similar functionality was implemented in a different
system by a developer who may have had more knowledge or awareness of security.

It appears that trust boundaries were drawn, but not around all of the components
that may cross it. Proper analysis of the architecture is really the only mitigation
against this kind of vulnerability. Since this vulnerability was found by someone
outside the Chromium team, it is unclear if this has been done.

The lesson to be learned here is that discovery of a vulnerability such as this warrents
an audit of existing subsystems that may also be susceptible the same vulnerability. This could 
be done with a fuzzer or by manual inspection of the code and design.
"
1020,CVE-2014-7932,chromium,"This vulnerability refers to an attacker that attempts to access memory after it has been freed. 
This could cause the program to crash or could allow for full remote code execution capabilities. In
the case of this vulnerability consequences such as denial of service or pending updates of detached 
elements could happen. This vulnerability is found in the Element::detach function in core/dom/Element.cpp 
in the DOM implementation in Blink which is found in Google Chrome versions before Google Chrome version 40.0.2214.91.
","The main mistake that lead to the vulnerability was trying to update an
element that was trying to detach and free its memory.
I believe it was mainly a design mistake in the code itself. This is because
an element is scheduled for an update while being detached. The code just needed to 
be moved for the element to update after the element was detached. The fix was simple it
just wasn't dealt with for quite a bit of time after it was discovered.
"
55,CVE-2010-0656,chromium,"Webkit, if given a false directory in the URL section, will show a page that displays 
directories on the server in response to the XMLHttpRequest for a file that's actually a directory. 
Based upon the XHR requests to chrome browser. This allows the attacker to scope out the server's
file system leading to other exploits.
","The origin of the bug is not really a commit or code error but a structural issue. Other browsers
such as Safari got away with not allowing local directory access by denying any file directory access 
from URLs. ""The patch for this was added to WebKit (webkitgtk 1.2.0 contains this change), but the 
problem depends on browser's ability to generate local directory listings."" (Tomas Hoger). This fix was
an implementaion of a mitigation rather than fully blocking a security risk. It was mitigated rather than 
blocked so that the availability or usability was not removed in the directory listing sense.
"
1022,CVE-2014-7934,chromium,"A user was able to crash Chrome by executing a complex series of JavaScript 
commands. This crash was caused by a used-after-free issue. By accessing memory 
no longer available, the program crashed and generated a sensitive crash dump.  
","This vulnerability was simply a rare abuse case that broke an assertion in the style 
rendering of WebKit. This vulnerability appears to have been present as far back as 
when Google forked the WebKit repository from Apple. When blamed, the original code's 
last author was an Apple engineer, at least 5 years before this bug was identified.

There was not much in terms of design or coding mistakes that were made. This vulnerability 
was an extreme edge case, however, the Google engineers appeared to have some issues finding 
the correct patch for this. Some commits were made, but were then later reverted because 
they either did not fully solve the problem, or they broke more features.
"
1105,CVE-2015-1272,chromium,"Heap use after memory freed in Chrome content renderer and GPU. The vulnerability
allows remote attackers to deny service to the victim and can possibly allow
unintended code execution.
","The vulnerability here was an oversight in terms of properly freeing up 
memory. The fix was to modify the way a GPU channel was being destroyed by 
verifying it is always on the main thread and to properly handle channel's 
NULL state.
"
875,CVE-2013-6622,chromium,"The vulnerability was a ""use-after-free"" bug in the fork of WebKit used by
Chrome. The engine provides the ability to move elements between documents,
and frees the memory used by the element in the first document before moving
the element to the second document. It was found that, with a certain timing,
the freed memory used by the element in the first document could be loaded
after it was destroyed, creating a potential denial of service.

To fix this vulnerability, tweaks were made to how Chrome tracks the load
delay. Rather than checking if the old document is present when the original
load delay occurs, the method was changed to make checks between the old
document and the current document mutually exclusive. In addition, if the old
document is present, the load delay of the document is increased to ensure
that the memory cannot be loaded back into the old document. The load delay in
the old document is decremented now that the element in the old document is
guaranteed to be destroyed.
","The vulnerability appears to be the result of an oversight on the part of
both the VCC's contributor and the reviewer. Because the commit touched so
many files when unifying the two methods, its complexity made it hard to
track smaller errors. If the commit were instead split up between separate
files, this vulnerability might not have fallen through the cracks.

That is not to say they would have found the vulnerability. The
use-after-free vulnerability occurs because a load event can be sent to the
old document after the element is destroyed; that would be difficult to find
from the code alone. The developer would have benefited from documenting the
process using comments, like the person who fixed the vulnerability would
eventually do. If they had documented the sequence of events, it is probable
the vulnerability would never have made it to the initial review.
"
1354,CVE-2016-7395,chromium,"Part of Google's 2D graphic library, Skia, does not properly validate return
values of a method call. This allows attackers to craft graphics data and 
cause a denial of service or have other impacts. 
","The main mistake the developer made in the VCC was forgetting to validate
input. They were most likely thinking of the expected use case and what is
likely to happen within the system, which is a mistake that many developers
make.
In the comments on the bug, one of the developers suggested an
alternate fix that would deal with the uninitialized variable (the problem
that the fuzzer was testing for) but would not have validated the return value
(which is where the actual bug was). Another developer pointed out that since
they could figure out what the actual bug was, it was worth fixing the larger
bug. 
"
1045,CVE-2015-1211,chromium,"Privilege escalation using File System API to store worker script.
This should be only allowed for HTTPS or HTTP request.
","Not specifying the element to trigger the Service Workers caused this
privilege exploit. Service Worker should not allow any other API to interact
other than HTTPS or HTTP. This violation the least privilege principle.
"
1408,CVE-2017-5038,chromium,"Some view based and other related javascript objects were able to inherit from
a global prototype. Such related objects include view implementations and
containers. With these objects able to inherit prototypes from global javascript,
this could allow for arbitrary user code to be attached to these vulnerable objects.
If code is attached, it could be executed causing many problems.
","This was a design mistake. The system was not compartmentalized to safe areas
where the Guestview would be trusted with everything available to access. The
Guestview was allowed to cross these boundaries and potentially bring malicous
code with it.
"
1320,CVE-2016-5143,chromium,"There is a potential access control vulnerability in the DevTools subsystem
of Google Chrome. The subsystem allows for a hostname and other parameters
to be passed in by the user. The system does not sanitize the parameters
properly, which creates an opening for an attacker to supply their own
hostname and parameters by passing in a specially crafted URL.
","The main coding mistake here was the attempted fix of the original path traversal
vulnerability. Sanitizing input by removing all ""../"" was a good first step, but
when input becomes more complicated, the fix falls apart.

I believe this vulnerability could have been avoided using unit tests. There are no unit
tests specifically for the Runtime file, which is a concern. Sending in a complex input
in a unit test would have shown the developer that their sanitization algorithm
may not be as robust as intended.
"
281,CVE-2011-1413,chromium,"(Linux Only) A malicious user could remotely construct a relatively long string.
Upon creating the string, the user could then use it with the javascript alert 
function, or use it with an input that could be displayed in an alert. As a result, 
the display server could crash and lock up the open chrome windows on the target device, 
requiring a reboot (Denial of Service).
","The coding mistake that was made was essentially an unmanaged javascript alert
that was allowing remote users to create large inputs to be displayed in the alert, 
causing both the browser and x-server itself to crash unexpectedly.

When the vulnerability was introduced, it looks as if the boundary case of a long input
being used in alerts was not being covered, allowing this vulnerability to expose itself.

The chromium team is in adherance to the mitigations documented on the CWE page for 
this vulnerability fix. The inputs being used in javascript alerts is now being checked
for length, thus working around the previous crashes.

For this part of the UI, dealing with alert window width and sanitizing/validating
inputs being used in the alerts is necessary in order to keep the linux x-server working
as intended
"
1208,CVE-2016-1622,chromium,"Remote attackers could bypass the Same-Origin Policy via a maliciously
crafted extension since the Extensions subsystem in Google Chrome didn't
prevent use of a method to override intended extension behavior.
The Same-Origin policy states that web browser scripts can access data in a
second web page, but only if they have the same origin. Bypassing the
Same-Origin policy means that data confidentiality or integrity could be lost.
","The CWE ID for this vulnerability is 346, and is titled Origin Validation
Error. This vulnerability was caused due to not enforcing the Same-Origin
policy. In order to prevent these types of vulnerabilities, a potential
mitigation would be to separate privileges. Following the principle of
least privilege during the design/coding process would've fixed this issue.
In order to ensure this issue doesn't occur again, make sure that the
source is checked, and that malicious websites cannot be loaded. Preventing
Origin Validation Errors by testing the origin will lead to a safer system,
and prevent attackers from gaining access to undesired functionality.
"
1011,CVE-2014-7923,chromium,"For the Regular Expressions package used within Chromium (International Components for Unicode),
opcodes are represented by a 32-bit Integer. The first 8 bits represent the type of opcode.
The remaining 24 bits represent optional parameters. 

One parameter of the URX_LBN_CONT opcode requires the max length of a lookbehind regex match.
When this pattern is eventually assigned to a variable, it's range was not checked. Therefore,
if it's value was large enough, it could overflow the parameter bits and change the opcode
type.

This would potentially allow an attacker to execute machine code.
","This vulnerability seems to be an issue of maintainability. The configuration file 
was not updated as needed and other issues were able to be exploited from the ICU regexp engine used.
"
773,CVE-2013-0907,chromium,"This vulnerability involves a race condition that occurs before Google Chrome versions 25.0.1364.152.
The vulnerability allows for attackers to remotely cause a denial of service to the system and other
possible threats relating to threads/asynchronous threading. The race condition involves the
VideoRendererBase object being ""destroyed"" in the main thread function. The interleaving of VideoRendererBase::Stop() with
outstanding asynchronous calls to a VideoDecoder would result in continuing to execute code (i.e.,
starting up a thread without intending to) on a stopped VideoRendererBase. The most common manifestation of
the bug was crashing in ThreadMain() because the VideoRendererBase was being destroyed.

A type of attack could happen because of the race condition allows for a temporary
access of shared resources where the shared resource can be modified by another code sequence
that is operating concurrently. This could allow an attacker to simiply modify the resource and/or
modify things on the page and create pop ups for the user to click and share private information,
or cause a denial of services and could crash a chrome tab that involves a video on the page.
","The main mistake made that led to this vulnerability was not using proper
threading practices and it caused some threads to run over each other. There wasn't
much unit testing for threading and it was later detected by the crash.
In the future it would be recommended for maintainability
factors to include more unit testing on such topics like threading that are very precise and can
happne very easily. Overall seems like a oversight with threading was their main issue.
"
1012,CVE-2014-7924,chromium,"The vulnerability occured when more than one cursor tries to access the same
BLOB (Binary Large Object) in the IndexedDB, resulting in a
heap-use-after-free error. This error occurs when a program attempts to access
data from a location in memory that has already been freed.

This could lead to multiple harmful exploits, include the execution of
arbitrary code or corruption of stored data.
","The biggest coding mistake that was made with this vulnerability was that
the code never checked for duplicate pointers, or whether locations on the
heap or in the IndexedDB were freed of their allocated memory or not.

The fix that was implemented works by limiting heap access to only one
thread rather than two and synchronizing the mapping once memory was freed
on the heap.
"
221,CVE-2011-0784,chromium,This issue spawns from an audio render issue where a logic check was not being performed where an audio item was not being verified to already exist inside of a value it was being added to. This issues specifically when playing the game Z-type and crashed at one in four sound effects due to a timing issues with multiple sounds playing at once.,"The biggest issue with the program was coding issues. Obviously when a project is implemented over multiple years, issues can appear, but the main concern here was a failure to check input and confirm it was as expected. In addition, it took a while to actually discover what was causing the issues as it was very hard to reproduce. The fix they implemented is small, but seems to prevent this issues from occuring, as the Reddit thread and the Chromium thread have not been modified in some time."
1112,CVE-2015-1279,chromium,"An integer overflow vulnerability was found in the PDF Reader process that allows
attackers to use large height and stride values that caused memory corruption issues (memory modification). Attempting to expand an image
to a certain size resulted in a integer overflow.
","The mistakes seemed to stem largely from coding mistakes. It isn't clear but there
was a lot of bugs fixed inside of one large commit which is possibly because they rebased
it into that commit. There were multiple fixes and even reverts of the intial fix which points
to the fact that the code maybe was not tested to the degree that it could have been. The input
for the image maniplation affected both 64 bit and 32 bit platforms which was especially
dangerous because it allowed for the modification of memory and the overflow vulnerabilities.
"
574,CVE-2011-3960,chromium,"Google Chrome doesn't decode audio data properly, allowing remote hackers to cause a denial-of-service using unspecified attack paths.","The mistake is the fault of a lack of testing.  As the issue comes with the version of ffmpeg they were using, they should've checked if there any such issues with this particular version of ffmpeg when incorporating it with chromium through the use of thorough testing."
1114,CVE-2015-1281,chromium,"Some Chromium extensions such as Adblock Pro executed JavaScript that would break CSP (Content Security Policy) checks. Attackers are then able to load any image that they would like, and possibly use the image's request to access the user's sensitive data.","This is a classic case of a bug fix causing another bug, and therefore the best way to avoid situations like this is to make sure everything is properly and regularaly tested. Even though there were test in general relating to this code, there were not tests that specifically honed in on the cause of this issue, which allowed it to become a problem. Engineers may have felt rushed to fix the original bug which could have caused them to not fully consider the implications of their fix."
997,CVE-2014-3201,chromium,"core/rendering/compositing/RenderLayerCompositor.cpp in Blink,
as used in Google Chrome before 38.0.2125.102 on Android,
does not properly handle a certain IFRAME overflow condition,
which allows remote attackers to spoof content via a crafted web site that interferes with the scrollbar.

This CVE allowed applications in an iframe to modify the scrollbar via css,
allowing the iframe to spoof content on the website outside of it's actual frame.
","This vulnerability came about not because of any direct mistakes per say,
rather the fact that the iframe was able to modify the scrollbar, and use
that to spoof content. While this was fixed by bounding the frames overflow,
it likely could have been fixed somewhere else.
"
830,CVE-2013-2875,chromium,"A method in the code is changed to clear all following text boxes whenever
it is called, and this happens whenever any underlying strings change.
Before the fix, the method only cleared a specific text box and did not
account for any following text boxes that may have references to the 
initial one. The attackers could use uncleared text boxes to cause
denial-of-service attacks by attempting to read text (or other data)
from the first text box which no longer exists, resulting in a 
program crash.
","This was a design mistake (or implementation error) that would have most 
likely been found and resolved with running proper unit tests at the time 
when the project was started. The memory problem is related to the language 
used to a point, as it would not have occured in other languages like Java 
and Python that have better memory allocation built in. The CWE entry does 
not list mitigations for this error, but ensuring that it's not possible to 
write beyond memory in any part of the program is a solid start.
"
1061,CVE-2015-1227,chromium,"The function for dragging an image reuslts in an improper initialization that
could result in unallocated memory that is then accessed. This is turn causes
a failed image decoding that remote attackers can trigger. While the
impact of that is unspecified the default orientation for the image cannot be
used.
","This vulnerability came from a design flaw. In this situation, the allocation of memory depended on image orientation. The if clause did seem to account for if the allocation failed. However, the state of the object allocating memory resulted in improper initialization. They should have made sure that the specific function didn't depend on that case."
1297,CVE-2016-1711,chromium,"Google's fork of WebKit, Blink, implements a loading mechanism for web frames
that doesn't properly prevent navigating through a frame while detaching an
object that helps load content and other documents into the frame.

What specifically happens is this: starting a document load in the middle of
detaching a loader object will cause a new loader object to be cleared
prematurely. If an attacker is both clever and quick enough, they can set up
their own loader object and use it to load a malicious webpage, completely
bypassing Chrome's ""same-origin policy"", which normally prevents webpages from
accessing data from webpages that don't originate from the same place.
","The main mistake made in this vulnerability was more or less a resource
management issue combined with a mistake in logic. First, detaching a
document loader was not handled correctly, leading to some functionality
remaining in the system without the normal protections against exploits.
Second, some of the necessary operations for detaching the document loader
either weren't occurring at all or weren't occurring where they needed to.
All of this combined to make for a serious problem in the code base. It was
also clearly a complex issue to resolve, as it took two separate bug reports
(and consequently two CVE entries) before the vulnerability was properly
fixed.
"
384,CVE-2011-2836,chromium,"Malicious websites would use the windows media player plugin to run malicious code.
This is because you would not be required to manually allow it to run via an infobar (popdown bar)
","They knew that the windows media player plugin was a backdoor for a while, and didn't solve it.
The bug was open for over a month before someone took ownership and started to fix it.
It seems that no one took ownership of the bug because the people who new more about what a fix should be were very busy on other projects.
"
429,CVE-2011-3024,chromium,"Some versions of Google Chrome causes there to be an empty client certificiate
due to an unvalidated null value. This certificate is used by the Chrome 
browser to make authenticated requests to the server. Attackers can take 
advantage of the empty certificiate to bypass the hostname check for a 
certificiate and cause a denial of service or other issues. 
","The mistake that was made was not inserting null checks throught the process. If one variable is passed in as null, it causes another variable to be null, which causes an empty certificate. A recommended Implementation mitigation from CWE is to consider all potentially relevant input possibilities, including empty input. The fix used this mitigation."
802,CVE-2013-2844,chromium,"Use after free vulnerability occurs when the CSS renderer attempts to use
the same pointer after freed causes chrome to crash. An attacker can use
style resolution as vulnerability access to cause an unspecific impact.
This is done by placing a CSS file on the server and wait for a client to
fall in the bait. As a consequence, memory might be accessed by something
that is not supposed to happen or data on Chrome might be lost. Another cause
to the vulnerability could be a denial of service to make Chrome unavailable.
","I believe it was the coding mistake because the person did not think of checking the pointer to ensure it is not freed before using it. So, it is essential to think about all cases what the pointer will do during the process even if it becomes complex. When the code becomes complex, try to apply some practices such as check if the pointer is valid or not rather than figure out all cases for the pointer."
1089,CVE-2015-1256,chromium,"A remote attacker can craft an SVG file that exploits chromium's shadow tree (a way of hiding the creation of complicated web elements).
The shadow tree will begin the rendering of SMIL animations, during which the SVG adds more SMIL animations to be rendered.
SMIL animations should not be added during rendering, as it causes an infinite rendering loop that crashes your browser.
This is, at the very least, a denial-of-service attack and has even worse potential.
","In my opinion, this vulnerability came to be because the developers that were implementing 'SVGUseElement.cpp' (the file with the vulnerability) thought they had finished writing the file.
They wrote all the functions necessary for this file, but simply forgot to call a particular function ('isDisallowedElement(target)') in every place it was needed.
They called it in 6 out of the 7 places necessary, so this vulnerability was fixed very quickly by adding an ' || isDisallowedElement(target)' to an if statement.

There are 2 mitigations for this CWE.
The first is choosing a language that provides automatic memory management, which is not a choice as this is written in C++.
The second is setting pointers to NULL once they're freed. However, this would also not apply as the malicious SVG file exhausts chromium's allowed RAM to crash it.

The fix they made is proper, which is just blacklisting which elements can be rendered (preventing special elements that reproduce themselves from being rendered)
"
795,CVE-2013-2837,chromium,"The scalable vector graphics (SVG) library that is used failed to properly
handle the deletion of ""RareData"", which would sometimes accidentally delete 
more SVG data than intended since it was modifying the data it was iterating 
over. This would cause the program to hang.
","The vulnerability was due to improperly deleting data. The fix made sure 
that the data deletion was handled correctly. The fix isn't the most efficient
change, but it is effective in guaranteeing that the program doesn't 
crash or hang."
992,CVE-2014-3196,chromium,"Shared memory resources in Windows have a property known as a Discretionary
Access Control List, or DACL, which keeps track of who or what is authorized
to access them, how they can be accessed, and so on. Typically, these
resources are also given a name when instantiated. If this is not the case,
then Windows automatically assigns the resource a null DACL, which means there
are no authorization controls attributed to this resource, and thus there are
no limits to how they can be accessed, or who can access them.

Windows implementations of Google Chrome occasionally use unnamed shared
memory resources, meaning they are susceptible to this problem. Specifically,
the shared memory resource is not properly restricted to ""read-only"", meaning
a clever enough attacker can bypass protection mechanisms in Windows and
Chrome's ""sandbox"" (a mechanism used to isolate potentially dangerous
programs) or otherwise adversely modify resources in Chrome, leading to a slew
of unintended problems.
","The main mistake made was related to an implicit security requirement
imposed by how Windows handles objects in memory. Because some of the shared
memory resources were anonymous, Windows would not make them securable, and
thus they were vulnerable to an elevation of privilege attack as described
in the CVE entry. To prevent this, these resources had to be named.

It is clear that the initial developers were either not aware of this
property in Windows, or didn't think it would pose an issue, as the problems
present in the code went largely unaddressed for several years.
"
234,CVE-2011-1113,chromium,"Chrome uses a byte stream deserializer called a pickler. The pickler has a function that reads
information about the header and byte stream size to read. The function was not checking the size of the header
before reading the payload infomation and this could lead to a buffer overflow scenario
if someone sent a header of the wrong size
","This was a very simple mistake that developers make all the time. The original developer assumed all input to
this class would be good and no validation/sanitation was required. In any instance where memory is directly being
affected, buffer sizes must always be checked and anything larger than the maximum buffer size must be
disallowed
"
407,CVE-2011-2859,chromium,"This vulnerability allowed extensions to be downloaded to the chrome
browser without the user's consent.  By using Man in the Middle attacks, attackers
could use http redirects to make a victim land on their page and automatically
install a browser extension.  This browser extension allowed the attacker to 
elevate their own permissions and the permissions of other extensions on the 
victim's system.  This resulted in unlimited priviledges.
","I would say that this would be a design/requirements mistake because the paths
that extensions could be downloaded from included too many possibilities.  The 
former controls they had in place were moved to the gallery urls instead.  It
allowed extensions to be installed from pretty much anywhere once the http 
redirect was successful.  "
1052,CVE-2015-1218,chromium,"Moving a script element to a new document with the same context
document removes the script completely. When moving the script to a document
with different context the script is in the context document, not the non-
context document. This allows attackers to cause a denial of service or event
have other unspecified impacts that move a SCRIPT element to different
documents to affect the integrity of the system.
","This vulnerability was the result of a maintainability mistake. The scripts
loaded properly on new context documents until the vcc was pushed. That also
means a coding mistake was made at the point. Unfortunately, the cloudfuzz
couldn't detect the issue for a while.
"
1292,CVE-2016-1706,chromium,"This vulnerability resulted from the improper implementation of PPAPI, which is
a plugin management API for Adobe Flash Player.  
Plugins have a broker process with two methods for handling messages.
BrokerProcessDispatcher handles BrowserOperations messages managing browser functions
such as locally stored Flash cookies and camera/mic permissions.
BrokerDispatcher handles only ConnectToPlugin messages which manage inter-process-communication 
data for the plugin.
ConnectToPlugin messages are treated as untrusted and are sanitized and validated, but BrowserOperations
messages are not.  BrowserOperations messages are intended for use by the browser's settings
UI, while ConnectToPlugin messages should be sent on behalf plugins.  The Flash renderer 
is able to send both types of messages on behalf of plugins, meaning a compromised renderer
can submit unsanitized data and access powerful BrowserOperations functions. The primary danger
is that several BrowserOperations message variants include an absolute file system path
as an argument with no validation, allowing access to local files by the renderer.  An exploit 
could have the capability to write or overwrite local files.  The reporting user described 
a potential exploit for OS-X where vulnerability is used to mount a remote file system on the
target computer.
","The relevant code appears to have been written by a single developer and had not
been modified in almost two years when the vulnerability was found.  The presence of
this vulnerability appears to be a simple ovesight among largely robust code, given 
it lasted so long without requiring modification.  While both the original code and
the fix do not appear to use unit testing, I believe the issue is sufficiently 
complex that it would not have been feasible to detect it through all but the most 
extensive unit testing.  A 'defense in depth' approach would have been useful in this
case, which would involve sanitizing and validating all received messages from the 
Flash renderer rather than just those expected to be vulnerable.
"
882,CVE-2013-6629,chromium,"An image segment reading function for JPEG files didn't check if the chunks of data comprising an image were being repeated, possibly allowing images to be stolen across domains and maybe even non-image memory.","The mistake was not ensuring data leakage wasn't possible when data was accessed- processing image data in chunks should ensure the same data isn't being processed twice, and that the remaining data isn't leaking. The mitigations enforce that the data is all processed and the tests appear sufficient."
926,CVE-2014-1714,chromium,"This was used as part of an exploit that potentially allowed for
code execution outside of a sandbox environment in Windows. A method that wrote
objects to the clipboard did not validate or sanitize the format of objects that
are passed to it and instead wrote them directly to the clipboard. This had the
potential to cause issues with Inter-Process Communication (IPC), as malformed
objects could be read by an IPC handler and may cause a denial of service.
","This vulnerability is a case of missing code, and not incorrect code. The
function of copying to the clipboard worked perfectly, but only during an
abuse case did it malfunction.

It takes a lot of domain knowledge on the functionality of this clipboard
write function and the ways that the clipboard data is used by the
application (or other applications) over IPC to realize the possibilities
of malformed data an the consequences of not sanitizing it.

This is potentially an issue that arose because of a lack of tests. If tests
were involved, there would be thought of possible failure cases of the method
instead of just the ideal case.
"
304,CVE-2011-1465,chromium,"Response bodies for a certain type of HTTP stream are not drained. The stream
is left idle, which causes the system to crash without a user-visible error message.

This vulnerability exists because the system did not close that type of HTTP stream
and it went unnoticed for a long period because the problem arose only rarely.
","The core reason for this vulnerability was improper design, a result of 
poor analysis. If the functionality being added was properly analyzed, 
the team working on it would have prevented the vulnerability in the first place.

The person who created the fix was not certain that it was proper, but there have
not been related problems since, so it was likely correct.
"
227,CVE-2011-1059,chromium,"A vulnerability that allows remote attackers the ability to cause a denial of service by enticing a user to resubmit a form.  If a user filled out a form, went back in their browser, and then forward again, it would result in a crash.","This was a simple case of trying to access memory that has been freed. It only took about 12 days to discover the bug, but it took about 10 days to reproduce it because it happens on a rare boundary condition. Every developer makes memory management mistakes like this once in a while.  Most vulnerability scanners can identify use-after-free vulnerabilties, so one of these tools should be used when committing new code."
1041,CVE-2014-9689,chromium,"Chrome for mobile exposes the device's accelerometer and gyroscope data to all websites
on iOS and Andriod. Due to the precise nature of these instruments, with extremely accurate
measurements it is theoretically possible for attackers to monitor keystrokes (through the
taps on the screen), track users (through movement), and even obtain low frequency speech
signals (through the vibrations in the phone). Current technology in mobile devices
do not allow for such precise measurements yet.
","The mistake they made was not realising the types of vulnerabilities created by giving anyone access
to a user's extremely percise gyroscope and accelerometer. When that level of precision is obtained
in everyday mobile devices, it should be a permission that the user can give.
"
803,CVE-2013-2845,chromium,"A heap-use-after-free vulnerability in the Web Audio implementation of Google 
Chrome, for playing audio through the Chrome web-browser, allows remote attackers 
to cause a denial of service or possibly have unspecified other impact. This kind of 
denial of service is caused by memory corruption. 

The fix for this vulnerability is to ensure that variables are not used once they
are free-d or released. Also pointers should be passed by reference. 
","The developers did not know that that the buffer was being used after it was freed. 
I did not see any checks in place to ensure that the buffer was being cleared properly. 
It looks like there was a design mistake with OwnPtr, and then a design decision to 
change OwnPtr to RefPtr, and recreate the corresponding functions required. 

Seems like the fix was not very simple. It took the creation of new RefPtr functions, 
replacing many OwnPtr with RefPtr in many files, and realizing that some functions
returned the AudioBus after it has been free-d.
"
342,CVE-2011-2361,chromium,"Dialog box for Basic Auth can be used to mislead a user into giving up their credentials. This is done by using a domain that intends to mislead the user into believing the authentication request is coming from a trusted source.
The fix is to specify both the domain and realm string, while also making sure that these strings are clearly labelled to the user.","The vulnerability here was an oversight of design. The devs did not
anticipate malicious domains being used to abusing their dialog box. After
realizing the possibility of such an attack, it was quickly rectified.
"
1125,CVE-2015-1293,chromium,"A vulnerability in a DOM implementation in web browser engine lead to remote attackers bypassing 
the Same Origin Policy through the use of forged security credentials.
","This vulnerability arose from an oversight by a developer. Their implementation was not 
secure by default which provided an easy means for potential attackers to exploit the system.
This vulnerability was unnoticed during code reviews, even though it was relatively 
obvious in hindsight. The developer who was responsible for creating the vulnerability, and
for implementing a resolution for it was focused on patching other vulnerabilities around the
time of the fix. However, the developer spent a large amount of time implementing efficiency
improvements before the fix was committed. This means that, had it not been found by an external
user, it would have likely made it deep into production.
"
525,CVE-2011-3880,chromium,"Google Chrome before 15.0.874.102 does not neutralize an invalid character (\0) in HTTP headers which can lead to many opportunities for XSS and CRSF by attackers. After receiving and interpreting a request message, a server responds with an HTTP response message. \0 character inside a headerline is being interpreted as a terminator. But \00 can also work An attacker can bypass web application filters like this -
$location = str_replace(""\r"","""",$location); $location = str_replace(""\n"","""",$location);
?location=/private-data.html%00Access-Control-Allow-Origin:%20attacker.com","This was a coding issue with how a chromium server properly whitelists user data inserted into headers. The current fix, ensures that chrome neutralizes the invalid character (\0) in HTTP headers.for XSS and CRSF by attackers"
119,CVE-2010-2898,chromium,"When Chrome looks up the MIME type for a long filename, the underlying library crashes.
This can be accessed through Javascript, meaning that in a malicious scripting situation (e.g. XSS),
an attacker would potentially be able to construct an exploit that corrupts memory. Memory corruption vulnerabilities can lead to arbitrary code execution and other bad things.

For this vulnerability, no such exploit was ever written, but the possibility was there.

The way that they fixed it was to (a) simply limit the filename lengths, and (b) work with the third party library to handle long filenames.
","The main mistake made with this vulnerability was in not testing the third-party library thoroughly.
They did not assume that filenames could be given abritrary lengths in Javascript, and therefore they ended up with a crash.
Simple unit testing with diabolical tests (e.g. super-long filenames) and distrusting inputs would have prevented this issue.
"
527,CVE-2011-3882,chromium,Use-after-free vulnerability allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to media buffers. These impacts may include overwriting data or pushing confidential data to the output.,"Based on the code this looks like a case of accidental buffer overflow that occurs under load testing. So while a denial of service was possible due to poor memory management, it would be hard to blame the programmer. The only real way to avoid this is cultivating safe memory allocating practices.
The fix properly mitigates this by locking resources via threading so that the freed memory can't be used before it is re-allocated by the program."
877,CVE-2013-6624,chromium,"Google Chrome was susceptible to a use after free vulnerability. This involves
accessing a pointer after it was freed. This can lead to a variety of things, from
a segmentation fault to the execution of arbitrary code. To leverage this vulnerability
an attacker would need to have an idea of where the use after free is taking place. Then,
the attacker may be able to hijack the ""freed"" pointer and use it to execute their own code.
In the case of this code an attacker may be able to alter the rendering of the DOM (Document Object Model) AKA the page, seeing as this
code refers to the id attribute of an HTML tag.
","The vulnerability was introduced early on in the code and seemed to be a long time
coming judging by the commit message ""Exposed a lifetime issue with strings for id attributes.
We simply need to use AtomicString."" It seems as though people were aware of the issue
but either could not figure out a good solution or didn't have the time. In additon the fixed seemed
to be very simple leading me to beleive that people just didn't have the time to fix it. If anything this was
a design mistake that could have been caught earlier.
"
139,CVE-2010-3250,chromium,"A vulnerability allows remote attackers access to a private list of functional plug-ins 
added to the application by the user.
","This looks like a classic example of software that had a minor vulnerability
most likely because the developers not wanting to put the time into fixing it.
Some evidence: The VCC was made the day before Christmas (near the end of the 
west-coast workday). The vulnerability was fixed by the first commit a contributor
made to the system. This is highly evident that it was some minor but annoying 
work given to a new hire. The fix required a new development to be made, as well
as minor other changes in different areas of the subsystem. The vulnerability
existed within the system for just under 2 years.
"
140,CVE-2010-3251,chromium,"The WebSockets implementation in Google Chrome allowed attackers to 
cause a NULL pointer dereference resulting in a crash. WebSocket is a protocol 
used for real time communication between client and server without the need for 
the client to continuously send requests. When the WebSocket connection was closed while 
the host was being resolved the null pointer dereference would occur.
","The function in question did not have a check for a null pointer and had 
been present in the source code since the file was first created (almost a year before).
It seems that there wasn't automated testing used for that specific error which, according to
the CWE page, does exist. Judging by the response when the issue was reported, it does not appear
to be a very severe issue which may justify the lack of automated unit tests. Additionally 
this problem could definitely have been addressed during design.
"
945,CVE-2014-1733,chromium,"The bug was in Chromium's Sandbox in the way they detected and merge two blocks of code via PointerCompare and
TailMerge.

When executing a compare and a merge, the code does not properly account for the ""next"" pointer (the
next lines of code to execute after the blocks have finished executing) if the two blocks are not JMP (jump) or RET
(return) instructions.

This creates an edge case where two blocks of code could be identical except that their 'next' pointer is
different, but the two blocks get merged anyways. This merge can introduce a cycle into the program and
can cause crashes during compilation. Worst case scenario, this can lead to illegal system calls via an attached
BPF program.
","The biggest mistake made in causing this vulnerability is that the developer in question did not think of all the
edge cases. As the developer did not think that they would need to compare the 'next' blocks of code to be
executed, it created this edge case where the code allowed an illegal merge because it did not look deeply enough.
I would argue that this is a coding mistake, although this could have been caught at multiple levels. Better
requirements, testing, or design would have potentially caught this issue, but it ultimately fell through to the
developer to ensure that the case was accounted for, which they failed to do.
"
1034,CVE-2014-7946,chromium,"Chromium's rendering engine, Blink, had a vulnerability where the rendering of
the table on a webpage would skip captions in certain situations. When a table
is rendered, it would render all the table sections if they are needed but the
rendering engine did not account for table captions being a part of the table
layout. Therefore, it would read past the defined size of an array. This
allowed remote attackers to cause a denial of service attack where they
could corrupt sensitive information, cause a crash, or code execution.
","The fix for this vulnerability appears to be a temporary workaround
that does not fully address the root problem of the vulnerability. Instead,
it is meant to resolve the crash rather than fully address the issue
with rendering the table properly. It appears that when the vulnerability
was introduced, the author did not account for table captions which needed
to be laid out when a table is rendered. This could have been found earlier
if there were unit tests that tested tables with captions.
"
748,CVE-2013-0881,chromium,"Google Chrome allowed remote attackers to cause a denial of service 
(incorrect read operation) via crafted data in the Matroska container format.
This is because of the manipulation with an unknown input when calling the function
matroska_parse_laces which in turn led to out-of-bounds reading in the memory.
More specifically, this caused a Heap buffer overflow.
Matroska Multimedia Container is a file format that is able to hold unlimited 
numbers of video, audio, picture, or subtitle tracks all in one file. 
","The mistake that led to this vulnerability was the developers not checking the outputs of all the file formats
that they were decoding. In the instance of this vulnerability, the developers allowed remote attackers to
cause a DOS due to carefully crafted data in a Matroska container format. The developer had not checked a function
that related to matroska, more specifically matroska_parse_laces(), that moved a pointer in the file forward but did
not subtract the size of the file which caused an out-of-bounds read.
This could have been easily prevented had the developers checked all use cases for the formats they support and made sure 
that the file's outputs were accounted for if they do support media formats such as matroska. Also the developers noted that
the vulnerability was old and dated back three months prior to this. The unit tests should have been more robust and the requirements
should have been more fleshed out so that all use cases were covered. 
"
1145,CVE-2015-3334,chromium,"The vulnerability was in the way website permissions were being displayed to
the user.

Microphone and Camera permissions were implemented in a way that they had to
be requested individually by a website, but were displayed as a single 
'MEDIA' permission in the Page Info dialogue. In cases where the two 
permissions did not have the same value, the UI instead showed the default
value, often something unhelpful like ""Ask by default"".

This meant that a user had no way of knowing which media devices, if any, a
website had access to.
","The code that introduced this vulnerability contained no mistakes, but 
rather, was based upon a mistake in the UI Design for the relevant feature.

From the discussion on the original bug report for this vulnerability, it
seems there was significant confusion about what information, exactly, the
user needed to be privy to, in regards to 'Media' permissions, and,
ultimately, a choice was made that allowed this ambiguity into the UI. 

This choice was reconsidered with the filing of the bug report, and was
found to have been mistaken.
"
1147,CVE-2015-3336,chromium,If the url consistted of 'file://' then the browser would not ask the user if they are going to allow or deny for fullscreen and mouse lock. This problem allowed remote attackers to cause denial of service since the user didn't not have the chance to not allow the page the access.,"The mistake was associated to them do a inverse check, by allowing the client be not notiified by default and an if statement managing when they should be notified. This is problematic and was not fixed still. They assumed with file:// that it would be user code which in turn means the user most likely knows what they want, however it is possible that another program loaded up the file and brough chrome to the directory which use this vulnerabliity."
953,CVE-2014-1744,chromium,"Integer overflow in the audio component occurs when a remote attacker sends an
overflow value to cause a denial of service or a large shared-memory allocation.
An attacker can send an audio file with an integer overflow value to cause a
segment fault then the attacker can add input at the end of the audio file
to modify memory. Alternatively, the attacker desire to crash the chrome, this
can be done by with the audio file alone. All these happen in the buffer value
in the audio component; this means the vulnerability is a buffer overflow.
",Whoever was tasked with the cyclic buffer change has since left chromium. They appeared to be either an intern or a new employee given the comments. They were tasked with a decently large change and there was much pushback to the approach that dominated the conversation in the code review instead of noting the lack of tests or looking for issues.
1224,CVE-2016-1638,chromium,"Remote attackers can bypass access restrictions by using platform Web APIs, i.e editing the underlying
html dom for the extension or editing load js scripts, via Google Chrome Apps.
","I think what mostly contributed to this vulnerability was coding mistakes. While the developers did try to fulfill the requirement of preventing restricted access via Chrome apps, there were still cases that they missed. I believe more misuse and/or abuse cases would have helped them in this situation, as they would have noticed that there was another way to bypass their restrictions."
339,CVE-2011-2358,chromium,"All extensions completed installation without first prompting the user with a ui to confirm 
installation completion. This could lead to the user downloading malicious extensions without 
realizing it if they clicked on a fake download link or something similar. Malicous 
changes to a user's system could occur because of this without the user's knowledge.
","I think this problem was brought about by a requirements issue. 
It seems no one thought of the impact of downloading extensions without prompt until a similar 
ssue happened  on Android that was very damaging. The fix was very straight forward and makes 
sense. Adding a prompt for free extensions ensures that the user at least understands that 
they are downloading something. Not showing the confirmation for paid extensions also makes 
sense as the user will have to put in their payment info, ensuring that they understand 
that they are buying and downloading something.
"
578,CVE-2011-3964,chromium,"The drag and drop feature within Google chrome was not properly 
implemented. To be specific, it is the action of dragging a url to the url bar.
This allowed spoofing of legitimate urls through javascript when a link was 
dragged into the address bar. 
","The mistakes that were made was that after stripping the javascript schema, having to 
not navigate to the link allowed for social engineering to take place and spoofing of 
websites to occur. It was more of a design mistake as the use case of dragging and dropping
a link to url address bar was not carried out fully to the end. You would expect the browser
to navigate to the link and not stop. 

Based on the CWE entry for this vulnerability, they are not exactly carrying out an architecture
and design mitigation of warning the user that they are leaving the page if there is javascript ran 
behind the scenes. But they are sanitizing the javascript and navigating to the url to prevent spoofing 
of the real website.
"
966,CVE-2014-3161,chromium,"
When playing video from <video> tag, chromium on android uses a native media player. But once the video url is sent to the media player, Chromium has no longer control, and that opens up attackers to bypass Same Orgin policies. 

Under the Same Origin Policy a web browser allows scripts in one webpage access data of another webpage, but only if both web pages have the same origin. But, if the policy is bypased, it allows outside sources access data of a particular website. 

For example, the attack would go something like this:
    1. User is logged in on myvideos.com, and visits evil.com, which had a <video> tag
    2. User plays a video on evil.com, evil.com handles the request from the browser and serves a response.
    3. Then, the browser sends the url of evil.com to the native video player to play the video. Now the browser has lost control of the interaction.
    4. After that, evil.com recieves the request redirects the video to myvideos.com, allowing it to play cross-origin videos from myvideos.com that it should not have access to under the Same Origin Policy.  
","I believe that this should be thought of as a design mistake. This is because
it is part of the design of the product to securely handle browser requests at 
every level, from the browser, to the actual native Android videoplayer. The 
current fix at this time fixed the issue by always treating media urls as cross-origin.
This is not proper because although the approach did resolve the issue, it still 
sacrificed functionality by not trusting any URL to be same origin. 
"
1166,CVE-2015-6766,chromium,"The AppCache destructer calls the function OnDestructionImminent() on 
appcache_update_job.cc to notify any pending cache update jobs. While 
this is happening, the new_master_entry_url_ of the host is expected to 
stay the same. But, this variable is susceptible to change with with a compromised 
renderer, causing the browser to crash. 
","The mistake that led to the vulnerability seemed to be mainly a design mistake, 
and also a testing mistake. This is because there should have been a test case
that made sure the browser checks whether the new_master_entry_url_ of the host 
was changing while the browser was finishing up cache update jobs before the cache 
was deleted.  
"
1167,CVE-2015-6767,chromium,"In the AppCache implemetation in Google Chrome before 47.0.2526.73, there is a vulnerability in 
content/browser/appcache/appcache_dispatcher_host.cc named use-after-free 
which means referencing memory after it has been freed can cause a program to crash, use 
unexpected values, or execute code. In this scenario, the memory in question is allocated to 
another pointer validly at some point after it has been freed. The original pointer to 
the freed memory is used again and points to somewhere within the new allocation. As
the data is changed, it corrupts the validly used memory; this induces undefined behavior in
the process. Therefore, this vulnerability allows remote attackers to cause a denial of service by 
leveraging incorrect pointer with certain callbacks.
","I think this is the coding mistakes that a developer may forget about a host 
can have a pending callback with a raw pointer to the dispatcher. If the 
dispatcher dies, it deletes all of its hosts, so that any pending callbacks are 
deleted. But there is an exception, hosts can be transferred from an old backend 
to a new one, which doesn't clear any pending callbacks. Such a case leads to a 
UaF in the browser process if the old backend is deleted before a callback fires. 
After examining the mitigations I think ths is proper fix for it
"
1172,CVE-2015-6772,chromium,"The previous implementation of DOM in the subsystem Blink (Chrome's rendering 
engine) did not protect URL navigation while a document was being detached, 
allowing attackers to attack internal plugins with JavaScript by attaching
a false document.
","In my opinion, there were no mistakes. The vcc itself was a fix, originally,
that fixed the same vulnerability; making sure that while detaching a document,
an attacker can't attach another document to that frame. The problem arose
from where the fix was installed; it was installed in NavigationScheduler.cpp,
and regression made that fix moot. The new fix was simply moving the old fix from
NavigationScheduler.cpp to LocalFrame.h.
"
1175,CVE-2015-6775,chromium,"A static method which doesn't use signatures could allow a remote 
attacker to cause denial of service or possibly access secure 
information by creating a ""fake"" object and passing it to this 
static method. 
","The Chromuim team's inital commit contained a bug. This snippit of code went
through multiple code reviews and tests yet still manages to exist in the 
system. The code was noted as confusing several times in the commits and yet 
nothing was not to simplify the code or separate it out into multiple files 
for easier readability. Complex code tends to hide vulnerabilities such as 
this one and needs to be carefully reviewed before sent to production.
"
450,CVE-2011-3049,chromium,"Web requests are made all the time by browsers looking to retrieve content,
post content, and the like. In this case the API in question allows developers
to view these requests to take analytics, block the requests, or modify them. This is
problematic in the case that a web extension goes rogue. This api allows rogue
extensions to block incoming requests. Specifically, it allows a rogue extension
to block a request calling for the blacklist of web extensions (which could include
itself).
","Overall in my opinion there was not enough code review that went into the VCC's merging.
While it is difficult to think of such cases, further analysis might have revealed
the possibility of blocking important connections through a rogue extension. Furthermore, there seemed to be alot
of misunderstanding dealing with how the updates to the blacklist were handled. Looking at the bug
comments, there was a good amount of debate about how the updating of the extensions was
initially planned to be a system call (meaning not using the profile) but ended up using the
web request. In retrospect, if they had followed through with the initial design choice, the
vulnerability would have been avoided.
"
743,CVE-2013-0841,chromium,"In the content-blocking funtionality of Google Chrome, there is a
vulnerability where an array index is not checked. Content blocking
is important to protect the user from unsafe scripts. 

This vulnerability could potentially allow remote attackers to cause a denial
of service (DoS). It could also cause the disclosure of information and
unauthorized modification of data. This array is responsible for logging the
type of content settings accessed.

The fix for this vulnerability is to prevent the array index from going lower
than zero or higher than the size of the array.
","This vulnerability was introduced during the implementation phase of development.
I believe this vulnerability was the result of a coding mistake, but it could be
the result of a design mistake as well. Due to the relatively simple nature of
this vulnerability I believe that it could have simply been a mistake done by the
programmer. Not properly checking array indexing is something can be easily
forgotten. If input validation was not part of the design, then this is a design
mistake as well. In order to prevent this vulnerability going forward, it must be 
remembered that array indexes should always be validated before use. The chromium
should also consider improving their unit testing plan. Array indexing is a
vulnerability that can usually be caught during unit testing.
"
575,CVE-2011-3961,chromium,"Race condition in Google Chrome allows remote attackers to execute arbitrary
code via vectors that triggers a crash of the utility process.

There seemed to be 4 clents that could have lead to the crash of the utility process;
IndexedDB, WebstoreInstallerHelper, the profile importer, and posix plugin loader.

Before the fix, it seemed the race condition was caused by the ""utility_process_host_""
variable becoming NULL and then not being appropiately dealt with. Though I am uncertain, 
it seems once this variable was NULL, calls on it that required it to be defined would 
not work, causing a bunch of calls to be thrown off. 

I am unsure how an attacker would cause the ""utility_process_host_"" to become NULL.
","The coding mistake that was made was not locking certain sections of code
that multiple threads talked to. That what allowed a race condition to
happen. The fix was to see check to see if a specific variable existed,
which I assumed was a thread. In this case though, it seems like if a thread
already existed, it would execute code. This either stops the previous
thread from continuing, or it is stoping the new thread from taking over the
original thread accessing the data.

Looking further, the specific thread that was crashing was the main utility
process for google chrome. It seems when certain variables were set to NULL, 
then the process does not know how to handle it, and it either treats the
condition as a crash protocol, or crashed because it could handle the certain
statements as being NULL.
"
1185,CVE-2015-6786,chromium,"The Content Security Policy (CSP) is used to prevent attacks such as
cross-site scripting (XSS). It defines approved origins of content that
can be loaded on the site. When a policy of 'script-src *' was used in Chromium,
it allowed content to be loaded that was explictly banned by the standard.
","The mistake made was not fully supporting the standard. Some of the standard was implemented but a special case for wildcard sources was left out. The team seemed to be actively working on adding support for the standard at the time of the report, so the fix may have come later on its own. The fix may be related to incomplete planning. When the bug was reported, the first comment was asking if someone else had already fixed it, assuming they were working on it. The other person responded that they never worked on it. This may indicate the work was not fully planned before implementation and they were informally assigning large parts of the standard to different people, leading to a missed detail in the implementation."
1187,CVE-2015-6788,chromium,"Some handler functions were improperly implemented. This allowed for attackers to cause a denial of service or utilize potential type confusion.
They could shut down the browser by using this type confustion through trying to access values that wern't expected.
The fix used a new method to grab data in a more safe and hidden fashion
","The major mistake made that lead to this vulnerability was a slight trust in
the input received either from the user or from another system. Sometimes
when designing an application we're under the assumption that some input can
be trusted. But if there is an issue down the chain, it can lead all the way to
what otherwise might have been trusted.
The code of the fix has not changed much at all since it was put in 2015 to today,
that would lead me to believe that the fix was indeed proper.
"
1247,CVE-2016-1661,chromium,"Blink, a web framework previously used in Chrome did not ensure
content in frames passed a check for the same render process along with a Same
Origin Policy check, meaning the objects' source were the same. The Same Origin
Policy is defined as a combination of the URL scheme, the host name, and port
number for the same origin. This allowed attackers to cause a denial of service attack
or other impacts using a fake website and frame content.
","The mistakes that led to this vulnerability were mainly design mistakes.
The authors of the code assumed frames that passed the SecurityOrigins
canAccess method had to be local frames. This does not hold true for
frames that occur as a result of renderer initiated navigation, since
each frame has the same origin but see the other frame as a remote frame.
This allowed content in frames to have external rendering processes which
did not have to pass the same level of security checks.
It appears the fix attempts to implement the third potential midigation of
checking the frame's ancestors to ensure it is a local frame.

The fix looks pretty good for a problem that not many people know about.
"
754,CVE-2013-0887,chromium,"The developer-tools process in Google Chrome before 25.0.1364.97 on Windows and Linux,
and before 25.0.1364.99 on Mac OS X, does not properly restrict privileges during
interaction with a connected server, which has unspecified impact and attack vectors.

This allowed the developer-tools process to access the web ui bindings, which
it did not neeed access to. This opened up numerous attack vectors, although
was easily resolved by simply removing the bindings to the web ui
","This bug was caused by the devtools process allowing access to the web UI bindings,
which was not necessary. It is likely it came about from planning ahead during devtools development,
with the assumption that the web UI bindings would be needed.
It is clear that the binding was in fact not needed, as the fix was quick and involved simply removing the binding.
"
1195,CVE-2015-8480,chromium,"The function that creates a video frame pool, the memory structure for video media frames, 
does not zero initalize the memory for a video-frame data structure. 
Large unitialized sections of memory can contain sensitive information and cannot be relied on. 
Out-of-bounds memory access also allows for a denial of service attack and or read/write access. 
","The issue here comes down to coding mistakes. They neglected to zero initialize the video frame. 
When the problem was being addressed there was a lot of ambiguity about interaction with a 
video library *ffmpeg* being used at the time. The team did not seem to have a clear answer 
on how the library would interact with their code for awhile. The originator assumed sending the memory 
without zero-initializing it would be safe - as they speculated that the library could handle it. 
"
326,CVE-2011-1817,chromium,"There are two vulnerabilities in Google Chrome before 12.0.742.91 in the way they implement history deletion.

The first vulnerability was because of the implementation not removing
old event observers properly, which leads to observers looking for the event 
that has already been deleted. Specifically, when a user try to clear browsing data,
an event and its observer will be created to handle deleting browser data. However, 
if the process is somehow discrupted (ex. user cancels clearing browsing data), 
the event will delete itself, while its observer does not. When the browser is reloaded, 
the stale observer will try to listen to a non-existing event, which then will make the 
browser crashes.

The second vulnerability was not stated to directly cause the bug, but was a bad
coding implementation. The removing browser data event calls some methods on a wrong thread,
which certainly could make the browser stall or crashed. 

The way that this could be exploited would be an attacker somehow disrupts the history deleting
process while it is ocurring. Then users will intuitively reload the page to restart the process,
and the browser will crash.
","It was a coding mistake where the developer deleted the event without thinking
about its living observers. 

Althought the fix was simple, finding this bug in the first place was not easy. 
Noone thought about the situation where the deleting user's browsing data process
is interupted. 
"
1216,CVE-2016-1630,chromium,"This refers to the ContainerNode::parserRemoveChild function in
WebKit/Source/core/dom/ContainerNode.cpp in Blink, as used in Google Chrome
before 49.0.2623.75, which mishandles Widget updates. Taken from Chromium's
Developers page: 'At the root of a View hierarchy is a Widget, which is a
native window. The native window receives messages from Windows, converts
them into something the View hierarchy can understand, and then passes them
to the RootView.'

The mishandling of Widget updates results in an easier medium for remote
hackers to bypass the Same-Origin Policy, allowing them access to data in
a second web page.

Normally, an origin webpage and a second/destination webpage must have the
same combination of URI scheme, port number, and host name, if data in the
second webpage is to be accessible by the origin webpage.
","This vulnerability was a combination of coding and design mistakes. Widget
updates were improperly handled, causing a delay that could facilitate the
manipulation of the DOM tree. The solution was simply to implement a method
that would effectively run the updates to prevent the acquisition of resources
from an external actor. Multiple fixes combined when targeting the prevention
of unauthorized DOM tree manipulation, as the initial fix did not account for
the update issue with widgets.
"
1325,CVE-2016-5148,chromium,"A vulnerability found in an older version of chrome made widgets vulnerable to
XSS attacks through ""widget updates"". Attackers could inject custom html files via
vectors into widget updates.
","I'd say that this is no fault of the developers or of their design. As a
professional developer, you will always have to deal with other peoples code.
It doesn't make sense to spend the time and write 100% of the project when
there is a plugin or library that will do it for you. Purchasing COTS software
is almost always a good idea financially and sometimes the only way to create
a reasonable project timeline. However, I do believe the onus is on the developers
using third party plugins to have a healthy distrust of those plugins and design
the system with that in mind.
"
61,CVE-2010-0662,chromium,"The memory for a struct is allocated based on a value provided by an untrusted
source elsewhere in the code. This is dangerous because the source may not
have the correct value for the amount of memory needed, and the resulting
Bitmap that is initialized will not have the correct amount of memory
allocated. This could lead to two attacks. The first is a denial of service by
causing an integer overflow. The second is being able to read potentially
sensitive data from the extra allocated data.

The fix is to recalculate the amount of memory the bitmap will require instead
of trusting the input.
","The issue here was caused by a design mistake when developing
the function. A parameter was made available in the struct passed in so
the developer believed there was not a need to recalculate it. The value was
being set by an untrusted input elsewhere in the code. As such the value
should have been calculated by a trusted source.
"
906,CVE-2013-6658,chromium,"The vulnerability occurs when Javascript executes multiple triggers for a
layout refresh (an attempt to re-render the page at hand). It
intermittently fails to handle those multiple triggers and causes
a ""use-after-free"" vulnerability as a triggered component attempts
to use another one that has been destroyed (memory freed) by another
component caused by the Javascript code which causes a crash (DOS).
","I believe that this vulenrability could have been avoided if mitigations against use-after-free were followed.
It seems that between the VCC and fix, it was noted by a review that this area in particular was a high risk
area that may induce such a vulnerability. However, no action was taken to mitigate the issue. the
vulnerability originated due to a lack of risk mitigation in this high risk area as well as no proper
unit tests in place despite this being a system critical component.
"
907,CVE-2013-6659,chromium,"SSL certificates are used by hosts so that connecting browsers know how to
encrypt messages and that the host can be trusted. When a new session is
started, such as logging in or out of a site, SSL must be renegotiated, or
reverified and encrypted.

When renegotiating with a host, SSL certificates would be reverified, but not
checked against the previous certificates to see if they match. This allows
remote SSL servers to use a new certificate chains unexpected by the user.
Consequently, this can lead to different information linked to the website
being shown to the user, making the user believe a different company owns the
site.
","This vulnerability exists due to an unforseen scenario where a server could
renegotiate a connection with a new, but still valid, SSL certificate.
Since the second certificate is still valid, it would be accepted, but in
reality each host should only have one certificate. Because the certificates
were verified both before and after renegotiation, and because it was likely
assumed the host only had one certificate, this vulnerability went 
unnoticed. If this specific scenario was thought of when designing the 
checks for certificates, it could have been avoided, but it is likely the
engineers believed the validity checks would be sufficient.

The vulnerability was fixed entirely in the two commits to fix it. Other
mitigations were already in place for validating certificates, but none
were in place for this particular vulnerability.

The two commits completely fix this vulnerability by checking the current
certification matches the old certification. Some comments throughout the
source suggest the functions were originally based on other browser
projects, and it is unclear if other browsers had a similar issue that was
patched at other times.
"
282,CVE-2011-1434,chromium,Opening suitable pages sometimes causes Chrome to crash at various places on startup due to a lack of thread safety when handling MIME data.,"A mixture of coding and design mistakes. 
Since thread saftey wasn't ensured while handling MIME data, 
if an attacker entered unknown vectors the system would crash. 
"
1319,CVE-2016-5142,chromium,"Due to poor handling of data buffers inside the cryptography API used in chrome
(WebCrypto), attackers could remotely cause a denial of service via crafted javascript
code. This is caused by a use-after-free error on a pointer related to the buffers.
","The mistake that led to this vulnerability was the fact that google assumed
there were no vulnerabilities inside the web crypto library that they used in
chromium. Despite unit tests, there were vulnerabilities that went undiscovered
inside webcrypto. The lesson to be learned here is that you can't necessarily
trust every external piece of software that your system depends on. Luckily, 
regression of this bug is unlikely to occur because more unit tests were created
to test for the case that causes it.
"
462,CVE-2011-3061,chromium,"The implementation of the code handling creating a socket connection to an
intermediary, request-handling server recognizes that a certificate error
exists but it appears to be ignored since it doesn't disconnect when the
error is caught. This could have allowed for a man-in-the-middle attack
where one could spoof a server and potentially get sensitive information
with the created certificate.
",The mistake could have came from a design mistake or an issue with requirements. The code was initially written to make sure to notice if a certificate mismatch is found. The mistake there was not disconnecting immediately. Why the code to disconnect wasn't written at first confuses me. It may be because of it not being stated in the requirements. It could also have made it through if it wasn't accounted for in unit testing. It could have even slipped through code reviews as well. The fix does look proper as it immediately does a disconnect.
1338,CVE-2016-5161,chromium,"In Google Chrome there was an issue with merging certain CSS styles together.
Their old implementation serialized the CSS property value and then reparsed 
it which didn't preserve the name of the custom property. In their test example 
the CSS that was causing the issue was '--A:var(---B)' and 'float:var(--C)' 
when applied to two spans.  When these styles were merged it would create a 
case where the system could end up reading memory that wasn't allocated which 
could result in a segmentation fault, which could be a denial of service.
","It was a design mistake. They failed to consider a certain type of input,
which when entered had the potential to break their system. They should
have considered CSS properties with custom values when desiging the
merging functionality. They should have had people who are experts in CSS
looking over the code to make sure that their implementation conforms to
the standards, the stakes are high for a project like this and google
definitely has the resources. They also could have written tests for all
of the different types of CSS inputs to make sure the merging worked as
expected for a variety of inputs.
"
1309,CVE-2016-5132,chromium,"This vulnerability allows insecure pages with an iframe to a secure page to intercept any communication between the secure page and the browser's Service worker. The service worker controls things like push notifications, background sync, period sync, and geofencing.",This appears to be a testing mistake. This vulnerability takes advantage of a very specific scenario that didn't seem to be accounted for in unit test.
1430,CVE-2017-5065,chromium,"Incorrect UI in Blink. Form input validation bubble doesn't go away on page
reload.
",
1017,CVE-2014-7929,chromium,"Use after free vulnerability occurs in moving a script from old document to
new document function. The function can cause a denial of service or an impact.
When a user moves an old document to a new document, then Chrome will move the
script between the old document and the new document. Chrome did not check if
the script is allocated or not will cause a crash or an attacker can add input
to overwrite memory.
","The person who was working on adding the feature by moving a running script across
documents did not check the use after free vulnerability case. It seems the original
code unit did not review all cases at the VCC. He/she did apply unit tests in the VCC
for some cases but not all. The VCC was focusing on moving pending async script loader
to the new document introduced the use after free vulnerability with the document
pointer.
"
1205,CVE-2016-1618,chromium,"This vulnerability pertains to pseudo-random number generation. More specifically,
the code in question uses a poor method of generating a random number, making it 
more vulnerable to external attacks than say, a proper random number library.
","This was a case of two developers not knowing that a previously widely understood
to be secure library was no longer standards compliant and was being retired. 
This might be classified as a Maintainability issue since we as developers cannot 
trust libaries always. 
"
1174,CVE-2015-6774,chromium,"The vulnerability was found in one of the functions relating to loading time 
within the Chrome's renderer subsystem.

Modification of a pointer through javascript can give remote attackers the 
ability to cause denial of service. Specifically, when the pointer used for 
reporting load times data is modified by javascript, the use of unexpected 
values can occur. To do so, a remote use would have to create specific content
that when loaded by the target system, will execute arbitrary code on the target 
user's system.
","The mistake made was assuming the type of the input before carrying out execution of
the variable. When working in a programming language that has the programmer handling memory,
having explicitly written code prevents some of these vulnerablities. 

Based on the CWE entry, to mitigate such vulnerability, one should try to use a language that 
provides automatic memory management. This was not done because execution should be optimal 
when it comes to speed and to do that, carrying out your own memory management gives more flexibility.
For the implementation fix, the programmer did set the pointer to null before carrying out further
implementation of the pointer. This would seem to be the proper fix to a problem such as this.
"
956,CVE-2014-1747,chromium,"Certain file types embedded in an HTML page would be automatically downloaded with no user prompt and any javascript 
code contained within the file would be executed.
","The fix whitelists the acceptable location of the input, limiting MHTML documents from being loaded in any frame except the top.
The major mistake here is allowing files to be downloaded automatically, and enabling javascript code execution in areas where it is not necessary.
"
542,CVE-2011-3898,chromium,"If users had a version of Java that was 7 or above, then applets were allowed to run without any confirmation from the user. This was due to the code only checking for Java versions below 7.",The choice that ultimately lead to this vulnerability was the choice to add an upperbound on the Java version when it was not necessary. This caused a real security issue when Java version 7 and above were released.
1025,CVE-2014-7937,chromium,"Multiple off-by-one errors in libavcodec/vorbisdec.c resulting for-loop over/under-execution.
The vorbisdec.c is a decodeder for vorbis data. Vorbis is an open-source project that
produces audio coding for lossy audio. These error allows for possible denial of
service attacks. Other vulnerabilities such as information disclosure and unauthorized
modification may also exist, with the crafting of vorbis data.
","This error was cause by a simple coding mistake, an off-by-one error. Theses mistakes are bound to happen,
the only thing that can prevents error like this are extensive tests that include boundary and edge
cases. The mitigation is very simple and does look proper. An off-by-one is quite easy to identify
and correct. This was fixed according to the CWE, as the fix is making sure loops stay within range, when
working in languages like C.
"
1261,CVE-2016-1675,chromium,"Prior to the fix for this vulnerability, remote attackers were able to bypass the
Same Origin Policy by mishandling Document attachments during the FrameLoader and
LocalFrame document attachment process. Essentially it allowed for an elevation of
privilege, creating issues with security within the software (Along with cross-site
scripting vulnerabilities). This could allow for malicious code to be executed, or
give to the attacker privileges that could harm the rest of the system.
","The general design flaw from this problem seems to have stemmed from an attachment
functionality from an outlook process. It's strange that this was used all the way up
to the time it was... and it's interesting to see how high coupling can really
affect a software system over a long period of time. It sometimes makes sense to use
older functions to accomplish common tasks, but when it becomes so depricated that it's
just getting in the way it needs to be removed.
"
78,CVE-2010-1504,chromium,"This problem was found early on in chromes development and for good reason. If you passed an html <script> tag to
the url when inputting a url in the url bar, it would directly place the script code into chromes internal html
code and it would exectute that script.

For example, for a website such as www.website.com/#<script>blah</script> it would execute the script appended to the
end of the url due to the vunerability.
","This was a design mistake that led to this bug. In this intial code, it was not taken into account that
a user may provide a bad link with html code directly in it. This bug is also so old, that it is likely that it
was unknown exactly what kinds of attacks were possible at the time. The fix for this was correct but not complete
and later, a complete solution was added essentially making it impossible to use an XSS attack nowadays using the
same attack as before. The original developer also perhaps did not understand that the line of code
""url.InnerHtml = url"" would set the actual web pages executable html to whatever the
user inputs, which is of course bad.
"
1322,CVE-2016-5145,chromium,"Blink, a rendering engine used by Chromium, allowed remote attackers to bypass the same-origin policy
restriction for images that was written in the JavaScript code. Same Origin Policy is a concept where
a web browser allows scripts in the first page to access data in the second page but only if they are
from the same origin (URI scheme, host name, and port number). They are able to bypass the policy because
Blink did not ensure the taint property is preserved after a structure-clone operation on an ImageBitmap
object derived from a cross-origin image. What this means is that Blink, after cloning of an ImageBitmap
object, did not keep the property that determined whether it would taint a canvas or not with cross-origin data
which would prevent interactivity.
","The primary mistake that was made here that led to this vulnerability was a result of an oversight in the implementation of a structure-cloning operation. Whoever wrote the original function to clone a bitmap forgot to include the taint peoperty that is important in realizing whether or not scripts in the first page could access data in the second page. They had overlooked the fact that the same origin policy was important and so when writing the bitmap code, they did not include checks that verified if the bitmap was from the same origin. This vulnerability should not prove to be a problem in the future because the code appears to have been fixed and reviewed carefully. There is now an added test case which will check to make sure this wouldn't happen again as well."
1279,CVE-2016-1693,chromium,"When downloading the CCT (Chrome Cleanup Tool) binary, HTTP was used.
This allowed an attacker to spoof the identity of the CCT. The consequence
is that a man-in-the middle attacker would be able to send malicious executables
to an HTTP session.
","I am unable to view the Bug report that the VCC fixed so I am not sure if the author's
usage of HTTP instead of HTTPS was a miscommunication across team members.

It could have been a lack of knowledge of what the difference between HTTP and HTTPS
is and why HTTPS should have been used in this situation. If that is the case,
then I don't think it is really a coding mistake. The mistake would be that the domain
and implications was not well understood by the developer. Although HTTPS itself doesn't
completely against man-in-the middle attacks, what it does it encrypt the information sent
accross a connection so that a third-person cannot intercept the data and view or modify it.

Given that the time between the VCC and the fix was over a year, and several
chromium developers saw the code, it is a mistake that it is not automatically realized
that HTTP should not be used.
"
963,CVE-2014-3157,chromium,"When decoding a video, a buffer is allocated for each frame to be decoded in
to. However, if the buffer is not large enough to hold the decoded frame, a
heap overflow occurs, which can allow data to be written where it should not.

This Heap-based buffer overflow inside the function to get a video buffer for 
decoding allows remote attackers to cause a denial of service by causing the
system to crash. An exploited to abuse this could be a malicious video file
embedded on a web page.
","The coding error was a buffer overflow, caused by not allocating enough 
space for ffmpeg to use for decoding. This mistake was because the buffer
provided by chrome did not use the same calculations for allocating space
as a buffer that would be provided by ffmpeg.

This vulnerability was caused by misunderstanding how ffmpeg allocates and
handles video buffers. The team changed the code so Chorme provides a
buffer for ffmpeg to use instead of letting ffmpeg allocate a buffer, but
they used a slightly different calculation to determine the size of the
buffer. 

The solution implemented was to allocate the same ammount of space as
ffpeg would have for the buffer, ensuring that there was enough room to 
not overflow the buffer.
"
985,CVE-2014-3189,chromium,"An out of bounds read occurs when data is read past its intended boundries. In the
case of this particular vulnerability, a function responsible for copying an image to
known destination was able to preform an out of bounds read. This was allowed by
not checking that the size of the image you want to copy makes sense. This is done by
checking for negative x,y values and also making sure that size wise, it could be contained within
the data being passed in as the source data. Not having these checks 
in place allows either a buffer overflow to occur by reading and trying to store 
a mass amount of unintended data, as well as has the possibiliy of producing
segmentation faults by reading outside the program's assigned memory which could lead to a denial of service.
Most importantly, this vulnerability could be leveraged to allow leaks of sensitive information. Since
you are able to read outside intended boundaries, one could read around to try and find sensitive data contained
within a particular processes assigned memory region.
","The mistake that led to this vulnerability was not sufficiently testing the 
pdf plugin source before introducing it into the chromium codebase. In terms
of the plugin itself one could also say that this has the design mistake of 
not implementing proper boundry checking of incoming parameters.
"
1036,CVE-2014-7948,chromium,"Google Chrome caches pages despite having an SSL certificate error which allows man in the middle (MITM)
attacks to spoof HTML pages via a certificate that the attacker can create. The MITM can intercept web pages
and replace the site's page with a malicious one on a malicious server or site.

The fix for this vulnerability is to refuse to Application Cache responses with any SSL certificate errors. Basically to not
ignore SSL certificate errors unless they are flagged to do so.
","I think that the vulenrability is interesting because it is difficult to find/test for. What made this vulnerability
was a design issue where the developers failed reject caching a page after ignoring SSL certificate errors. This also
may be a requirements issue where the devs know not to execute something after a non-trustworthy certificate but
may have overlooked it thus a non-google employee discovered it. We are human after all. The main thing for practitioners
to learn from this vulnerability is to have your code/product properly handle errors and to never ignore any given errors
that can lead to a possible execution that you did not intend.

As for the mitigations, the team does properly check for SSL certificate errors
and validates whether it is valid or not or has a tag that allows the certificate errors to be ignored.
"
910,CVE-2013-6663,chromium,"The SVG implementation in Google's web engine *Blink* allows for the use of
an object after it has been freed from memory. This was caused because
resizing an SVG image could destroy the renderer which would cause a
""use after free"", crashing the engine.

The vulnerability could cause a denial of service but its impact is limited
beyond that due to the fact that there was only the resizing of the image
between the free and its use which causes the crash.
","The coding mistake that occurred was due to the fact that the original author
of the function did not realize, or forgot, that resizing a container could
destroy the renderer and had misplaced his check for it. The same chromium
developer who originally wrote the method also added the fix and an additional
test case.

The vulnerability was a part of the initial creation of the function and
thus there could have been a small design mistake which led to it. Being
more familiar with the SVG renderer likely could have prevented this mistake
as it appeared to stem from a misunderstanding about the unintended
side-effects resizing a container could have.

The Chromium team uses the Modern Code Review (MCR) process whose
effectiveness has come under question in recent years. The original author
of the VCC, pdr, has also only ever had one documented code review and it
was not for any code related to this vulnerability. These two factors may
have also contributed to the vulnerability going undetected.

Source: http://ieeexplore.ieee.org/document/7781793/
"
332,CVE-2011-2345,chromium,"This vulnerability is exploited based on improper handle of string
in Application Programming Interface (API) which allows remote attackers to conduct
a denial of service attack based on out-of-bounds (CWE-125) read using unspecified vectors.
For example, without input validation and verification, an attacker can pass in an arbitrary
memory address to read sensitive data from the system or an arbitrary snippet of code 
to execute inside the application. In case of arbitrary code, attacker can cause
significant harm to the system such as retrieving sensitive data, modifying 
application's internal data or even affect other users.

The vulnerability was first introduced in the Netscape Plugin Application Programming
Interface (NPAPI) of Google Chrome before version 12.0.742.112. When '\' is passed to
function in the NPAPI, the value is read in as an arbitrary memory address. When the 
memory address read is outside of the address space that the computer gives to the 
current process, it is an out-of-bounds read. Out-of-bounds read causes the process 
to crash and when there are enough crashes, system resources are unavigateailable to other user.
","The mistake that led to this vulnerability was lack of defense in depth
principle, the developer forgot to validate and verify inputs in API module
which is used by everyone. Overall, it's a coding mistake. The original code
basically read in whatever string user passed in without validating it. As
a result, when user passed in an arbitrary memory address, the vulnerable
function just returned to user data stored in that memory location. Should
the developer be more careful and validate the inputs, unsafe inputs can be
avoided.
"
158,CVE-2010-4033,chromium,"Chrome does not verify that the user is the one submitting data when saving auto-complete data.
If Chrome stores the data automatically it can overflow what chrome is able to handle and crash the browser.
An attack targeting this vulnerability would be a malicous site continously filling and submitting a form to 
overflow the possible storage of auto-fill data and crashing the browser. A Google employee determined that in the matter
of a few seconds a form doing that would be able to crash the browser.
","This vulnerability appears to be an oversight in a potential line of attack which was then caught later on.
The infobar that originally designated form data as being saved no longer appered so the user would not know when data was being saved.
Because this infobar no longer existed, it was possible to fill/overfill the store of data malicously and crash the browser.
"
1282,CVE-2016-1696,chromium,"Remote attackers could bypass the Same-Origin Policy via unspecified vectors
since the Extensions subsystem in Google Chrome didn't properly restrict
bindings access.
The Same-Origin policy states that web browser scripts can access data in a
second web page, but only if they have the same origin. Bypassing the
Same-Origin policy means that data confidentiality or integrity could be lost.
","The CWE ID for this vulnerability is 346, and is titled Origin Validation
Error. This vulnerability was caused due to not enforcing the Same-Origin
policy. Looking at the code review, we see that the developers had an
in-depth discussion and recognizd that there were files not being used, and
new native handlers were made for the extensions. In order to prevent these
types of vulnerabilities, a potential mitigation would be to separate
privileges. Following the principle of least privilege during the
design/coding process would've fixed this issue. In order to ensure this
issue doesn't occur again, the developers expanded their bindings access
checks. These checks will enforce the Same-Origin policy and make sure that
the source is checked, and that malicious websites cannot be loaded.
Preventing Origin Validation Errors by testing the origin will lead to a
safer system, and prevent attackers from gaining access to undesired
functionality. This vulnerability is very similar to CVE-2016-1622 in
regards to the type of malicious actions that attackers can perform.
"
869,CVE-2013-2926,chromium,Use after Free vulnerability in the 'Indent' command of the rendering engine 'Blink'. The vulnerability could be used to cause user-assisted denial of service attacks.,"This was a simple coding mistake that occurred when the 'Indent command' function was refactored.
The developers refactored the code to make it more readable.
However, they accidentally made an incorrect assertion in one of the 'if' statements.
The original 'Indent command' made the correct assertion, so the developers made a simple coding mistake that was overlooked for a little bit.
An automated tester was able to find this incorrect assertion and bring it to the team's attention
The vulnerability was fixed when the team simply removed the incorrect assertion from the function."
745,CVE-2013-0843,chromium,"For Mac OS, the buffer size is too small when running the 96 kHz sampling
rate, allowing remote attackers to cause a denial of service (DoS)
attack. This, in turn, can cause memory corruption and have the application
crash as well as cause some other impact to a third party site that provides 
WebRTC audio, increasing the risk of sensitive information disclosure.
","I believe that, since this vulnerability was due to not considering
the use of 96 kHz sampling rates for MacOSX, additional 
cases of increased rates (96 kHz, 192 kHz) should be included in the unit
testing scripts for all platforms to ensure that this type of vulnerability
is not repeated. It's important to have good boundary testing in order to
determine how your code works within and outside of your expected value of
ranges as it can cause other issues that the system may not be prepared for."
1329,CVE-2016-5152,chromium,"A function inside of OpenJPEG which is used by PDFium in Google Chrome
didn't prevent integer overflow giving attackers the ability to cause 
denial of service with heap-based buffer overflow attacks.  This occured
when an svg element was rendered in an iframe.

A heap-based overflow attack could allow malicious users to access 
memory they shouldn't and write data to those locations the program does
not expect at run-time.  In this situation the consequence of one of these attacks
is that Chromium cannot handle the corrupted memory and will stop working which
is an example of denial of service.
",I believe design mistakes were made by the Chromium team.  By incorporating the open source OpenJPEG2000 project Chromium was exposed to vulnerabilities in that project.  Security doesn't seem to have been as big a concern to the developers of OpenJPEG as compared to Chromium.    It is likely that many other vulnerabilities have been found/exist as a result of the use of third-party software like OpenJPEG2000.
1179,CVE-2015-6779,chromium,"When a user opens a pdf file in the chrome pdf-viewer, and the pdf file has a link 
to a url, they can open this link in a new tab. This allows for the scheme restrictions
of a pdf to be bypassed.  This is prohibited in HTML. This also should not even be
possible in a pdf file.
","I would say that this vulnerability was a culmination of design mistakes and 
potentially poor requirements.  I say this, because a vulerability like this
should not normally occur.  HTML prohibits this and PDF documents do not normally
allow this behavior.  My guess is that some niche design decision was made that
allowed for this behavior.  It is also fair to say that this design decision may
have been made due to poor requirements.
"
901,CVE-2013-6653,chromium,"Certain aspects of how Google Chrome handles displaying web contents allows a
remote attacker to generate a webpage that attempts to access the operating
system's color chooser (think of the dialog that you can open in Windows Paint
to select a color) in a conflicting manner.

This is essentially a concurrency bug that causes a race condition (i.e., two
threads/processes try to access the same resource at the same time) for an
instance of the color chooser. If more than one webpage accesses this color
chooser, and that color chooser's memory resources are then freed, this leads
to what is known as a ""use-after-free"" error. This only seems to cause Chrome
to crash (an example of ""denial of service""), though it has the potential to
cause other serious issues.
","The main mistake made throughout this vulnerability's history was essentially
a resource management issue - instantiation of the color chooser dialog was
not handled properly, and as a result a race condition could occur and cause
the browser to crash.

Though not exactly what is recommended as a mitigation in CWE-416, the
developers used NULL to indicate failure if a color chooser dialog has
already been opened. At the very least, this prevents the same issue from
happening again.

The vulnerability was introduced by two developers across two commits,
although there are no signs of miscommunication between the two of them.
It seems as though they were just attempting to address the same issue
at different points in time, which led to the vulnerability.
"
348,CVE-2011-2785,chromium,There was an issue with the Extensions in Chromium that allowed attackers to cause various issues. This was caused by attackers abusing the fact that Extensions didn't validate URLs for home pages as the way they should. Attackers could use custom Extensions to do damage.,A lot of it had to do with poor sanitization of URLs are restricting privileges. This is more on the design side rather than requirements or communications. The fix looks like it might work but could have some work-arounds. The ending fix was to validate the homepage only if it was http or https.
1182,CVE-2015-6782,chromium,"In the The Document::open function in WebKit/Source/core/dom/Document.cpp in Google Chrome before 47.0.2526.73 has a improper input validation which The product does not validate or incorrectly validates input that can affect the control flow or data flow of a program. The page-dismissal event handling is compatible with modal-dialog blocking, which makes it easier for remote attackers to spoof Omnibox content via a crafted web site.","I think this is coding mistake that a developer accidently create a vulnerability 
that makes it possible to display arbitrary content under the URL of the website 
that the user is trying to access (from the attacker's page,through the omnibox). 
After examining the mitigations I think ths is proper fix for it
"
1237,CVE-2016-1651,chromium,"This vulnerability causes an information leak or a denial of service
during the rendering of JPEG images in PDFs. It can be exploited by embedding
a specially crafted JPEG image which will read memory past the end of the
allocated space, due to a mistake in the implementation of a type conversion
function. The fix involves checking the size of the image prior to allocating
memory.
","Parsing JPEGs is a relatively small portion of the PDFium application, and it
seems like it's something that requires a specific skill set. Because of this,
I believe the developers should have used a previously written and tested
JPEG converter/parser, instead of trying to write their own.

Besides that, it was clear that the JPEG parser was not unit tested until relatively
late in the project's existence, which was a mistake. It's a lot harder to detect
bugs and vulnerabilities without unit tests.
"
521,CVE-2011-3876,chromium,"File downloads with trailing whitspace characters at the end of the file name were not handled 
properly. No download warning was given to users if they weren't explicitly downloading .exe 
file. Users could download a .exe%25C2%25A0 file without warning trailing characters were 
stripped from the file name which may lead to a user downloading something like a .exe file 
without their knowledge.
","It seems like this was a coding mistake that no one initially caught because it occurs in a
very specific circimstance that doesn't happen often. The developers probably did not 
recognize this as an issue when they created the bug. The fix replaced whitespace in file 
download names with hyphens instead of wiping them out completely. This is a better 
solution although it still gives the user to download an exe without warning. The user 
would now have to manually alter the file name in this case in order to allow the file to 
act maliciously which is better than potentially converting a file to exe without warning.
"
976,CVE-2014-3173,chromium,"WebGL (Web Graphics Library) does not ensure that clear calls interacted properly 
with the state of a draw buffer. This could allow a denial of service attack by 
reading uninitialized memory, which causes weird states in the code.  Also, it leaked virtual 
RAM but it was only from sampled textures so this wasn't much of a concern.
","This issue appeared to be a coding and logic mistake.  The potential problems
that were caused by the uninitialized buffer being called were not thought of
in the initial implementation of the patch they created.  This caused a buffer
overflow.  There was not much of an issue with leaking sensitive data however
because it only accessed sampled textures, but there was a potential risk of a
denial of service attack do to unwanted states being caused by an exploit.

Their solution to this bug was not one of the possible mitigations on the CWE
page, but still effective.  They just check the buffer to see if it is
uninitialized before trying to clear it again.
"
349,CVE-2011-2786,chromium,"
The pop-up screen for speech-input-bubble in google chrome can be moved out of the 
screen. Google Chrome fails to ensure that the screen is shown on the product's screen. 
This might make it easier for the remote attackers to make audio recordings via a crafted
web page containing an INPUT element. 

Web page can start speech recognition whenever user clicks anything on web page. 
The problem is that Chromium relies on a popup showing that recognition is started. 
That popup can be moved to be outside the screen. With the use of this ability, the 
attacker could use this  as a platform for phising attacks. For instance, if the attacker 
can cause the UI to display erroneous data, or to otherwise convince the user to 
display information that appears to come from a trusted source, then the attacker
could trick the user into performing the wrong action. Hence, causing the source,
the original window - to be obscured or spoofed. 
","This really seems to be a mix of requirements and a design issue, the engineers 
clearly didn't think about enough cases and requirements on the ability of the 
speech-input-bubble whether it could be dragged outside the window. The did not have 
a complete test plan. The actual fix wasn't that complicated and involved just adding
more checks. "
1188,CVE-2015-6789,chromium,"Blink is an open source rendering engine used to visualize web content loaded by Chrome.
The affected code uses MutationObserver objects to monitor and log specific events.
The MutationObserver objects are stored using raw pointers, which cause use-after-free
issues if the object is no longer at the expected location in memory when the pointer is
referenced.  Exploiting this vulnerability requires the creation and subsequent deletion
of a MutationObserver object, which will result in denial-of-service when a crash is caused.
","A developer removed support for specific heap memory testing, which was relevant 
as the vulnerability resulted in a heap related error when discovered.  Removal of
this support may have resulted in the six month discovery time for the vulnerability.
This issue may have been discovered with more robust unit testing, but only the developer
who implemented the fix added testing for the MutationObserver HashShet.  Improved testing
and capability for testing could have lead to earlier discovery for this issue.
"
927,CVE-2014-1715,chromium,"Path traversal vulnerability that can lead to creating a junction point (an
alias to another directory) out of a valid directory within a sandboxed path
to the root of the system partition, where critical files are kept.

A valid directory within a sandboxed path can be explained as follows:

Imagine if the program is running in a directory called 'safe'. This directory
is a valid directory for the user to access files in. This directory is
within the sandboxed path (e.g. usr/program/safe). Anything outside this sandboxed
path is considered unsafe and therefore an invalid directory.
","Ultimately, this vunerability was the direct cause of a coding mistake,
however, the coding mistake is very obscure and could easily be overlooked
by someone either inexperienced with the nitty-gritty specifics of file
systems, or by someone who may be aware but just wasn't super vigilant of
this particular issue.

Proper mitigations such as making sure we're still in the sandbox directory
were taken, however this vulnerability simply went a step beyond such a simple
mitigation.

It should also be noted that the VCC was by a single person adding >900 lines
of a code, which is definitely error prone.

I think this really goes to show you that mitigations are far from perfect.
I'd say based off of what we've done in class and what we've seen about
mitigations regarding path traversal, those steps were taken. But even with
those steps, the vulnerability in this case is still disastrous.

Something as niche as this most likely would require outside sources, such as
a security expert, or in this case -- a competition, to clearly identify the
vulnerability and handle the mitiagtion properly.
"
881,CVE-2013-6628,chromium,"Google Chrome was not checking that the servers digital certificate, which exists as 
part of the SSL authorization process, is the same during renegotiation of the client socket as it was 
before the renegotiation. Renegotiation is a way to adjust the the parameters of the SSL 
handshake without needing to make a new SSL session. This means that remote web servers could 
interfere with trust relationships of a session.

An example attack of this would involve starting a renegotiation during the authentication between 
the server and client, changing the certificate sent by the server so that it gets authenticated by the client.
","This was either a design mistake or a coding mistake but I am leaning more towards design mistake. 
At some point they know that renegotiation of sockets happens, and they know that there is a certificate proving 
what you were before renegotiation. No one had considered(at a design point) that during renegotiation the certificate 
could be changed. And up until the point that renegotiation got handled in the code, no one included any cases for if 
it had or added code saying it could not.
"
213,CVE-2011-0776,chromium,"On Mac, Chrome's sandbox can be escaped to obtain information about local files.",The issue ultimately derived from Mac allowing calling stat() on arbitrary paths when that isn't expected. This required Chromium to adjust its access to that call. The issue also could have been avoided if Mac's interface to the stat() system call was in line with user expectations.
496,CVE-2011-3096,chromium,"There was a vulnerability on Linux machines that would allow remote hackers to
cause a denial of service attack through use-after-free of a particular error
in the GTK implementation of the omnibox, a web browser address bar that also
acts as a search engine. GTK is a toolkit used for creating graphical user
interfaces.
","After sifting through all of the commits and posts about the vulnerability,
I would have to say that this mistake came from a misunderstanding of how
GTK handles object removal. Unfortunately, the programmer was under the
impression that GTK would handle closing the signal listeners for them.
Because of this misunderstanding of a third party dependency, the
vulnerability slipped into the code. I would have expected there to be a
test to see if you could still call the signals even after destroying the
object, but there was no such tests.
"
1238,CVE-2016-1652,chromium,"Cross-site scripting (XSS) vulnerability in the ModuleSystem::RequireForJsInner
function in extensions/renderer/module_system.cc in the Extensions subsystem
in Google Chrome before 50.0.2661.75. This allows remote attackers to inject
arbitrary web script or HTML via a crafted web site, aka ""Universal XSS (UXSS).""
Should an attacker inject their own scripts, they will be able to spread malicious
code to various end user's. The attacker could compromise a user's browser data
and even alter the content of an HTML page.
","The mistake leading to this vulnerability, was simply rooted within a
privacy issue regarding getters and setters. These were modified to deal
with private properties instead of regular properties. These was done to
make interception harder from the outside. By privatizing properties, they
become less accessible to attackers, helping to eliminate the acquistion of
data that should not be publicly transmitted. The mistake was truly a simple
coding mistake that was corrected in conjunction with additional files as support.
It was fixed within a matter of days, which attests to the fact that not much
needed to change to mitigate the vulnerability.
"
1243,CVE-2016-1657,chromium,"The method to force focus on the address bar to allow a user to overwrite the
contents of the address bar would misbehave when a user, or site, uses a method 
to generate a blank page. The method would append the new url onto the existing 
blank page url. This would allow the page url to appear as a different page, 
allowing an attacker to spoof a site to gather information from an unsuspecting 
user.
","The vulnerability was due to trusting users. They were allowed to append to 
the url on an about:blank page to essentially spoof a website.

The fix prevents the address bar from being focused and appended to if the
about:blank page wasn't created as the startup page. This prevents an attacker
from creating an about:blank page and appending to the url. This fix should 
be permanent."
751,CVE-2013-0884,chromium,"Initially, the code allowed the specific urls to run Native client applications until special privileges were added. With special privileges being added, the code is to be removed because granting special privileges to HTTP URLs isn't a good idea. HTTPS and public keys are to be forced for this subdomain.","The only mistake that occurred was designing the system. They didn't think
about the subdomain that was added in the fix for 8 months until special
privileges were granted to users.
"
1242,CVE-2016-1656,chromium,"The download manager did not check the file name to make sure that an attacker
can't download a file to an unwanted directory outside of the Chrome folder for
downloads. This vulnerability occurs when a user downloads a file from a website
and the website change the file's name with a relative path cause Chrome to
put the file in a wrong directory with the http request.
","The team did apply the filename sanitizer; however, it was not part of the
http request content disposition sanitization. What we can learn from this
is when working with a download manager, you have to make sure the manager
sanitize the filename and the file path from the http content disposition.
I would say this is part of requirement mistake because the download manager
is a critical part of the browser task and people use the download manager
daily makes the manager a security risk.
"
1346,CVE-2016-5171,chromium,"WebKit/Source/bindings/templates/interface.cpp allows for constructor calls to be
used, when that constuctor shouldn't be allowed. If able to get a constructor to
make one of these illegal calls, it can cause the particalar system to crash or 
stop working, causing a denial of service.
","What seemed to lead to this vulnerability not being found was using their 
own testing class and methods instead of incorperating already created 
testing options. This is seen at the final commit of this code, where all 
of the custom testing methods mode were deleted.

This was created by one person (for the most part), and I think this person
either did not know about testing packages out there, or did not want to
use them. I think this shows that using packages or reliable code from
others is ok to do in the right situation. This would have saved a lot of
time and effort if it was done right away.

I wasn't unable to really figure out what was going on, but it seemed to be 
a very simple fix to get this vulnerability fixed. When defining the local
V8 template variable, they made a funciton value without specifing the parameter,
""V8ObjectConstructor::isValidConstructorMode"". Maybe an extra parameter was added
in later to allow for specific constructors to have their specific functions, but
it is very unclear from the code that I saw.
"
1365,CVE-2017-15394,chromium,"Embargoed. URL spoofing in extensions UI.
",
1101,CVE-2015-1268,chromium,"A Document Object Model wrapper could be returned with an incorrect scope, allowing the remote attacker to bypass the Same Origin Policy. This policy limits scripts from a webpage to only access information on a second webpage with the same protocol, domain, and host.","This vulnerability's VCCs were made over the course of 8 months, by two people, one of which will be the patcher of the vulnerability. This tells me that there could have been a design mistake that led to passing in a type that was not intended to be there, or was intended to be there and the consequences weren't understood. If it was not a design mistake, I'd suspect that it was a lack of knowledge about the effects of the type being passed in."
1091,CVE-2015-1258,chromium,"A specific webm file was able to crash Chromium when opened in a tab. The webm caused a
negative size parameter error in a Chromium dependency, libvpx. From what I can understand
from the technical solution discussion on the issue report, this negative size parameter caused
a buffer overflow.
","On the libvpx side, it's likely that there are some coding mistakes allowing such a vulernability to exist
or communication mistakes in not making the importance of the size limit flag not obvious enough. On the
Chromium team's side, I would say that they were not thorough enough in their research of libvpx and the
flags available to them when building it to be used within Chromium, as their omission of the size limit
allowed for this vulnerability. Since this is a very niche vulnerability mainly caused by configuration
issues of a third party dependency, the mitigations for the CWE are not particularly relevant or useful.
"
954,CVE-2014-1745,chromium,"This was a vulnerability in the SVG implementation of Blink, Chrome's
rendering engine, that allowed for a denial of service attack.

A change was made to enhance the performance of the implementation, and allow
the browser to selectively update font rules of a page, rather than having
to reload the entire FontSelector when things are changed. The vulnerability
was caused by the removal method, wherein not all references to a removed
element were cleared, even after said element's memory was freed. 

The program would still attempt to use these elements, and would either crash
or have unspecified behavior. 
","After analyzing the bug report and comments that followed, as well as the
discussion on the VCC, it seems clear that this vulnerability was a simple
coding mistake.

The author of the VCC simply overlooked a reference in a major enhancement
to the renderer, and fixed it after the vulnerability was reported. 
"
24,CVE-2009-2060,chromium,"The Vulnerability was in authentication. A false positive or improper
checking has been done on the validity of the identity of someone. The HTTP
Host header was used in responses from a proxy server.  When a certain
response was given, someone passing the response along was able to change
the content. This man-in-the-middle attack can occur relatively undetected.
","The main root cause of this was oversight when testing scenarios that could
happen but were never accounted for. The way it was caught was by observing
the result from one specific input. It is often difficult to have catch for
every situation when developing.
"
1180,CVE-2015-6780,chromium,"This vulnerability allows for remote actors to cause denial of service or 
other damage to chrome. The issue is a use-after-free vulnerability and exists 
in the Infobars version of Google Chrome. Use-after-free refers to memory that 
has been allocated, used, and then freed, but is then able to be used again 
(where it is not supposed to be). Infobars are displayed below the url bar when 
there is related information that is important to inform the user about. In 
this case a malicious actor could abuse freed memory through the chrome InfoBar 
to “[tear] down” the whole browser.
","This vulnerability was caused by a mistake made at the code level.
Ultimately the developers never reset a pointer that attackers would have
been able to leverage to cause denial of service in chrome. After this
pointer was freed, attackers would be able to use the memory address to
bring down the service.
"
397,CVE-2011-2849,chromium,"The webSockets implementation in Chromium had a vulnerability due to the
referencing of a NULL pointer. When a browser tab was closed it would make
the current web socket null, however, if the tab still had stacked sending jobs
(SendPending) it would attempt to reference the NULL socket pointer resulting
in the browser crashing. This vulnerability could have been used to cause a
denial of service attack.
","The coding mistake was an edge case in which closing a tab would destroy
the websocket but the WebSocketJob would continue sending multiple sending
jobs. This resulted in the use of a NULL pointer which could cause a denial
of service.

This mistake came about as a result of three commits from two individuals.
The first of these commits added the majority of the code which had this
vulnerability and the vulnerability was likely due to the developer not
thinking about this edge case. Since he didn't anticipate the issue, the
other individual working on the code didn't notice it, and the automated
unit tests didn't catch it, the bug slipped through. In the future more
vigorous test likely could have caught the bug. Being more familiar with the
use and intricacies of using websockets would aid in preventing the mistake.

The Chromium team uses the Modern Code Review (MCR) process whose
effectiveness has come under question in recent years. Both of the original
authors of the VCCs have many code reviews during the time between when the
bug was introduced and was fixed, some of which were on the code base
containing the vulnerability. This again brings into question either the
effectiveness of MCR or the effectiveness of the reviewers.

Source: http://ieeexplore.ieee.org/document/7781793/
"
1234,CVE-2016-1648,chromium,"The vulnerability occured in Google Chrome's Extensions, specifically in the GetLoadTimes function of renderer/loadtimes_extension_bindings.cc.
An attempt to access memory was made after the memory was freed, causing a use-after-free vulnerability. Attackers can use this to crash the system and cause denial of service problems, or use the memory access to perform some action in memory not defined by the system. By using a technique like Cross-Site Scripting (XSS), attackers can write their own javascript and have it run by the system.","From my research, I would mark this vulnerability as the result of a big design change at one time that allowed a simple but big mistake to slide through. The file was being almost enirely rewritten to improve performance and update the techniques used, so it was likely for something like this to happen.
The fix changed a lot of code in the file, but if you look at the changes, the overall flow of the code didn't really change. The design was modified to check for a failed set instead of relying on a successful set, as well as nulling the incoming arguement automatically instead of doing it only if the frame, data_source, or document_state failed to be retrieved. From most of the angles you look at it, it seems like just a design mistake from the performance update.
The takeaway from this is to remember the basics as you are designing a bigger chunk of code because a few small mistakes can chain together and cause a bigger vulnerability."
908,CVE-2013-6660,chromium,"Extra information can be gathered by wesites about where you are uploading a file from which can be a data leak.
The extra information that can be gathered is the location of the file on the local filesystem which is information a website does not have a need for.
The information is available becuase when a file is dropped into Chrome it fills in the URL data (attribute of the object) with the local file path.
","It looks like this vulnerability could have been prevented if the team developing the drag and drop functionanlity kept information leaks in mind a little more.
"
1376,CVE-2017-15405,chromium,"Symlink traversal in cryptohomed that allows a persistence established by malicious code
with a race condition. Cryptohomed is able to execute commands as root. This is a execution
with elevated privileges example.
",In my opinion this was a coding and design mistake. The race condition and symlink vulnerability was not just a coding mistake because it involved path traversal and therefore would have been difficult to pinpoint in just code. Avoiding a symlink by using a value from a config file or using a string in the code could have prevented this vulnerability.
1029,CVE-2014-7941,chromium,One of the functions in the applications uses an int data type for a certain value that can get particularly large.  Since int variables have a smaller maximum value the variable was going over the max and looping back to the negative values.  Having negative values could cause a denial of service.,"This vulnerability was caused by a coding mistake. The developers did
not fully think through what data would be stored in this variable.
From this bug, you can see how useful fuzzers can be. Two different
fuzzers were able to find this bug, which shows that it is not
super difficult to make a useful fuzzer.
"
1093,CVE-2015-1260,chromium,"Attackers can execute arbitrary JavaScript code upon completion of a
getUserMedia request. The Object in question was destroyed within the 
subroutine it was being called in, allowing the memory to be accessed after it has 
been freed.
","The mistake for this vulnerability was made when an engineer decided to 
remove the default case of the switch as well as move a critical function 
call that is executed when none of the cases match. While this function was 
moved, the function itself was not changed and thereby the Object was 
deleted from memory but then accessed again in certain use cases.
"
1206,CVE-2016-1619,chromium,"A PDF file containing a malformed JP2 image can cause an out-of-bounds read 
in the openjpeg library. Remote attackers are able to cause a denial of servie 
(out-of-bounds read) via a created PDF document. The error occures when the 
{PDF is being parsed and an JP2 image is found and rendered.
","Codex code is very complex and is generally created and then left alone. 
Software engineers don't want to have to continuously look how a PDF is rendered
and prefer to just assume it works as intended and leave it alone. This may be 
problamatic for changing systems. This vulnerability could have led to a denial 
of service attack by crashing the server. Software engineers must be wary of what libraries 
they are using and protect their system from outside vulnerabilities.
"
283,CVE-2011-1435,chromium,"The implementation of permissions for browser extensions was not properly secured.
Plugins utilizing the file system could use this error to access files outside of their designated
sandbox. This allowed an attacker to access any files on a user's system using malicious code
inserted into a browser extension, assuming some knowledge of the user's file structure. They were
able to access these files at the same level of permissions as they would have in their sandbox,
i.e. read and write permissions.
","I feel that there was a design mistake made to lead to this vulnerability.
The design decision to allow for unrestricted access to the file system with 
a lower level permission led to this vulnerability. It seems that it was an
oversight not to disallow file access outside of a plugin's sandbox.
"
320,CVE-2011-1811,chromium,"Having a large number of forms on a webpage would cause the browser to crash.
","The original programmers did not think about the extreme cases of their code.
They didn't put a obvious limit on chrome form autofills. They did for the fix, around 1000.
The fix is common sense and should have been in the code originally,
making the fix pretty trivial and obvious.
"
321,CVE-2011-1812,chromium,"Chrome before 12.0.742.91 allows remote attackers to bypass intended access
restictions through certain extensions. The tabs permissions defined in the
manifest file of Chrome extensions could be bypassed if a webpage was spoofed.
",I think that this vulnerability was introduced because all edge cases weren't thought of. The conversation between developers discussing the vuln shows that the scenario is a very specific issue that exists within permissions of extentions.
323,CVE-2011-1814,chromium,,
324,CVE-2011-1815,chromium,,
325,CVE-2011-1816,chromium,,
455,CVE-2011-3054,chromium,,
456,CVE-2011-3055,chromium,,
327,CVE-2011-1818,chromium,,
328,CVE-2011-1819,chromium,,
329,CVE-2011-2075,chromium,,
330,CVE-2011-2332,chromium,Universal Cross Site Scripting exploit possible when abusing window.execScript.,
331,CVE-2011-2342,chromium,,
333,CVE-2011-2346,chromium,,
334,CVE-2011-2347,chromium,,
335,CVE-2011-2348,chromium,,
336,CVE-2011-2349,chromium,,
337,CVE-2011-2350,chromium,,
338,CVE-2011-2351,chromium,,
340,CVE-2011-2359,chromium,,
341,CVE-2011-2360,chromium,,
343,CVE-2011-2599,chromium,,
344,CVE-2011-2761,chromium,,
345,CVE-2011-2782,chromium,"The drag-and-drop implementation in Google Chrome on Linux does not properly
enforce permissions for files. This allows attackers to create a file link on their 
website (e.x. <a href=""file:///etc/passwd"">) and if the user drags this link onto something
like a file upload, and it will upload the file from the users device.
","This vulnerability was clearly a design flaw as the developers, from the conversation on the bug, clearly did not anticipate drag-and-drop not working properly when a URL linking to a file was dragged in as opposed to the file itself."
347,CVE-2011-2784,chromium,,
457,CVE-2011-3056,chromium,,
458,CVE-2011-3057,chromium,,
459,CVE-2011-3058,chromium,,
350,CVE-2011-2787,chromium,"Failing to lock and unlock the GPU allows for reentrancy issues allowing
remote attackers to execute a denial of service attack, crashing the application
using unspecified vectors.
","This would likely best fit into a design flaw because it was likely an overlooked
edge case of concurrent operation on the GPU. This was likely overlooked by the
code review and QA as a result of a missing vector when looking for potential flaws
"
351,CVE-2011-2788,chromium,,
352,CVE-2011-2789,chromium,,
353,CVE-2011-2790,chromium,,
354,CVE-2011-2791,chromium,,
355,CVE-2011-2792,chromium,,
356,CVE-2011-2793,chromium,,
357,CVE-2011-2794,chromium,,
358,CVE-2011-2795,chromium,,
359,CVE-2011-2796,chromium,,
360,CVE-2011-2797,chromium,,
361,CVE-2011-2798,chromium,,
362,CVE-2011-2799,chromium,,
363,CVE-2011-2800,chromium,,
364,CVE-2011-2801,chromium,,
365,CVE-2011-2802,chromium,,
366,CVE-2011-2803,chromium,,
367,CVE-2011-2804,chromium,,
368,CVE-2011-2805,chromium,,
369,CVE-2011-2806,chromium,,
370,CVE-2011-2818,chromium,,
371,CVE-2011-2819,chromium,,
372,CVE-2011-2821,chromium,"Google was using the libxml2 library for Chrome. The way they were using the
library allowed attackers to cause a double free by entering certain types
of code in a query. A double free can result in memory being changed that
you did not anticipate, which can result in a Denial of Service attack.
Additionally the memory that was freed twice can also cause malloc to get
called on it twice, resulting in a pointer being returned to the same
location in memory for two different malloc calls. This could also allow for
a buffer overflow attack.
","This vulnerability was introduced because of the use of the libxml
library. We all use libraries to make our work easier, but have to
remember that those libraries can introduce as many vulnerabilities
as our own code does.
Looking at the changes to the lxml library this looks to be a coding
mistake where it was assumed some data structures could never be
modified. This turned out to be incorrect.
"
373,CVE-2011-2822,chromium,,
374,CVE-2011-2823,chromium,,
375,CVE-2011-2824,chromium,,
376,CVE-2011-2825,chromium,,
377,CVE-2011-2826,chromium,,
378,CVE-2011-2827,chromium,,
379,CVE-2011-2828,chromium,,
380,CVE-2011-2829,chromium,,
381,CVE-2011-2830,chromium,,
383,CVE-2011-2835,chromium,"The cache has a race condition when being used by the X507 certificate. It was a very difficult problem,
as it would probably need some significant changes to one or more of the already existing APIs in use.
","I believe that the main mistake was improper knowledge of the systems. By using
a raw certificate, it caused race conditions that in the end were easily mitigated.
The use of os specific wrappers around the certificates was not an obvious solution, but
an elegant one. 
"
385,CVE-2011-2837,chromium,"Google Chrome had a Linux specific bug based in compiler options. The compiler
was not configured to use the PIC (Position Independent Code) and PIE
(Position Independent Executable). Since the code wasn't being compiled as 
expected, the attack surface was unpredictable.

The most plausible security attack here could have been related to denial of
service on certain machines due to compilitation related crashes. Because there is
memory positioning involved with the vulnerability, information disclosure could
also be an issue in the case of an overflow.

The chrome team's conversation didn't seem very concerned with the details of
possible attacks here, and the security severity of the bug was low. Security-wise
this seemed like a ""better safe than sorry"" situation.
","This seems to be a vulnerability that was caused by overlooking some of the
finer detail of the compiler configuration. By missing the proper compiler
flags, unpredictable behavior was introduced into the system. The CWE-684 is
simply that Code does not function due to published specifications, which is
a bit vague. The mitigation suggested is also brief: make sure the Code adheres
to the specifications. It appears that the Google team did that once they found
the issue. It's hard to tell if the ultimate cause of the vulnerability was an
outright design mistake or just a coding mistake when creating the configuration
file, but improved communication of the proper settings for specific platforms
would have definitely helped the team.
"
386,CVE-2011-2838,chromium,,
387,CVE-2011-2839,chromium,,
460,CVE-2011-3059,chromium,,
461,CVE-2011-3060,chromium,,
469,CVE-2011-3068,chromium,,
389,CVE-2011-2841,chromium,,
390,CVE-2011-2842,chromium,,
392,CVE-2011-2844,chromium,,
394,CVE-2011-2846,chromium,,
395,CVE-2011-2847,chromium,,
399,CVE-2011-2851,chromium,"Video conversion and transformations were not being properly handled, which
could allow remote attackers to cause a denial of service.

This vulnerability was the result of accessing an array at x-1 when x == 0.
","This was a coding mistake made by overlooking possible bad inputs. When
the main functions of the file were added, the author failed to recognize
that certain inputs could break their code. The fix was implemmented in a
single line which terminated the function if the problem inputs were entered.
"
400,CVE-2011-2852,chromium,,
401,CVE-2011-2853,chromium,,
402,CVE-2011-2854,chromium,,
403,CVE-2011-2855,chromium,,
404,CVE-2011-2856,chromium,,
405,CVE-2011-2857,chromium,,
408,CVE-2011-2860,chromium,,
409,CVE-2011-2861,chromium,,
410,CVE-2011-2862,chromium,,
412,CVE-2011-2874,chromium,,
413,CVE-2011-2875,chromium,,
414,CVE-2011-2876,chromium,,
415,CVE-2011-2877,chromium,,
416,CVE-2011-2878,chromium,,
417,CVE-2011-2879,chromium,,
418,CVE-2011-2880,chromium,,
419,CVE-2011-2881,chromium,,
420,CVE-2011-3015,chromium,,
421,CVE-2011-3016,chromium,,
422,CVE-2011-3017,chromium,,
423,CVE-2011-3018,chromium,,
424,CVE-2011-3019,chromium,,
425,CVE-2011-3020,chromium,,
426,CVE-2011-3021,chromium,,
427,CVE-2011-3022,chromium,"Javascript used by Chrome to translate web pages is downloaded over HTTP. This script is executed in the context of the web page to be translated.
translate/translate_manager.cc in Google Chrome before 17.0.963.56 and 19.x before 19.0.1036.7 uses an HTTP session to exchange data for translation, which allows remote attackers to obtain sensitive information by sniffing the network.","A small coding mistake was made in that a page's url could contain javasript
that could be potentially executed. In general, it is important to sanitize
urls whenever they are being obtained, because regardless of who is providing them,
urls still could contain malicious content.
"
428,CVE-2011-3023,chromium,,
430,CVE-2011-3025,chromium,,
431,CVE-2011-3026,chromium,"When a function is called to expand the size of a PNG (within Google Chrome),
the value associated with the size of the PNG can be as large as requested
(meaning there is no size limitation). The reason it can be so arbitrarily
large is because in the process of inflating a compressed image holds the need
to ""throw away"" chunks of data if (when they are decompressed) have an output
arguement of 0. Due to this vulnerability, malicious users can exploit this
and create a value for the data that when expanded is greater than the type
value (png_size_t) can hold causing an overflow. This obviously leads to
memory allocation issues and heap-buffer-overflow. It is a possible entry
point for malicious attackers to implement a DoS or possibly have unspecified
other impact(s) by tampering with integers via truncation.
",Overlooking input due to face value of the input being an image as opposed to some data that is taken in as strings or characters. It was a fairly complex vulnerability to even catch. but a relatively simple fix.
432,CVE-2011-3027,chromium,,
433,CVE-2011-3031,chromium,,
434,CVE-2011-3032,chromium,,
435,CVE-2011-3033,chromium,,
436,CVE-2011-3034,chromium,,
437,CVE-2011-3035,chromium,,
438,CVE-2011-3036,chromium,,
439,CVE-2011-3037,chromium,,
440,CVE-2011-3038,chromium,,
441,CVE-2011-3039,chromium,,
442,CVE-2011-3040,chromium,,
443,CVE-2011-3041,chromium,,
444,CVE-2011-3042,chromium,,
445,CVE-2011-3043,chromium,,
446,CVE-2011-3044,chromium,,
448,CVE-2011-3046,chromium,,
449,CVE-2011-3047,chromium,,
451,CVE-2011-3050,chromium,,
452,CVE-2011-3051,chromium,,
470,CVE-2011-3069,chromium,,
471,CVE-2011-3070,chromium,,
472,CVE-2011-3071,chromium,,
473,CVE-2011-3072,chromium,,
474,CVE-2011-3073,chromium,,
475,CVE-2011-3074,chromium,,
476,CVE-2011-3075,chromium,,
477,CVE-2011-3076,chromium,,
478,CVE-2011-3077,chromium,,
479,CVE-2011-3078,chromium,,
480,CVE-2011-3079,chromium,"Inter-process Communication implementation does not correctly validate
messages allowing for attack vectors. It is possible to create a fake
listener process that does not have the proper permissions to connect to
a pipe started by the browser's process and cause a privledge escalation.
","The mistake was trusting the pipe of input given to the process. By just
assigning a random id to the process and adding it the system was trusting
it by default. The fix worked by giving it a specific id so that it could
be controlled properly.

It was introduced when child process hosts were refactored through an
interface in content/public rather than inheritance.
"
481,CVE-2011-3080,chromium,,
482,CVE-2011-3081,chromium,,
483,CVE-2011-3083,chromium,"The vulnerability allowed remote attackers to intentionally cause an
application crash by means of a specialized web page.

If an attacker placed an FTP URL in the SRC attribute of an HTML
<video> tag, then a browser crash would inevitably result when a user
visited the web page and loaded the video.

This was caused by a failure to properly create FtpTransaction objects for
media delivered over FTP. The FtpTransaction object handles FTP transactions
between the web page and client. While the majority of non-media content
delivered over FTP used an FtpTransactionFactory object to create
transactions, any media content, like videos, delivered over FTP didn't
use the FtpTransactionFactory, which resulted in a NULL pointer dereference
and a subsequent application crash when used.

While the original reporter only noticed this issue when the FTP URL was
within a <video> tag, the application would have similarly crashed if the user
had placed an FTP URL ending in a media file format (AVI, MP3, etc.) in
Chrome's address bar and hit enter. This was also the case for malformed
FTP URLs with no file extension.
","A simple coding mistake seems to have been the cause of this vulnerability.
Throughout the file, there are many lines of code in which both the main and
media context variables are modified together, one after the other. For example,
the function set_http_transaction_factory was called on both the main and media
context variables. However, it seems that when the developer was writing the
code to call the function set_ftp_transaction_factory, they accidentally forgot
about the media context variable and only set the FTP transaction factory on
the main context variable. This led to no FtpTransaction objects being created
for media over FTP.

This might have been prevented if the developer was more careful when creating
the file, practiced pair programming, or if the code had undergone a more
thorough code review before being released.
"
484,CVE-2011-3084,chromium,,
485,CVE-2011-3085,chromium,,
486,CVE-2011-3086,chromium,,
487,CVE-2011-3087,chromium,,
488,CVE-2011-3088,chromium,,
489,CVE-2011-3089,chromium,,
490,CVE-2011-3090,chromium,,
491,CVE-2011-3091,chromium,,
493,CVE-2011-3093,chromium,,
494,CVE-2011-3094,chromium,"The input validation vulnerability did not properly handle Tibetan text, and thus an
out-of-bounds read could occur during Tibetan handling. If a Tibetan letter was followed
by a Tibetan cantillation sign, a global buffer overflow would be reported.

The vulnerability was located in the method called tibetan_form().

This vulnerability could be exploited by remote attackers, who could execute arbitrary
code on the system and cause a denial of service via the out-of-bounds read through
the use of unspecified vectors. They can accomplish this by persuading a victim to
visit a specially-crafted web site or JavaScript program using Chromium or V8, where
they could exploit the vulnerability to trigger the out-of-bounds read in order to
execute the arbitrary code on the system.
","A mistake that allowed for that out-of-bounds error was that some variable ""c"", which
which represents the Tibetan unicode char hex value that can be used to find the index
with the involvement of some math, was allowed to be either less than or equal to 0x0fc0,
which in turn allowed that out-of-bounds error to occur. It appeared to have been an
oversight in how the boundary cases were addressed and thus limited incorrectly.
"
495,CVE-2011-3095,chromium,,
497,CVE-2011-3097,chromium,,
498,CVE-2011-3098,chromium,,
499,CVE-2011-3099,chromium,,
500,CVE-2011-3100,chromium,,
501,CVE-2011-3101,chromium,,
502,CVE-2011-3102,chromium,,
503,CVE-2011-3103,chromium,,
504,CVE-2011-3104,chromium,,
505,CVE-2011-3105,chromium,,
506,CVE-2011-3106,chromium,,
507,CVE-2011-3107,chromium,,
508,CVE-2011-3108,chromium,,
509,CVE-2011-3109,chromium,,
510,CVE-2011-3110,chromium,,
511,CVE-2011-3111,chromium,,
512,CVE-2011-3112,chromium,,
513,CVE-2011-3113,chromium,,
514,CVE-2011-3114,chromium,,
515,CVE-2011-3115,chromium,,
516,CVE-2011-3234,chromium,,
517,CVE-2011-3389,chromium,,
518,CVE-2011-3640,chromium,,
519,CVE-2011-3873,chromium,,
520,CVE-2011-3875,chromium,,
522,CVE-2011-3877,chromium,,
523,CVE-2011-3878,chromium,,
524,CVE-2011-3879,chromium,,
526,CVE-2011-3881,chromium,,
528,CVE-2011-3883,chromium,,
529,CVE-2011-3884,chromium,"A timing issues in the DOM traversal can cause denial of service attacks and
remote vector issues or possible unknown issuess through a crafted document.

The DOM stands for Document Object Model and is a tree like structure, used to
represent the HTML webpage.

The DOM traversal runs for at most 50ms before pausing to allow the WebkKit 
thread to run. If the frame is removed before the traversal resumes then it
will attempt to access a deleted WebFrame.

The fix is to ensure that the WebDocument is not null.

An interesting note is that these vulnerabilities are in a client side phishing
detection model.
","The developers did not consider all the consequences for adding a time out.
It appears they were attempting to make the process quicker, since they even
reduced the limit one time. 

Managing resources is an important part of security. Since you can not allways be
sure that a resource or object will be available. Check for edge cases and attempt
to prevent the possibility of freed resources being accessed."
530,CVE-2011-3885,chromium,,
531,CVE-2011-3887,chromium,,
532,CVE-2011-3888,chromium,,
533,CVE-2011-3889,chromium,,
534,CVE-2011-3890,chromium,,
535,CVE-2011-3891,chromium,,
536,CVE-2011-3892,chromium,,
537,CVE-2011-3893,chromium,,
538,CVE-2011-3894,chromium,,
539,CVE-2011-3895,chromium,,
540,CVE-2011-3896,chromium,,
541,CVE-2011-3897,chromium,,
543,CVE-2011-3900,chromium,,
544,CVE-2011-3903,chromium,,
545,CVE-2011-3904,chromium,,
546,CVE-2011-3905,chromium,,
547,CVE-2011-3906,chromium,,
548,CVE-2011-3907,chromium,,
549,CVE-2011-3908,chromium,,
550,CVE-2011-3909,chromium,,
551,CVE-2011-3910,chromium,,
552,CVE-2011-3911,chromium,,
553,CVE-2011-3912,chromium,,
554,CVE-2011-3913,chromium,,
555,CVE-2011-3914,chromium,,
556,CVE-2011-3915,chromium,,
557,CVE-2011-3916,chromium,,
558,CVE-2011-3917,chromium,,
559,CVE-2011-3919,chromium,,
560,CVE-2011-3921,chromium,,
561,CVE-2011-3922,chromium,,
562,CVE-2011-3924,chromium,,
564,CVE-2011-3926,chromium,,
565,CVE-2011-3927,chromium,,
566,CVE-2011-3928,chromium,,
567,CVE-2011-3953,chromium,"After a user performed a paste operation, an attacker could use malicious
code on a webpage that could start a loop that would continiuously monitor 
the user's clipboard. This could allow attackers to steal password information 
and other sensitive data from the clipboard
","The primary mistake here was simply an oversight in the implementation of the 
product. None of the developers thought of this attack as a possible issue for 
a few years after it was introduced, and it was therefore not directly mitigated
for quite some time.
The developers did a good job during the design of the product by applying
defense in depth to this area, so that users were at least notified when
something was wrong. They could have possibly gone further than simply
notifying the users, but this was likely a design tradeoff that the
developers knew about going in - allowing sites to remain in infinite
javascript loops in order to prevent a total crash. The mitigation for 
this CWE states that priveleges should be extended only to complete 
the exact task at hand. The fix for this issue does not follow this 
exactly, as access to the clipboard is not terminated directly after 
the paste is complete, it is only terminated if the contents of the 
clipboard are changed. There does not, however, seem to be any direct 
negative security implications to this fix, since the site is still 
restricted to see only the clipboard contents that it already read from 
the paste operation. Still, further thought could be put into this fix 
in order to be sure that the attacker cannot exploit some other method 
of stealing clipboard data using the permissions they are given.
"
568,CVE-2011-3954,chromium,,
569,CVE-2011-3955,chromium,,
571,CVE-2011-3957,chromium,,
572,CVE-2011-3958,chromium,,
576,CVE-2011-3962,chromium,,
577,CVE-2011-3963,chromium,,
579,CVE-2011-3965,chromium,"Google Chrome crashed when the program internally called a function.
This function tries to access data from a NULL variable. This allows remote attackers
to cause a denial of service (application crash).

In general, this is a NULL Pointer Deference problem, that can occur when the
application deferences a pointer expecting it to be a valid, but is NULL.
This causes a program to crash or exit.
","NULL Pointer Dereference is one of the commonly seen vulnerabilities.
It is very important to validate data received from outside the module
before acting upon it. Sanity-checking before using could nearly prevent all
NULL pointer dereference problems. However, it is impossible to sanity-check
all data all the times. Thus, writing some strong unit tests to check such
scenarios whenever possible could go a long way.
"
580,CVE-2011-3966,chromium,,
581,CVE-2011-3967,chromium,,
582,CVE-2011-3968,chromium,,
583,CVE-2011-3969,chromium,,
584,CVE-2011-3970,chromium,,
585,CVE-2011-3971,chromium,,
586,CVE-2011-3972,chromium,,
587,CVE-2011-4691,chromium,,
588,CVE-2011-4692,chromium,,
590,CVE-2012-0724,chromium,,
591,CVE-2012-0725,chromium,,
592,CVE-2012-1521,chromium,,
593,CVE-2012-1845,chromium,,
594,CVE-2012-1846,chromium,,
595,CVE-2012-2764,chromium,,
596,CVE-2012-2807,chromium,,
597,CVE-2012-2815,chromium,,
598,CVE-2012-2816,chromium,,
599,CVE-2012-2817,chromium,,
600,CVE-2012-2818,chromium,,
601,CVE-2012-2819,chromium,,
602,CVE-2012-2820,chromium,,
603,CVE-2012-2821,chromium,,
604,CVE-2012-2822,chromium,,
605,CVE-2012-2823,chromium,,
606,CVE-2012-2824,chromium,,
607,CVE-2012-2825,chromium,,
608,CVE-2012-2826,chromium,,
609,CVE-2012-2827,chromium,,
610,CVE-2012-2828,chromium,,
611,CVE-2012-2829,chromium,,
612,CVE-2012-2830,chromium,,
613,CVE-2012-2831,chromium,,
614,CVE-2012-2832,chromium,,
615,CVE-2012-2833,chromium,,
616,CVE-2012-2834,chromium,,
617,CVE-2012-2842,chromium,,
618,CVE-2012-2843,chromium,,
619,CVE-2012-2844,chromium,,
620,CVE-2012-2846,chromium,,
621,CVE-2012-2847,chromium,,
622,CVE-2012-2848,chromium,,
623,CVE-2012-2849,chromium,,
624,CVE-2012-2850,chromium,,
625,CVE-2012-2851,chromium,,
626,CVE-2012-2852,chromium,,
627,CVE-2012-2853,chromium,,
628,CVE-2012-2854,chromium,,
629,CVE-2012-2855,chromium,,
630,CVE-2012-2856,chromium,,
631,CVE-2012-2857,chromium,,
632,CVE-2012-2858,chromium,,
633,CVE-2012-2859,chromium,,
634,CVE-2012-2860,chromium,,
635,CVE-2012-2862,chromium,,
636,CVE-2012-2863,chromium,,
637,CVE-2012-2865,chromium,,
638,CVE-2012-2866,chromium,,
639,CVE-2012-2867,chromium,,
640,CVE-2012-2868,chromium,,
641,CVE-2012-2869,chromium,,
642,CVE-2012-2870,chromium,,
643,CVE-2012-2871,chromium,,
644,CVE-2012-2872,chromium,,
645,CVE-2012-2874,chromium,,
646,CVE-2012-2875,chromium,,
647,CVE-2012-2876,chromium,,
648,CVE-2012-2877,chromium,,
649,CVE-2012-2878,chromium,,
650,CVE-2012-2879,chromium,,
651,CVE-2012-2880,chromium,,
652,CVE-2012-2881,chromium,,
653,CVE-2012-2882,chromium,,
654,CVE-2012-2883,chromium,,
655,CVE-2012-2884,chromium,,
656,CVE-2012-2885,chromium,,
657,CVE-2012-2886,chromium,,
658,CVE-2012-2887,chromium,,
659,CVE-2012-2888,chromium,,
660,CVE-2012-2889,chromium,,
661,CVE-2012-2890,chromium,,
662,CVE-2012-2891,chromium,,
663,CVE-2012-2892,chromium,,
664,CVE-2012-2893,chromium,,
665,CVE-2012-2894,chromium,,
666,CVE-2012-2895,chromium,,
667,CVE-2012-2896,chromium,,
668,CVE-2012-2897,chromium,,
669,CVE-2012-2898,chromium,,
670,CVE-2012-2899,chromium,,
671,CVE-2012-2900,chromium,,
672,CVE-2012-4903,chromium,,
673,CVE-2012-4904,chromium,,
674,CVE-2012-4905,chromium,,
675,CVE-2012-4906,chromium,,
676,CVE-2012-4907,chromium,,
677,CVE-2012-4908,chromium,,
678,CVE-2012-4909,chromium,,
679,CVE-2012-4929,chromium,,
680,CVE-2012-4930,chromium,,
682,CVE-2012-5109,chromium,,
683,CVE-2012-5110,chromium,,
684,CVE-2012-5111,chromium,,
685,CVE-2012-5112,chromium,,
686,CVE-2012-5115,chromium,,
687,CVE-2012-5116,chromium,,
688,CVE-2012-5117,chromium,,
689,CVE-2012-5118,chromium,,
690,CVE-2012-5119,chromium,,
691,CVE-2012-5120,chromium,,
692,CVE-2012-5121,chromium,,
693,CVE-2012-5122,chromium,,
694,CVE-2012-5123,chromium,,
695,CVE-2012-5124,chromium,,
696,CVE-2012-5125,chromium,,
697,CVE-2012-5126,chromium,,
698,CVE-2012-5127,chromium,,
699,CVE-2012-5128,chromium,,
700,CVE-2012-5130,chromium,,
701,CVE-2012-5131,chromium,,
702,CVE-2012-5132,chromium,,
703,CVE-2012-5133,chromium,,
704,CVE-2012-5134,chromium,,
705,CVE-2012-5135,chromium,,
706,CVE-2012-5136,chromium,,
707,CVE-2012-5137,chromium,,
708,CVE-2012-5138,chromium,,
709,CVE-2012-5139,chromium,,
710,CVE-2012-5140,chromium,,
711,CVE-2012-5141,chromium,,
712,CVE-2012-5142,chromium,,
713,CVE-2012-5143,chromium,,
714,CVE-2012-5144,chromium,,
715,CVE-2012-5145,chromium,,
716,CVE-2012-5146,chromium,,
717,CVE-2012-5147,chromium,,
718,CVE-2012-5148,chromium,,
719,CVE-2012-5149,chromium,Integer overflow in the audio layer of Google Chrome allowed remote attackers to cause a denial of service or possibly have other unspecified impacts via unknown vectors.,
720,CVE-2012-5150,chromium,,
721,CVE-2012-5151,chromium,,
723,CVE-2012-5153,chromium,,
724,CVE-2012-5154,chromium,"An Integer overflow in a web browser could allow attackers to
cause a denial of service attack. It could also allow for other impacts through ""vectors""
related to the allocation of shared memory.
","If the requirements for the use of this buffer were laid out completely, the programmer may have known to check its
size upon the Implementation phase.

This programmer, however, could possibly have just forgotten to check the buffer size, which is a coding mistake.
"
726,CVE-2012-5156,chromium,,
727,CVE-2012-5157,chromium,,
728,CVE-2012-5376,chromium,,
729,CVE-2012-5851,chromium,,
730,CVE-2013-0828,chromium,,
731,CVE-2013-0829,chromium,,
732,CVE-2013-0830,chromium,,
733,CVE-2013-0831,chromium,"Path traversal vulnerability that allows remote attackers to
have an unspecified impact by leveraging access to an extension process.
","In my opinion, it was a coding mistake. The author of the code did not
account for '/.' in file names. So when '/.' was present, the code
returned the unintended filepath.
"
734,CVE-2013-0832,chromium,,
735,CVE-2013-0833,chromium,,
736,CVE-2013-0834,chromium,,
737,CVE-2013-0835,chromium,,
738,CVE-2013-0836,chromium,,
739,CVE-2013-0837,chromium,,
740,CVE-2013-0838,chromium,,
741,CVE-2013-0839,chromium,,
742,CVE-2013-0840,chromium,,
744,CVE-2013-0842,chromium,,
746,CVE-2013-0879,chromium,,
747,CVE-2013-0880,chromium,,
749,CVE-2013-0882,chromium,,
750,CVE-2013-0883,chromium,,
752,CVE-2013-0885,chromium,,
753,CVE-2013-0886,chromium,,
755,CVE-2013-0888,chromium,,
756,CVE-2013-0889,chromium,"Chromium browsers do not properly check that users performed a gesture
required before downloading a file. This made it possible for remote hackers
to run arbitrary code from a crafted file.
","This was a simple mistake where it looks like the developer missed input
validation. The fix was just to add one more check to the input to make
sure that the request to download was one that came from the user and not
remote hackers.
"
757,CVE-2013-0890,chromium,,
759,CVE-2013-0892,chromium,,
760,CVE-2013-0893,chromium,,
761,CVE-2013-0894,chromium,,
762,CVE-2013-0895,chromium,"Google Chrome on Linux and Mac OS X does not properly handle file paths for 
copy operations in the CopyDirectory method. The copy operation does not
properly strip trailing separators when creating its target path, which makes
it possible for a remote attacker to execute arbitrary code through path 
traversal.
","The primary culprit of this vulnerability was the copy/paste styled
implementation of file paths in the first iteration of the CopyDirectory 
method for posix operating systems. There was no input checking on the 
path, it was assumed that no malicious file path would be used. 

It is interesting that there was a gap of about 4 years from the first 
implementation of the CopyDirectory method with the vulnerability to when
the vulnerability was fixed. All the while there were a series of edits
made to the problematic lines of code by Google employees. One of which
addressed that there may be a problem with the path implementation (leading
'/' characters) but it only scratched the surface of the greater problem.

The fix ended up utilized a generic AppendRelativePath function that could
be utilized in all operating systems and worked to both sanitize and validate
the file path inputs before constructing the file path for the CopyDirectory
function.
"
763,CVE-2013-0896,chromium,,
764,CVE-2013-0897,chromium,,
765,CVE-2013-0898,chromium,,
766,CVE-2013-0899,chromium,,
767,CVE-2013-0900,chromium,,
768,CVE-2013-0902,chromium,,
769,CVE-2013-0903,chromium,,
770,CVE-2013-0904,chromium,,
771,CVE-2013-0905,chromium,,
772,CVE-2013-0906,chromium,,
774,CVE-2013-0908,chromium,,
775,CVE-2013-0909,chromium,,
776,CVE-2013-0910,chromium,"Google Chrome previously did not properly manage browser interactions between browsers and
renderers. The issue occurs when plug-ins are loaded or validated/authorized. 
Attackers can use it to bypass access restrictions with blocked plug-ins due to 
the exposed rendering process. The renderer is what loads the plug-ins in the browser, and is
exposed enough to theoretically be compromised. If a renderer is compromised, there are no 
longer any restricitions on the type of plug-ins that are loaded, and an attacker could use this
to load in a nefarious plug-in.

This vulnerability was not a found bug, but more of a security oversight. Someone discovered
a potential vulnerability that could be corrected before it was ever an issue in practice.
","All in all, I don't think that there were that many mistakes that were made that
were avoidable. Someone with more experience with Java and plug-ins noticed a section
of code that could be improved, and google responded accordingly. If any mistakes were
made, it would be in the design phase. It also might be able to be considered a Maintainability
issue, because as technologies evolved, they did not stay upgrade this feature accordingly.

As far as the mitigations go, the only one mentioned on the cwe page is to use an authentication
framework and library. However, this is not entirely relevant because we are not concerned with
user authentication, but authentication of a renderer. This is a more unique problem than one that 
can be solved with a default library. 

The fix looks like a pretty good solution for a problem that is not very common.
"
777,CVE-2013-0911,chromium,,
778,CVE-2013-0912,chromium,,
779,CVE-2013-0916,chromium,,
780,CVE-2013-0917,chromium,,
781,CVE-2013-0918,chromium,,
782,CVE-2013-0919,chromium,,
783,CVE-2013-0920,chromium,,
784,CVE-2013-0921,chromium,,
785,CVE-2013-0922,chromium,,
786,CVE-2013-0923,chromium,,
787,CVE-2013-0924,chromium,,
788,CVE-2013-0925,chromium,"There is a missing check to see if an extension has permission to a tab before
allowing it access to the tab's URL. This has potential to leak the user's
visited tabs to an attacker.
","After searching through this CVE for a long time, I was unable to find the
exact vulnerability. I know it has somewthing to do with not checking for
extension permissions when updating tabs. This could be somewhere in the
following files:
  /chrome/browser/extensions/browser_event_router.cc
  /chrome/browser/extensions/extension_tab_util.cc
Potentially in the TabUpdated or ExtensionActionExecuted functions of
browser_event_router.cc, or the CreateTabValue function in
extension_tab_util.cc.
"
789,CVE-2013-0926,chromium,,
790,CVE-2013-2268,chromium,,
791,CVE-2013-2493,chromium,,
792,CVE-2013-2566,chromium,,
793,CVE-2013-2632,chromium,,
794,CVE-2013-2836,chromium,,
796,CVE-2013-2838,chromium,,
798,CVE-2013-2840,chromium,,
799,CVE-2013-2841,chromium,,
801,CVE-2013-2843,chromium,,
893,CVE-2013-6642,chromium,,
804,CVE-2013-2846,chromium,,
805,CVE-2013-2847,chromium,,
806,CVE-2013-2848,chromium,,
807,CVE-2013-2849,chromium,,
808,CVE-2013-2853,chromium,,
809,CVE-2013-2854,chromium,,
810,CVE-2013-2855,chromium,"The vulnerability was in Google Chrome's Developer Tools API where in Chrome's
inspector, which lets the user view HTML of the page, there was a way for a user
to set up a setter and get access to a object called InjectedScriptHost.

The implementation, which was done in C++, had a class with methods that had
elevated privileges from the common user which could be accessed.  This could
result in a crash at best and an integrity violation at worse.

The way this could be exploited would be if an attacker found out about this
vulnerability and used it to purposely crash the site.  This could prevent
other people from accessing the site, also known as denial of service.
","The vulnerability was an oversight where the programmer intended for
the class to only be used be the inspector itself, but did not think about
the consequences if the user was able to access that object.  Also,
Javascript code was not sanitized against in the console, which made this
vulnerability possible.

Surprisingly, the fix was simply to not use the methods for the object with
elevated privileges unless it was specifically for the inspector.  They did
not get to the root of the problem where the console let the user set up a
setter in Javascript, which made the object vulnerable in the first place.
I believe that sanitizing the console input could improve this fix.
"
811,CVE-2013-2856,chromium,,
812,CVE-2013-2857,chromium,,
814,CVE-2013-2859,chromium,,
815,CVE-2013-2860,chromium,,
816,CVE-2013-2861,chromium,"Part of Chromium's image rendering system allows attackers to cause a memory
reference to already freed memory. This could cause memory corruption and
crashes allowing an attacker to make resources unavailable.
","The mistake appears to be a coding mistake. The original author failed to
check that the view had not already been freed before using.

In the fix process, there appeared to be a lot of miscommunication regarding
how to reproduce the issue and what its impact was. Quite late into the fix
there was still confusion as to how the vulnerability actually impacted the
system.
"
817,CVE-2013-2862,chromium,,
818,CVE-2013-2863,chromium,,
819,CVE-2013-2864,chromium,,
820,CVE-2013-2865,chromium,,
821,CVE-2013-2866,chromium,,
822,CVE-2013-2867,chromium,,
823,CVE-2013-2868,chromium,,
824,CVE-2013-2869,chromium,,
825,CVE-2013-2870,chromium,,
826,CVE-2013-2871,chromium,,
827,CVE-2013-2872,chromium,,
828,CVE-2013-2873,chromium,"When loading the error 404 page, there was a vulnerability in WebKit in which
an object called the WebURLLoader was used after being deleted.  The WebURLLoader was 
originally released because it received an inter-process communication that the page had 
finished loading.  The subresources of the 404 page had transitioned into the finished state, 
but may have signaled an error that resulted in a message from a nested message loop.  
Because the subresource was already finished and the WebURLLoader had been freed, a use-after-free 
crash occurred when the subresource attempted to proccess the body received from the nested message loop.
","The fix for this vulnerability was simple enough (adding a protective pointer),
but the main mistake was the developers' failure to reinstate the reverted test that
would have caught this vulnerability months earlier.  It's unclear why the test was reverted
and never reexamined, but because the comments on the thread for the reverting commit stop after
a few days, it's likely that the team because busy with more pressing matters and simply forgot about
the test since the fix itself for that bug had landed fine.  This was a process mistake, possibly due to
miscommunication or the emergence of higher-priority bugs.
"
829,CVE-2013-2874,chromium,,
831,CVE-2013-2876,chromium,,
832,CVE-2013-2877,chromium,,
833,CVE-2013-2878,chromium,Lack of bounds protections and input sanitization allows for remote attacks to cause denial of service attacks.,
835,CVE-2013-2880,chromium,,
836,CVE-2013-2881,chromium,,
837,CVE-2013-2882,chromium,,
838,CVE-2013-2883,chromium,,
839,CVE-2013-2884,chromium,,
840,CVE-2013-2885,chromium,,
841,CVE-2013-2886,chromium,,
842,CVE-2013-2887,chromium,,
843,CVE-2013-2900,chromium,"Windows version does not properly handle components of the path name containing
just a . (dot) and white space characters. Remote hackers can utilize this to do
a directory traversal by a crafted directory name.
","The main take away for this CVE is that more investigations need to be done when changing security. In this case an additional secuirty check was put in place in a handfull of different files solved the vulnerability. I would argue that there is a lack of organization of path traversal mitigations which may have caused this issue to be overlooked. I believe that this vulnerability was caused by a lack of proper design. In this case, many different files had logic for handling file paths securely and some cases were missed. By having sanitation logic split up in many different files it makes it harder to track what is being sanitized properly and what isn't."
844,CVE-2013-2901,chromium,,
845,CVE-2013-2902,chromium,,
846,CVE-2013-2903,chromium,,
847,CVE-2013-2904,chromium,Use-after-free vulnerability in Google Chrome before 29.0.1547.57 allows remote attackers to cause a denial of service attack,
848,CVE-2013-2905,chromium,,
849,CVE-2013-2906,chromium,,
850,CVE-2013-2907,chromium,,
851,CVE-2013-2908,chromium,,
852,CVE-2013-2909,chromium,,
853,CVE-2013-2910,chromium,,
854,CVE-2013-2911,chromium,,
855,CVE-2013-2912,chromium,,
856,CVE-2013-2913,chromium,,
858,CVE-2013-2915,chromium,,
859,CVE-2013-2916,chromium,"Blink, as used in Google Chrome before 30.0.1599.66, allows remote attackers to spoof the address bar via vectors involving a response with a 204 (aka No Content) status code, in conjunction with a delay in notifying the user of an attempted spoof.",
860,CVE-2013-2917,chromium,,
861,CVE-2013-2918,chromium,,
862,CVE-2013-2919,chromium,,
863,CVE-2013-2920,chromium,,
864,CVE-2013-2921,chromium,,
865,CVE-2013-2922,chromium,,
866,CVE-2013-2923,chromium,,
867,CVE-2013-2924,chromium,,
868,CVE-2013-2925,chromium,,
870,CVE-2013-2927,chromium,,
871,CVE-2013-2928,chromium,,
872,CVE-2013-2931,chromium,,
873,CVE-2013-6166,chromium,,
874,CVE-2013-6621,chromium,,
876,CVE-2013-6623,chromium,,
924,CVE-2014-1705,chromium,,
879,CVE-2013-6626,chromium,,
883,CVE-2013-6631,chromium,,
884,CVE-2013-6632,chromium,,
887,CVE-2013-6636,chromium,"Versions of Google Chrome before 31.0.1650.63 made an incorrect check for  an
empty document during presentation of a modal dialog, which allows remote
attackers to spoof the address bar via vectors involving the  document.write
method. These vectors involved calling document.write on a  window opened by
window.open and then Chrome not correctly setting the URL  in the OmniBox (the
navigation and search bar). Because of this error, malicious websites could
create windows with spoofed URLs in the OmniBox, leading users to believe their
information was being given to a trusted destination or even securely
transmitted when it was not.
","The mistakes that were made where coding mistakes. The author didn't think 
of every situation where the code could be exploited and more specficly,
didn't realize the effects of unnecessary environment checks. The bugfix for
this specfic issue involved removing a single line that limited the 
functionality of notifyIfInitialDocumentAccessed() to only operate when
m_stateMachine.isDisplayingInitialEmptyDocument() returned a truthy value.
This allowed for a vulnerability where the URL in the OmniBox was not
properly updated when the document.write() function was used. Hence, allowing
users to spoof any address in the OmniBox, the perfect setup for phishing 
schemes.
"
888,CVE-2013-6637,chromium,,
889,CVE-2013-6638,chromium,,
890,CVE-2013-6639,chromium,,
891,CVE-2013-6640,chromium,,
892,CVE-2013-6641,chromium,,
895,CVE-2013-6644,chromium,,
896,CVE-2013-6645,chromium,"A vulnerability where a pointer was being used after it was already freed, called a ""use-after-free"" vulnerability.

This vulnerability can allow attackers to cause a ""denial of service"" attack, where some set of users would no longer be able to use the browser. The sequence of activities that could cause an exploit involves specific actions related to a speech input element of the Chrome browser.
","A coding mistake led to this vulnerability. It seems a developer was implementing a quick fix for a different bug and did not realize that they were introducing a use-after-free vulnerability in doing so.

The fix to the mistake does look proper. The issue was created because the developer was properly handling a parent object, but not properly handling the pointers to the children of that parent. The fix involved iterating through the child objects and handling them properly as well.
"
899,CVE-2013-6650,chromium,,
900,CVE-2013-6652,chromium,,
902,CVE-2013-6654,chromium,,
903,CVE-2013-6655,chromium,"This vulnerability is when a heap that had previously been freed, would attempt to get accessed by scripts that were running as pages were being loaded.","With my limited knowlege in the area, it sounds like this was really more of a design mistake. It sounds like the scripts being run IN layout devs thought NEEDED to be there, in order to maintain performance; however, these same scripts were causing bugs and security risks because the place where they were actually being executed. Had more testing and research been done ahead of time when designing, these bugs would never have happened. In the end the devs ended up changing when certain events were fired as a fix to these bugs and risks."
904,CVE-2013-6656,chromium,"The vulnerability was in WebKit's XSS Auditor which is a built-in function designed 
to mitigate XSS attacks. It identifies if query parameters contain malicious 
JavaScript and block the response if it believes the payloads were injected into a response.

XSS Auditor, when processing a POST request with a chain of page redirects and a single 
final destination page, initializes with the URL of the destination page and the body of
the initial request page. This means that the body of the request page is still accessible 
thru the XSS Auditor by brute-forcing character by character the POST body of the initial request.
However, this will only occur if the original request url has a <script> tag in it, to make 
XSS Auditor suspicious and initialize.

By pairing this exploit with a login form, an attacker can get the body of the form
with the user inputs in the values and gain access to passwords and other sensitive 
information.
","I honestly think that this vulnerability came to be because of a typo. 

The solution was a one-liner (worth $500) that changed 
""FormData* httpBody = documentLoader->originalRequest().httpBody();"" to
""FormData* httpBody = documentLoader->request().httpBody();""

Notice that the only difference is which request function is being used;
each gives the XSS Auditor access to certain http bodies. After a form fill and a login attempt,
the request http body doesn't contain any of the user's input while the original 
request body does.

The vulnerability went long undiscovered mostly because of its security by obscurity
due to the specificity of its prerequesites and inputs. 

Since this vulnerability was introduced entirely as new code along with a larger featueset,
I think that the original developer just mistyped and chose the wrong request function
while not thinking about the consequences of choosing one or the other. They both 
are syntactically similar after all.
"
1400,CVE-2017-5030,chromium,"Memory corruption in V8.
",
909,CVE-2013-6661,chromium,,
911,CVE-2013-6664,chromium,,
913,CVE-2013-6666,chromium,"The PepperFlashRendererHost::OnNavigate function does not verify nor sanitize
headers, which can cause a Cross-Site Request Forgery by allowing remote
attackers to bypass the verification standards. Attackers can get around the
intended Cross-Origin Resource Sharing restrictions by using a custom and
unexpected header in the request.
","This vulnerability was most likely caused by an Archetectural Design mistake. The content within the headers of a POST request should always be verified as well as sanitized to prevent and mitigate CSRF, which did not seem to be done in this scenario."
914,CVE-2013-6667,chromium,,
915,CVE-2013-6668,chromium,,
916,CVE-2013-6802,chromium,,
917,CVE-2014-1568,chromium,An attacker could spoof an RSA signature via the Bleichenbacher's Low-Exponent Attack on the TLS handshake and certificate signature forgery. This is due to the fact that the Network Security Services had a small Abstract Syntax Notation One for decoding.,"The main mistake was trusting the ASN.1 which had a Bleichenbacher's Low-Exponent Attack. This is a problem not only this project had but was cross multiple applications. There is only one solution is creating every component, however this is not realisitc. So the best solution is testing all aspects of the library you are using and staying up to date with what information the creator of the library is releasing."
918,CVE-2014-1681,chromium,,
920,CVE-2014-1701,chromium,"The Cross-Site Scripting (XSS) vulnerability was located in the GenerateFunction 
function in the path bindings/scripts/code_generator_v8.pm in Blink. It existed 
because the aforementioned function didn't implement a specific cross-origin 
restriction for the EventTarget::dispatchEvent function.

The ""events"" processing component wasn't able to properly filter user input from 
the HTML code before displaying the input.

A way this vulnerability can be exploited is that a remote attacker can trigger
Universal XSS (UXSS) attacks via vectors involving events, and can essentially 
force the execution of arbitrary scripting code by the target user's browser within 
the context of a different domain. Such as how it affected iframes, as it permitted 
a page on an arbitrary site to retrieve the document element of any target page so 
long as the following conditions concerning the target page were met - 
(1) it may be imbedded in an iframe, (2) it has a handler for any window event,
(3) it gets or sets any property of the event in any jQuery listener, and
(4) it returns a dom node from the handler.
","The mistake seemed to stem from a lack of proper security checks in place. As stated
previously in the description above, The ""events"" processing component wasn't able 
to properly filter user input from the HTML code before displaying the input.
"
921,CVE-2014-1702,chromium,"This vulnerability is of the free after use nature. When a task is running on a thread,
and that task ends the thread is being shutdown. This vulnerability could allow an
attacker to creat an denial of service. They leverage the improper handling of how
these threads are terminated.
","This appears to be a code mistake. There was only one line of code in one file
that caused this vulnerability. This leads me to belive that this was simple a
function that a programmer overlooked. They use the mitigation of setting pointers
to null once they are freed. This prevents attackers from gaining accesss through
improper termination of a terminating thread in the clean up process.
"
923,CVE-2014-1704,chromium,,
928,CVE-2014-1716,chromium,,
929,CVE-2014-1717,chromium,,
930,CVE-2014-1718,chromium,"An integer overflow was possible when finding the area of a frame during a swap.
This could happen when the height or width of the frame was set to a large 
enough value as the formula multiplies these values by 4 but does not check
the size of the resulting integer. Thiss could allow a web application to potentially
escape its own memory space by allocating a large amount of renderer memory and overwriting 
or controling the memory space of other applications running within chrome. (Sandbox escape) 
It also allows a denial of service attack by forcing crashes.
by 
",This issue seems to have come from a coding mistake. It appears that the variables leading up to the section of code were properly checked to avoid an integer overflow but the calculation done on the variables was not considered.
931,CVE-2014-1719,chromium,"A vulnerability was found that allowed for already used memory to be used again in the Web workers API implementation. The
vulnerability allowed remote attackers to cause attacks that could bring down the system as well
as possibly have inputs that trigger a termination of shared web workers during script loading.
","The mistake came from a coding flaw and caused what would be a denial of service
attack as well as other potential errors. This could have been avoided by knowing
where the function should have properly been placed. Moving the position of one 
of the lines of code is what made the fix. 
There may have been a potential for the vulnerability to have been fixed during 
the design phase of the module. During the code review is when it seemed like the 
discussion was sparked regarding the correct placement of this line. If the discussion
was brought up during implementation or if the implications of the placement of the 
line of code were known it could have been mitigated. 
"
932,CVE-2014-1720,chromium,,
933,CVE-2014-1721,chromium,,
934,CVE-2014-1722,chromium,,
936,CVE-2014-1724,chromium,,
937,CVE-2014-1725,chromium,,
938,CVE-2014-1726,chromium,"The file drag-and-drop feature could be exploited by a user 
performing the drag-and-drop action with a file containing malicious code. 
This would allow the attacker to bypass the Same Origin Policy and forge 
local pathnames. HTML files that were loaded from file:// URLs were able 
to read other local files because Chromium would automatically grant the 
target of the drop action read acess to the file. 
","This vulnerability seems to be caused by design mistakes. There are some incorrect uses of 
methods in addition to a number of missing handlers. The fix seems to address the issues related to 
matching CWE entry. 
"
939,CVE-2014-1727,chromium,"A vulnerability in the web color chooser UI. The object is removed in the wrong
class allowing an attacker to access freed memory. This can cause denial of 
service attacks, or possible other attacks on unknown vectors related to forms. 
","This vulnerability is related to resource management. We should take into 
account when each paticular object may be deleted and ensure that it is
ok to be deleted at that time.

This is something very hard to protect against. There are many different times
an object can be deleted and figuring out all posible interactions can be tough.

Its best to limit the possiblities of object iteractions and ensure that it only
does what it needs to do and when. It was an easy fix for a bug that could have
had big implications since it's a use-after-free vulnerability. "
940,CVE-2014-1728,chromium,,
941,CVE-2014-1729,chromium,,
942,CVE-2014-1730,chromium,,
943,CVE-2014-1731,chromium,,
944,CVE-2014-1732,chromium,"The original design of the Speech Recognition Bubble view in Google Chrome had
a fault where a slower computer could delete the view of web page before the
other critical items could be deleted first causing a denial of service to occur.
","The coding mistake was a design mistake where an speech file could be attempted
to be played yet caused a denial of service under the right conditions. This being
a legacy issue, specifically slow, older Window XP, showed that the mistake was
a design error of ensuring the order of closing tasks took priority.

The fix looks proper, as it implements a correct design pattern for the job, however
since there weren't any unit tests to push the limits of the code, only the physical
test could be re-created to see if the issue had been resolved for that specific
situation, opposed to trying to solve for future issues at hand.
"
961,CVE-2014-3155,chromium,"The implementation of the network transfer protocol queue's 'write' function
doesn't check for re-entrancy (being called again after being interrupted).
Shrinking the queue while this happens results in an out-of-bounds read which
remote attackers could use to cause a denial of service.
","This seems like a basic coding mistake where the developer didn't consider how
iterating mutable data requires careful thought in an environment where it is prone
to change.
"
962,CVE-2014-3156,chromium,"Inside of the clipboard implementation there was a buffer overflow vulnerability. When trying to copy certain things to clipboard, the renderer cliboard would return something with NULL pixels causing this overflow.",From the solution I am seeing it seems to just be a simple coding mistake. The developer just allocates and does arithmatic with values that are never checked so this problem arose quickly.
946,CVE-2014-1734,chromium,,
947,CVE-2014-1735,chromium,,
948,CVE-2014-1736,chromium,,
949,CVE-2014-1740,chromium,"This vulnerability was an example of trying to use memory after it has been discarded.
It could lead to a crash of Chrome thus giving a denial of service attack and potentially
others issues. The exploit affected ninety-three versions of Chrome. After being
discovered, Google's AddressSanitizer was able to find the issue and detect the leak.
While this vulnerability was fixed, the tests were never added due to other code they
depended on not ready to be merged in.
","This error was found because of the lack of testing. This test case itself 
seemed to be a fairly obscure case that I can easily see the team missing.
The evidence for this being an obscure edge case is further supported by the 
code remaining unchanged for 4 years. The area was indeed unit 
tested so it was not for lack of testing per say that this was not found. 
A cursory internet search does not lead me to find the script the reporter used and 
it is likely they created the script themselves or was looking for this specific case 
and then made the script afterwards to confirm it.
"
951,CVE-2014-1742,chromium,,
952,CVE-2014-1743,chromium,"Attackers could cause an application crash by exploiting a use-after-free
vulnerabilty in Blink. Use-after-free is a vulnerabilty where the use of
previously freed memory creates unexpected behavior.
","The code for where this vulnerability exists seemed to be changing
as multiple began pushing their commits. The use of  the""free"" operation in the code seemed to be
introduced by miscommunication where one user removed a check and another user
added a feature without said check.
"
955,CVE-2014-1746,chromium,"A function relies on an integer data type that is not large enough. This
vulnerability allows for attackers to cause a denial of service by using vectors
with a buffer larger than the integer data type mentioned above, this leads to
an out-of-bounds error.
","This bug was caused by developers not realizing that changing the data type to
int would not allow for the variable to be sufficiently large. This error would
would be classified as a coding mistake. When making any changes, developers
should take time to contemplate why things were the way they
were. Unless the developer is intimately knowledgeable about the source code,
it's a good idea to consult colleagues about potential changes.
"
958,CVE-2014-1749,chromium,,
959,CVE-2014-3152,chromium,,
1047,CVE-2015-1213,chromium,,
1048,CVE-2015-1214,chromium,,
965,CVE-2014-3160,chromium,,
967,CVE-2014-3162,chromium,,
968,CVE-2014-3165,chromium,,
970,CVE-2014-3167,chromium,,
971,CVE-2014-3168,chromium,,
973,CVE-2014-3170,chromium,,
974,CVE-2014-3171,chromium,,
975,CVE-2014-3172,chromium,"The Debugger Extension API does not validate the tab's URL, allowing an attacker to get root access and bypass all
Chrome security.
","It appears that this vulnerability was a case where accessing the tab's permissions may have been overlooked. 
Although there were very particular steps invovled in reproducing the vulnerability, the exploit would have been a huge disaster. 
The attacker would have been able to wiretap the user's microphone, disable touchpad, DoS, steal private keys, etc. 
So although the steps to reproduce the exploit requires expert knowledge, the exploit would have caused distrust with Chrome.
"
977,CVE-2014-3174,chromium,,
978,CVE-2014-3175,chromium,,
979,CVE-2014-3176,chromium,,
980,CVE-2014-3177,chromium,,
981,CVE-2014-3178,chromium,,
982,CVE-2014-3179,chromium,,
983,CVE-2014-3187,chromium,,
984,CVE-2014-3188,chromium,,
1049,CVE-2015-1215,chromium,,
988,CVE-2014-3192,chromium,,
989,CVE-2014-3193,chromium,,
990,CVE-2014-3194,chromium,,
991,CVE-2014-3195,chromium,,
993,CVE-2014-3197,chromium,,
994,CVE-2014-3198,chromium,When scrolling using the arrow keys the subsystem PDFium does a check for the first visible page.  In the case where there is not yet a visible page this check will return -1.  There was no check for this scenario which caused an attempt to index by -1 resulting in a buffer overflow. The app would then crash causing a denial of service. The buffer overflow also exposes the app to potential data corruption or malicious code execution.,"The vulnerability was caused by simply overlooking the case where there is no visible page and -1 is returned, which causes the logic to try and index by -1.  Once the fuzzer found the issue it was a very simple fix.
Interestingly this case of returning -1 when there is no visible page was checked for further down in the file. In the entire file they checked for the first visible page 3 times.  The first 2 occasions they did not check to see if -1 was returned, but the third time they did. Due to the fact the the VCC added a lot of functionality this leads me to beleive that they did not thouroughly check the commit and only happened to consider this edge case in the third scenario.  Because there was no unit testing they did not notice this simple mistake until the fuzzer found it and then they were able to add in the checks for -1."
995,CVE-2014-3199,chromium,,
996,CVE-2014-3200,chromium,,
999,CVE-2014-7899,chromium,,
1000,CVE-2014-7900,chromium,,
1001,CVE-2014-7901,chromium,,
1002,CVE-2014-7902,chromium,,
1003,CVE-2014-7903,chromium,,
1004,CVE-2014-7904,chromium,,
1005,CVE-2014-7905,chromium,,
1006,CVE-2014-7906,chromium,,
1007,CVE-2014-7907,chromium,,
1008,CVE-2014-7908,chromium,"Integer overflow for multiple media file types. This overflow vulnerability
allows attackers to cause a denial of serivce. Any Mov/QuickTime/MPEG4 Container
had a defect that could cause performance degradation and potentially be used to
as a vector for denial of service attacks.
","The biggest mistake that lead to this vulnerability was focusing efforts on higher
priority bugs that existed within the same file. This was a coding bug as there was
an initial check for integer overflow, however it was not robust enough to cover
all cases. The working solution for this bug is using Input Validation. This is done
by ensuring that the input is within expected bounds of what should be expected. This fix
looks proper as it changes the following two lines
  int atomsize = Read32(buffer + offset); --> uint32 atomsize = Read32(buffer + offset);
  if (atomsize <= 0) --> if (atomsize == 0 || atomsize > static_cast<size_t>(buffer_size))
These fixes show that it uses checks to see if the input is within the proper bounds, as
well as paying close attention to variable types in calculations for a given language.
"
1009,CVE-2014-7909,chromium,,
1010,CVE-2014-7910,chromium,,
1401,CVE-2017-5031,chromium,"Use after free in ANGLE.
",
1013,CVE-2014-7925,chromium,"Chrome tab crashes because audio nodes in the Blink WebAudio component are being destroyed/disposed by the garbage collector. This is caused by racing in the AudioContext thread and the Garbage Collector thread. It means that as an Audio node is traversing it's graph,there's mutation with the Garbage collector which causes Chrome to crash and the tab to close.","In my opinion, this was a design issue. The way threads are handled which allow data and processes that are being used by chrome are also being cleared out by the Garbage collector process."
1014,CVE-2014-7926,chromium,"The Regular Expressions package has an issue with handling empty responses or
""zero-length quantifiers"" allowing remote attackers to cause a denial of service 
(memory corruption), as well as other possible unforseen impacts.
","A coding mistake that can be identified here is not tracking your process, 
especially when various operations are happening at once. In this case a 
check was not put in place to ensure that the variables were in the correct
state prior to operation. This caused some information to be lost and peculiar
things started to happen because of it."
1015,CVE-2014-7927,chromium,,
1016,CVE-2014-7928,chromium,,
1018,CVE-2014-7930,chromium,"The vulnerability was in Blink, Google Chrome's browser engine, in a DOM 
implementation of a tree data structure written in C. 

A DOM model represents a document with a logical tree. Each branch of the 
tree ends in a node, and each node contains objects. DOM methods allow 
programmatic access to the tree. 

The cause of this vulnerability was that it was possible for a variable called 
TreeScope, which represents a DOM object root node, to be deleted while it was
still in use in another context. 

This created a use-after-free vulnerability. Use After Free refers to the 
attempt to access memory after it has been freed, which can cause a program to crash
in the best case, or can potentially result in the execution of 
arbitrary code or even enable full remote code execution capabilities.

Furthermore, crafted JavaScript code could trigger improper maintenance of TreeScope data through this vulnerability.
","The user who committed the VCC introduced this vulnerability in his own code. 
However, since the concern is that different event contexts require the TreeScope at 
different times, it can be argued that this is a Design mistake first and foremost. 
Pointers to the root node of a DOM object should be null after the root has been deleted.
In this case the mitigation solution was to store a backup to the rootNode of
the tree. Developers should have taken into account for the tight coupling between these
two contexts, and the possiblity that actions in one scope would have catastrophic effects 
on another. This is more of a band-aid fix that doesn't fully adress the fact that the 
scope of these variable should not be so tightly coupled. 
"
1019,CVE-2014-7931,chromium,,
1021,CVE-2014-7933,chromium,,
1026,CVE-2014-7938,chromium,,
1028,CVE-2014-7940,chromium,,
1030,CVE-2014-7942,chromium,,
1031,CVE-2014-7943,chromium,,
1032,CVE-2014-7944,chromium,,
1033,CVE-2014-7945,chromium,,
1035,CVE-2014-7947,chromium,,
1037,CVE-2014-7967,chromium,,
1038,CVE-2014-9646,chromium,,
1039,CVE-2014-9647,chromium,,
1040,CVE-2014-9648,chromium,,
1042,CVE-2015-1205,chromium,,
1044,CVE-2015-1210,chromium,"When an exception is thrown in the DOM, the exception object is
created by inheriting from the object the method is called on, even if it comes
from a different origin. The created object does not conduct any checks on
whether it is supposed to be allowed access to said origin, exposing them to
potential attackers.
","This was a case in code, as this was a small hole that was easily
remedied without any serious structural overhaul. The fixer ended up creating
a fix on what is essentially the ""server-side"" in this scenario (this is a
browser vulnerability so not exactly the same typical scenario), by modifying
the ThrowException class in order to apply the fix in other potential exploit
scenarios
"
1046,CVE-2015-1212,chromium,,
1053,CVE-2015-1219,chromium,,
1056,CVE-2015-1222,chromium,"A use after free vulnerability was present, as there was no check against null or other unexpected input, causing the program to
delete space in memory, and then try to delete the same space again. This left the door open to denial of service errors or other 
impacts when an attacker would enter a null value into the object, or other unexpected input. 
","I believe that a coding mistake caused this vulnerability. I think that if the programmer
would have validated the input and put the checks in place, the vulnerability never would 
have come up. 

I think the fix that was put into place is a good mitigation. The problem was that if the context
was null, the system would try to delete and start over the null space in memory and it
was causing use after free problems, resulting in denial of service. By implementing a null check, 
it makes sure it isn't freeing up / trying to delete null space. You should check if the memory
address is not null before you try to free / delete it.
"
1057,CVE-2015-1223,chromium,,
1059,CVE-2015-1225,chromium,,
1060,CVE-2015-1226,chromium,,
1063,CVE-2015-1229,chromium,Cookie-injection attacks via crafted response could occur when a 407 error was raised,"This was caused by a design mistake, security was not throughly thought out when this issue was created curiously the user didnt remember to close the ticket and it took a while for the fix to be listed"
1064,CVE-2015-1230,chromium,,
1065,CVE-2015-1231,chromium,,
1066,CVE-2015-1232,chromium,,
1067,CVE-2015-1233,chromium,,
1069,CVE-2015-1235,chromium,,
1070,CVE-2015-1236,chromium,"The process function in the Web Audio API function is allowing attackers to access sensitive audio sample values through an offline
website containing an offline media element 
","There seemed to have been a coding/maintainability mistake that could have been mitigated. The vulnerability is a difficult one to discover because it would have required extensive testing of all components of the system. This is impractical because it would require a lot of resources and you don't know what exactly you're looking for. 
One thing that could have been looked into was that since the audio object was handling sensitive data, the subsystem that handles this object should have been a focus on unit testing. It should be common practice to evauluate areas where assets are being accessed. This vulnerability is a perfect example. The other mistake was trusting the API to be secure. The Web Audio API was responsible for hosting this vulnerability, so it would have been the Google's responsibility to evaluate the API implementation that involved handling sensitive data.
"
1071,CVE-2015-1237,chromium,"Google Chrome was susceptible to a use-after-free vulnerability, where a 
pointer is used after it has been freed. Accessing a pointer after it has been
freed can cause unintended behavior like: program crash, unexpected runtime 
values, and change in program execution. An attacker could exploit the 
vulnerability, through a specially crafted website, cause renderer crashes or 
arbitrary code executions.. 
","This vulnerability is resultant of a coding mistake. This vulnerability 
only required a two SLOC change, which is indicative that this vulnerability 
was sourced from an oversight of the author. The fix only required following 
the MITRE recommended mitigation, which is to set the pointer to null after 
freeing. 
"
1072,CVE-2015-1238,chromium,,
1073,CVE-2015-1240,chromium,"There was a vulnerability which allowed remote attackers to cause a denial of
service (out-of-bounds read) via a crafted WebGL program that triggers a state
inconsistency. In other words, any attacker writing a WebGL program who is
aware of this bug may force an integer out-of-bounds read which may halt or
break the WebGL operation.
","The largest mistakes that led to this vulnerability were all problems with
validating parameters before and after executing functions in WebGL programs.
This was a case of improper restriction of operations within the bounds of a
memory buffer. This, overall, was simply an oversight by a developer who did
not consider this at first, and the issue was left unknown until a hacker
discovered the issue. In the end, when they put in validation measures in
order to avoid out-of-bounds errors, the case was considered solved and I do
believe that this solution has held up over time and has not been an issue
since this.
"
1074,CVE-2015-1241,chromium,"On mobile, click events were able to fire outside of the scope that they were created in. This can be exploited through the use of tapjacking. Tapjacking is the concept that an attacker can listen for taps with a screen overlay, and can sniff any data that is being passed to an underlying application. This can even include credit card data or passwords. In the case of this specific vulnerability, the trigger page will redirect to the victim page (under ideal circumstances), and events can be fired across domain boundaries. This would give attackers access to input single clicks to perform simple tasks. Like buying something, or posting something. Anythig with a single button.
","This seems most like a requirements mistake. The commit that introduced the vulnerability seemed to have introduced it carelessly without knowing the consequences of what they changed. Proper requirements could have cleared up the misunderstanding. It could have been a miscommunication. It's puzzling why it was introduced. It seems like it was just changed for seemingly no reason, just to be changed back once it caused an issue. It'd be interesting to know what was going through the original developers heads. Maybe there is something more to the story here. Requirements that could have been added to prevent this could be something as verbose as Taps must execute only where they belong, and must not go outside of their scope. This could have helped eliminate this issue, as it doesn't make sense for Taps to travel between subsystems and to separate web pages."
1075,CVE-2015-1242,chromium,,
1076,CVE-2015-1243,chromium,"When Google first wrote it's DOM implementation the ""use-after-free""
vulnerability was intoduced. They iterated over a copy of a structure in
an Observer class and never checked the conditions of the original before
attempting to use it based on the copy. This caused the tab being used to
crash.
This could allow for a Denial of Service attack or other unspecified impact
because a remote attacker can trigger this by trying to force the freeing
of a non registered observer.
This also becomes a data integrity issue as the memory that was freed
may have been allocated again somewhere else, causing corruption of that
data.
","The coding mistake was made when this code was first created. This code was
not modifed again until this bug was found. The time between the bug being
found, the cause of the bug and the possible fix was very short (less then a
day).
This was a simple mistake where the coders assumed that the object they
made a copy of couldn't be changed and would remain identical to their
copy.
This mistake was mostly a coding mistake. The coders made an assumption
about the state of their object, and that assumption ended up being
incorrect, which resulted in this vulnerability.
The reviewers likely looked over this code and thought along the same lines
as the code author. There were not any unit tests to check for this part of
the code behavior, they were added after the defensive check was put into
place as no one anticipated this would be an issue.
"
1077,CVE-2015-1244,chromium,,
1078,CVE-2015-1245,chromium,"Use-after-free vulnerability in the OpenPDFInReaderView::Update function in 
browser/ui/views/location_bar/open_pdf_in_reader_view.cc in Google Chrome 
before 41.0.2272.76 might allow user-assisted remote attackers to cause a 
denial of service (heap memory corruption) or possibly have unspecified other 
impact by triggering interaction with a PDFium ""Open PDF in Reader"" button that 
has an invalid tab association. 

This can allow a malicious web site to cause a user to be redirected to a different
page when opening a link on the original page with the ""Open PDF in Reader"" button.
This can cause a user's information to be stolen.
",
1079,CVE-2015-1246,chromium,,
1080,CVE-2015-1247,chromium,Chrome allowed a file to be in the URL descriptor OpenSearch XML document.,"File urls were forgotten when they added the check for valid urls, this appears to be a good fix as it is whitelisting a few urls allowed"
1081,CVE-2015-1248,chromium,,
1082,CVE-2015-1249,chromium,,
1083,CVE-2015-1250,chromium,,
1084,CVE-2015-1251,chromium,"A Use-after-free vulnerability in the Speech subsystem allows remote attackers 
to execute arbitrary code via a crafted document. The use-after-free vulnerability
occurs when a pointer is freed and then accessed again, thereby allowing arbitrary
code execution. No one was able to craft an exploit for this vulnerability but the 
error can be replicated by initializing a speech recognition object, closing the 
window with window.close() and then calling the speech recognition object again, 
causing the browser to access freed memory.
The main issue was caused when the system removed a managed pointer method with
automatic garbage collection and failed to set the pointer to null after it was freed.
","The major mistake made was in removing a pointer management system and not
replacing it with an appropriate solution. The problem was that the document
no longer existed in some cases and the speechRecognition object used the
document after it was freed. The solution seems to be to check if the document
is still the context, this is not the recommended solution. The CWE says to
set the document to nil after it has been freed, this would make the check not
needed. An important lesson was to consider all pointers owned by a parent
element when removing the parent.
"
1118,CVE-2015-1285,chromium,"By brute forcing XSS injections, secret values contained in scripts on a site can be guessed. This is because the XSS filter will trigger only when the value is guessed correctly. The site must then provide an x-xss-protection mode=block header so that the attacker knows what was blocked and what was not.","From my rudimentary understanding of this, it seems as if there should not be a notification for when something triggers the XSS filter. Additionally, the developers have allowed this issue to sit around for years without really addressing the source of the problem. In the long run, this will probably cost more time and resources than just addressing how the core issue with the XSS filter."
1119,CVE-2015-1286,chromium,,
1087,CVE-2015-1254,chromium,,
1088,CVE-2015-1255,chromium,"In Chromium, Blink, a rendering engine, is used with almost a one to one 
relationship with each browser tab instance. It takes on the responsibility 
of rendering most of the content in a browser tab. In the 
case of this vulenrability, Blink was trying to use a particular 
object instance to stop playback of music content in the browser tab process after that instance 
was destroyed. This Use-after-free vulnerability in the WebAudio implementation 
of Chromium allowed remote attackers to cause a denial of service 
or possibly have other unspecified impacts.

The fix adds to the empty an destructor to call newly introduced function 
which removes the instance of particular pointer from the Blink renderer engine instance so that 
it is not used later on by Blink. Even though initially in the VCC the destructor 
is empty, in C++ at time of destruction it will still destroy member variables 
of the class which is what caused our use-after-free issue being addressed here.
","This appears to be an mistake with the design approach.
Since the instance of WebAudioCapturerSource could have a shorter
life then Blink it should have been considered
what things need to be done at time of destruction. In the case of the fix,
adding to the destructor in WebAudioCapturerSource to remove its pointer
to itself from Blink was the solution.    
"
1090,CVE-2015-1257,chromium,"The graphics module used by the Chromium engine contained a bug in the FEColorMatrix.cpp file that was caused by the lack of a check for the amount of values in a matrix passed to the createColorFilter method. Specifically, if this method was passed a empty vector object it would cause a crash. This bug was proven to at least cause a denial of service and also had the potential to have a worse impact through a crafted document.",What ultimately led to this bug were assumptions made in the design stages. If the developers had put less trust in the surrounding code they could have avoided this vulnerability all together.
1092,CVE-2015-1259,chromium,,
1094,CVE-2015-1261,chromium,,
1096,CVE-2015-1263,chromium,,
1097,CVE-2015-1264,chromium,,
1098,CVE-2015-1265,chromium,,
1100,CVE-2015-1267,chromium,"Scripts can pass any objects to the API as the chief context, meaning cross-origin scripting is possible. Therefore, information from one system can be passed into another and be considered as another system.   
","The mistake was chiefly in the design/architecture domain, as developers failed to recognized that context needed to be validated. The mitigation was in accordance to the CWE recommendations, which involved obtaining the origin of the request (by passing in the global instance). An additional mitigation could have been whitelisting trusted applications using manifest.xml; however, it is not Chrome's intention to limit others applications as there are plenty of plug-ins and APIs. It is necessary to assume risk in order to reach the broader audience.  "
1103,CVE-2015-1270,chromium,"The function ucnv_io_getConverterName in the file ucnv_io.cpp doesn't parse
strings beginning with ""x-"" correctly, leading to potential DOS attacks.
","The development team didn't consider if inputs beginning with certain 
combinations of characters could cause problems. Better validation of
inputs would have prevented this from becomming an issue.
"
1104,CVE-2015-1271,chromium,"PDFium's out of memory conditions are not properly handled. This allows remote attackers to cause a denial of service or other potential attacks from a heap-based buffer overflow. This results in heap buffer overflow from a large memory allocation of a crafted PDF document.
","The main factors that lead to the vulnerability were miscommunication and coding mistakes. I think it is clear looking through the comments that there was no clear task force on solving this error and many notes were inserted on the progress. This was clear by the mutliple comments back and forth on the Issue, trying to solve the bug.  Multiple months after the Issue was discovered and a solution was solved people agreed the orginal idea in the first comment would work.  The devloper on this had to be commented on to fix it, causing the bug to be open for months.  It had also exceeded the 60-day deadline for fixing a high severity security vulnerability that Google developers follow for Chromium.  There was also just a coding mistake in not checking for the alloc first."
1106,CVE-2015-1273,chromium,"This vulnerability is caused by incorrect data on an image file, which creates a heap-buffer overflow. A heap buffer overflow is different than a regular buffer
overflow in that heaps dynamically allocate memory for usage, and the memory contains program data. When the overflow occurs, program critical data is corrupted by 
being overwritten; pointers are generally the victim of this. This causes instability, and denial of service by crashing services. 

The subsystem is one called OpenJPG, whose purpose is to interpret and render images. Specifically here, it was for images within a PDF file, used by PDFium. 
PDFium is the Chromium tool for interpreting PDFs. The data read by OpenJPG for interpreting the image was not what the subsystem expected, so when it received improper input, it resulted in a heap buffer overflow.  

The solution was to upgrade to r3002 of OpenJPEG, which based on intuition and reasoning, added checks for the data to ensure it did not run over. 
","As this CVE is similar to CVE-2016-1645, which I also curated, I found it interesting that one problem could require two different solutions
in two different, but similar, areas. 

The biggest mistake that lead to this vulnerability was not properly validating inputs, and allowing invalid data to not be dynamically allocated 
a larger buffer size to prevent heap-buffer overflows. 

They failed to use unit testing at any phase of early development, except for seeming to add a large unit testing file that included some checks for
this vulnerability. There may have been some more in-between, but I was not able to look.

It seems to be a failure on multiple fronts. The original developer for not writing proper test cases, future developers for not writing them or verifying
that the method worked as intended, and looking for ways it could be broken, and the company for not having a proper code review to catch this before it 
could be exploited. 
"
1108,CVE-2015-1275,chromium,,
1109,CVE-2015-1276,chromium,Use-after-free vulnerability in the IndexedDB implementation in Google Chrome allowed remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging an abort action before a certain write operation.,
1110,CVE-2015-1277,chromium,"Remote attackers can cause a denial of service, because some data aren't
checked for validity. If an attacker has a user open a specially crafted
page, the memory resources on the user's computer could be exhausted. A
data tree gets serialized, and nodes aren't checked for validity as they
are serialized.
",The code was developed in such a way that tree nodes could point to freed memory
1111,CVE-2015-1278,chromium,,
1113,CVE-2015-1280,chromium,,
1115,CVE-2015-1282,chromium,"In Chromium, PDF's are handled by an open sourced library called PDFium. PDFium
was developed along with Chromium, however the library remained closed source until 2014.
This vulnerability was discovered in 2015.

Adobe (the creators of the PDF standards) includes a Javascript API that can allow
PDF's to embed and execute JavaScript code in order to enhance a PDF's functionality. For ex,
PDF's that include buttons are typically written with Javascript code. 

This vulnerability allows a ""crafted"" PDF (term taken from Chromium bug report) that 
contains specific Javascript code to crash the browser. Javascript code can cause
the delay() and doFieldDelay() functions in Document.cpp to call free() twice. This vulnerability 
is caused by javascript causing the PDFium (PDF) engine to enter a method, multiple times by 
causing document level and field level JavaScript to interact using the field.delay property.
This would free a previously freed pointer. This results in a denial of service attack, 
since Chromium defaults to crashing if it detects a use-after-free bug. 
","The mistake was a design mistake and a coding mistake. One thing the developers did well was
that they followed the fail securely principal. Freeing a pointer twice could cause undeterministic
outcomes - as a result it is best to terminate when such an error occurs. However, most people
do not consider a vulnerability fix or good coding practice to also something that can be exploited
for malicious purposes. That was the case in this scenario. Knowing a foolproof mechanism to
crash the browser lead to malicious PDF's that could simply invoke that failsafe over and over - 
writing a PDF that forced the browser to free a pointer twice, intentionally crashing it.

One potential solution that could be considered is to forbid Javascript in PDF's entirely - JS
in PDF's is an enormous security risk by itself that there should be debate whether or not the benefit
of having a Javascript API is worth the security headaches. A mitigation is to restrict the JS API 
in Acrobat API to prevent attacks as much as possible. The difficulty in this approach is the need
to maintain security while not reducing the API so much that it is no longer useful to users.
"
1116,CVE-2015-1283,chromium,,
1121,CVE-2015-1288,chromium,,
1122,CVE-2015-1289,chromium,,
1123,CVE-2015-1291,chromium,,
1124,CVE-2015-1292,chromium,"Blink, the rendering engine of Google Chrome since 2013, had a defect where an internal navigation function had no verification on the origin of a request.
This allowed a malicious attacker to perform arbitary cross site scripting if they were able to call this function.","The coding mistake made here was being too excited in implementing a new feature
and not checking that the entities using the feature are who they say they are.

This was a design mistake mostly. The code written in this library does (and did)
what it is intended to do. The designers of the subsystem did not think about the
case of untrusted users accessing the worker and so never thought to check.

The principle of defense in depth applies here mostly. Since service workers
are a heavily integrated component of modern web browsers, any malicious user
could have injected arbitary code into browsers if they were able to somehow
invoke a service worker in the wrong context.
"
1126,CVE-2015-1294,chromium,,
1129,CVE-2015-1297,chromium,"The WebRequest API did not properly consider a request's source before
accepting the request. This allows the bypassing of access restrictions.
","Introduced in a bug fix 3 years prior. In fixing a similar bug with permissions,
this bug was introduced.
"
1130,CVE-2015-1298,chromium,,
1132,CVE-2015-1300,chromium,"A bug in Blink, Chrome's rendering engine, allowed malicious actors to read cross domain URLs from a browser after a redirect through an iFrame","This vulnerability actually was present on all browsers at the time (Firefox, IE, Chrome) and was demo'd/exploited on this website http://vwzq.net/lab/xreadurl/.  Given this, it's safe to assume that this vulnerability was the result of an assumption that all browser developers made and was a design flaw"
1133,CVE-2015-1301,chromium,,
1134,CVE-2015-1302,chromium,"A vulnerability existed in Google Chrome where a web page could read PDF
content from any other web page. This is an XSS vulnerability.
","The mistake that lead to this vulnerability is likely a design mistake.
The team either didn't consider that external PDF files could be loaded,
or didn't consider it a problem if they were. The fix looks proper, in that
after the fix external PDF files from outside the origin can no longer be
loaded and executed. 
"
1135,CVE-2015-1303,chromium,,
1136,CVE-2015-1304,chromium,,
1137,CVE-2015-1346,chromium,,
1138,CVE-2015-1359,chromium,,
1139,CVE-2015-1360,chromium,,
1162,CVE-2015-6762,chromium,"This vulnerability is an example of a circumvention of the Same-origin 
implementation on Google Chrome. This vulnerability occurred in the manner 
Google Chrome handled Cascading Style Sheets (CSS); more specifically, it 
occurred in the code that fetched the fonts resource for a web page. The 
omission of the use of the Cross-origin Resource Sharing (CORS) algorithm, 
allows an attacker to bypass the single origin policy through JavaScript 
that requests a font through a redirect. The Google Chrome panel did believe
that this vulnerability did not bypassed anything other than DRM. 
","The defect that caused this vulnerability is primarily from a coding mistake. 
According to the bug reports and commit messages, it is evident that CORs 
handling of remote fonts are a requirement. Additionally, the fix did not 
require a significant rework of the code, therefore it was not a significant 
oversight in the system architecture. The original author just had a 
misunderstanding how to effectively implement CORS. 
"
1163,CVE-2015-6763,chromium,,
1164,CVE-2015-6764,chromium,,
1141,CVE-2015-2238,chromium,,
1142,CVE-2015-2239,chromium,,
1143,CVE-2015-2808,chromium,,
1144,CVE-2015-3333,chromium,,
1146,CVE-2015-3335,chromium,,
1148,CVE-2015-3910,chromium,,
1149,CVE-2015-4000,chromium,,
1150,CVE-2015-5605,chromium,,
1151,CVE-2015-6580,chromium,,
1152,CVE-2015-6581,chromium,,
1153,CVE-2015-6582,chromium,,
1155,CVE-2015-6755,chromium,"This issue is found in chromium reported on august 11 2015 found by Mariusz
Mlynski.

From /WebKit/Source/core/dom/ContainerNode.cpp:

parserRemoveChild| can run script, and it can remove |nextChild| from DOM or
move the node around. When this happens, the tree will be in an inconsistent
state after the |insertBeforeCommon| call, allowing an attacker to bypass the
frame restrictions.

Attackers can exploit this issue to execute arbitrary code, bypass certain
security restrictions and perform unauthorized actions and to gain access to
sensitive information that may aid in further attacks.
","It really just boils down to improper testing on this one. This was an edge
case that the original author did not check for. The original user
who wrote the code didn't check the parent of the nextChildNode, and simply
didn't see the potential vulnerability there. All that took to fix it was a
simple check, and if failed, a return statement.
The issue was a really severe security risk, and could have been used to
perform attacks on users by executing arbitrary code and gain access to private
information. These seem like dire consequences for a missed check, but it doesn't
take much for an attacker to gain access to a system.
After making the fix, it maintains the integrity of the DOM tree, as the insertion
of the newChild node is aborded, and the addition of the return statement rectifies
the ability for an attacker to exploit the vulnerability in this edge case.
"
1156,CVE-2015-6756,chromium,,
1157,CVE-2015-6757,chromium,"Trying to access data in ServiceWorker after it has been freed, creating a Denial of Service Vulnerability. In C, data is freed once it's use is complete to save memory and allow the unused data to be picked up by the garbage collector. Once a data struct or pointer has been freed, you are no longer able to acces that block of data, creating a seg fault and crashing the system in many cases. Also, by freeing the data before its use is complete, the system is denied the service of, or unable to access, the ServiceWorker.  The ServiceWorker was freed too early its callback function thus creating this use-after-free vulnerability.","The mistake made here was a basic C coding mistake, which was freeing up data and then trying to access that freed data that no longer exists.
As far as the mitigation for using data aftering freeing goes, The fix looks proper, as data is now freed after it is done being used."
1158,CVE-2015-6758,chromium,,
1159,CVE-2015-6759,chromium,"The origin of a LocalStorage resource in Google Chrome is not verified to be unique allowing remote attackers to obtain sensitive information via vectors involving a blob: URL
","Unit testing did not properly cover all possible cases allowing for an incorrent validator to be used
"
1160,CVE-2015-6760,chromium,,
1161,CVE-2015-6761,chromium,"A function in FFMPEG, used by Google Chrome before 46.0.2490.71 relies on a coefficient-partition count during multi-threaded operation, allowing for a denial of service or an unspecified impact via a crafted WebM file
","The main issue arose from an issue in FFMPEG resulting in a race condition that caused FFMPEG to terminate. The fix involved updating the version of FFMPEG being used as well as updating dependency tests to ensure that the issue doesn't repeat. This issue is a coding mistake in FFMPEG that results in a race condition. This bug is not directly inside Chrome
"
1199,CVE-2016-1612,chromium,,
1169,CVE-2015-6769,chromium,"The code that triggers unloading a window allows remote attackers to bypass 
the Same Origin Policy (aka SOP) by using the delay in window proxy clearing.
","It was a coding mistake, there was an extra line of code that ran the
script that gave an attacker time to execute an attack.
"
1170,CVE-2015-6770,chromium,,
1171,CVE-2015-6771,chromium,,
1173,CVE-2015-6773,chromium,,
1176,CVE-2015-6776,chromium,,
1177,CVE-2015-6777,chromium,"In versions of Google Chrome before 47.0.2526.73 there was a vulnerabilty that
would cause the application to crash due to memory that was referenced after
being freed by the application. This problem could have been leveraged to cause
denial of service attacks or other unspecified results.
This vulnerability was apart of the ContainerNode portion of the core WebKit 
code. More specifically, it was triggered when a container node was inserted by
the ContainerNode::notifyNodeInsertedInternal function without checking if the 
node was in the shadow tree.
","This error was definitely a very simple coding mistake. The original commit 
that introduced this error was meant to optimize node insertion by not 
notifying leaf nodes when inserting a node into a detached tree. There was
a lack of foresight in not checking if the node in question that was
in the shadow tree. Because of this, references to freed memory were made.
"
1178,CVE-2015-6778,chromium,"This is a heap-overflow bug in Chromium's PDF reader. There is an image format called JBIG2 (similar to JPEG)
and PDFs can store internal JBIG2 images. Specially crafted JBIG2 images would cause the image decoder to
write to uninitialized memory.
","The primary fix for this issue was listed as using C++ std::vector instead of doing manual memory management
which is listed as a common mitigation strategy. I believe this issue was caused by a subtle mistake that anyone
could have made, just a simple coding mistake.
"
1402,CVE-2017-5032,chromium,"Out of bounds write in PDFium. Chrome Browser is vulnerable to Out of Bound
Write/Invalid Pointer Write vulnerability due to improper pointer arithmetic
while parsing malformed PDF file due incorrect validation - could be used to
gain Remote Code Execution.
",
1184,CVE-2015-6785,chromium,"Hostnames formatted as x.y were accepted as valid for *.x.y pattern, enabling
users to bypass access restrictions.
","Faulty code and test cases resulted in the vulnerability. Test cases were
expected the opposite behavior of what should have occured, and allowed the
vulnerability to exist for 4 years before being found. The fix to code as well
as the unit tests appears to be sufficient and correct.
"
1186,CVE-2015-6787,chromium,,
1190,CVE-2015-6791,chromium,,
1191,CVE-2015-6792,chromium,"There was a race condition that was not checked for. The MIDI subsystem in 
Google Chrome before 47.0.2526.106 does not properly handle the sending of 
data, which allows remote attackers to execute arbitrary code or cause a 
denial of service (application crash) via unspecified vectors, related to 
midi_manager.cc, midi_manager_alsa.cc, and midi_manager_mac.cc, a different 
vulnerability than CVE-2015-8664.
",
1192,CVE-2015-7834,chromium,,
1193,CVE-2015-8478,chromium,,
1194,CVE-2015-8479,chromium,"This vulnerability exists in the handling of an audio output device. The 
device's ability to communicate with other processes is supposed to be 
disabled when the device is unauthorized. However the communication is 
never actually closed so the unauthorized device remains registered. This 
means that an attacker can cause a denial of service by corrupting memory 
outside the bounds of execution. The bug description describes it as a 
heap-use-after-free. 
","After researching this vulnerability it appears that this is a case of someone going
back and fixing a mistake in their code. The IPC stream is not closed when an audio 
output device is unauthorized. The fix is only one line so it seems like this could
be called a coding mistake if the programmer simply forgot to write that line or deleted
it by accident. However, it could also be considered a design mistake if the programmer
had no plan to include that safety precaution in the first place and only noticed 
the potential security risk later. With the stream not properly closed it would have
been possible for an attacker to corrupt heap memory, causing the potential for a denial
of service attack. However closing the stream once an audio output device is no longer 
authorized fixes this issue. 
"
1196,CVE-2015-8548,chromium,,
1197,CVE-2015-8664,chromium,,
1198,CVE-2015-8960,chromium,,
1200,CVE-2016-1613,chromium,"Referencing memory after it has been freed can lead to a variety of behaviors including crashing, corrupting data. 
In this specific CVE, due to the improper handling and tracking of 2 objects, after the destruction
of these objects from memory, they are accessed. These cause use after free vulnerabilities found 
that allow remote attackers to cause a denial of service ( Availability attack ) as well as the potential 
for other unspecified impact.
","It was an implementation / design mistake. Since they are working with memory management, 
they should have when writing this code to begin with handle the proper accessing of these
objects they create that are destroyed. This isn't the first CVE I've seen from them that they've
done this. This makes me wonder if Use After Free vulnerabilities aren't that commonly thought of
while coding or if they just didn't plan for it in their security procedures. 
"
1201,CVE-2016-1614,chromium,,
1202,CVE-2016-1615,chromium,,
1203,CVE-2016-1616,chromium,"There was a vulnerability where an attacker could spoof a URL using an unfocused
button in the UI via an accelerator, or keyboard shortcut. An unfocused button is a
button that does not currently have the focus of the web browser. Only one button
can be focused at a time and hitting enter essentially clicks the currently focused
button. A button can become focused after it is clicked or if it is selected through
pressing tab. The issue is that when unfocused buttons are allowed to interact with
accelerators, or keyboard shortcuts, a malicious actor could force a user to navigate
to an arbitrary website.
","This bug is the result of a mistake during planning given that a test case that
could have caught the issue was never considered until a vulnerability was discovered.
The lesson to be taken from this is that determining obscure edge cases can
help determine potentially dangerous vulnerabilities. Oversights are inevitable,
so bounty programs a good way to get as many eyes on your code as possible. If
this vulnerability wasn't reported by a community member, it could have languished
in the source code for years to come.
"
1204,CVE-2016-1617,chromium,"A feature of a Webkit tool implemented in Blink has a function called ""
 CSPSource::schemeMatches"" has an issue where http policies (regarding
 security of the site) aren't applied to https (secure http's) as well as
 Web Services or Web Service Security policies to the https. This lowers the
 level of difficulty for remote attackers to learn whether the specific
 header files (HSTS) website has been visited (in terms of the CSP report).
 While this isn't a terribly dangerous vulnerability, it is still a detail
 to be accounted for to prevent malicious attackers from exploiting user
 information.
",N/A
1207,CVE-2016-1620,chromium,,
1210,CVE-2016-1624,chromium,"A heap-based buffer overflow was discovered in Brotli open source compression
library. Although the vulnerability is categorized as a heap-based
buffer overflow, it is caused by an integer overflow within a function
from Brotli’s library, allowing remote attackers to cause a denial of service.
Google Chrome uses this compression library, and the buffer can be overwritten
and allocated in memory with the use of malloc.
","This vulnerability was caused by a third party library, therefore Google was
not responsible for it even though they review the third party software used
internally. As potential mitigation, bound checking should be performed for
buffers, and apply some defense in depth for prevention.
"
1212,CVE-2016-1626,chromium,,
1213,CVE-2016-1627,chromium,,
1214,CVE-2016-1628,chromium,"This is a vulnerability that existed when handling JPEG2000 images.
If properly crafted, a JPEG2000 image could be embedded inside a PDF to force
Chrome to read memory past the end of an allocated object.  This would allow an
attacker to execute arbitrary code.  JPEG2000 image
format improves compression performance and image quality.  The lack of this
JPEG format being widely used contributed to the implementation of this
vulnernability.
","There was definitely a coding mistake that allowed the execution
of arbitrary code to be run that wasn't intended.  While I can't see it,
Oliver Chang mentions in a code review that he doesn't agree with the
png_gt function because an overflow might be able to happen, he let's it slide
because it's only used once there.  Based on that comment that leads me to believe
the fix was not properly implemented on the pdfium side because if that function
gets used again without proper checks, this could lead to more overflow errors.
Maintainability was also a problem that became apparent in the build fail commits.
"
1215,CVE-2016-1629,chromium,,
1219,CVE-2016-1633,chromium,"This is a typical use-after-free. A pointer is pointing to a location in the heap. That location is then free'd with a call to free() or delete() and then that memory location can no longer be considered valid. Any pointer that attempts to read this memory address back MAY get a correct response, but the memory allocator is free to put whatever it wants back in this location. This is usually not possible in other programming languages, specifically those that use Garbage collection.","When looking at what was changed in order to fix the CVE, there are just two lines that are deleted and then checks performed to do the same actions that were performed in the line before.
It happens often, but if the mistake is actually as simple as these commits make it out to be then it's a case of checking a pointer's datatype, and verifying that the pointer is valid before performing an action that relies on that pointer's integrity.
In this project's C/C++ guidelines, there should be reference to bounds checking and pointer checking before any pointer operations are performed. Tests can be written to make sure that pointers have their data checked before being operations that could result in errors are performed. Stricter code review by team members should also be able to catch potential problems like this in the future."
1221,CVE-2016-1635,chromium,"In Chrome extensions there was a vulnerability that was discovered by a project
committer. The vulnerability allowed malcious extensions to use memory that
was previously freed, by closing or writing to the page and then uing a function
that referenced the previous pointer.

This flaw is normally created during the architechture and implementation phases
when the developer fails to consider all of the paths associated with a pointer.
The reviewer who discovered the bug also provided a patch to fix it.
","The creation of this vulnerability appears to be due to oversight by the
initial developer and failure to be caught during the course of the code
review."
1223,CVE-2016-1637,chromium,,
1225,CVE-2016-1639,chromium,"Based on the report of CVE-2016-1639, there is a Use after Free vulnerability in the WebRTC Audio Private API implementation in Google Chrome.

Use after Free is a memory problem where the memory is referenced after it is freed. Developers usually face this problem in many application where
they have to allocate memory and the previoused memory was freeed. It may cause the program to crash or use unexpected value to perform a certain action. 

The Use after Free vulnerability is dicovered in the file webrtc_audio_private_api.cc with the path browser/extensions/api/webrtc_audio_private/webrtc_audio_private_api.cc
in the WebRTC API. The vulnerability may cause denial of service or unexpect result by dependent on resource context pointer. 
","The Use after Free is a simple oversight issue when the system has to deal with pointer. However, it seem like the vulnerability is ignore in commit 
f9583f83523a0ad7c2c97300dfe303066bcb1ec0. The system attempted to retrieval the media device ID salt even after resourceContext is no longer available. 
The design may not work well to lead to this vulnerability. It is important to have a solid design of how to handle memory allocation and free it afterward. "
1239,CVE-2016-1653,chromium,,
1240,CVE-2016-1654,chromium,,
1435,CVE-2017-5070,chromium,"Type confusion in V8. This problem is related to the crankshaft JIT.
",
1436,CVE-2017-5071,chromium,"Out of bounds read in V8.
",
1228,CVE-2016-1642,chromium,,
1230,CVE-2016-1644,chromium,"In the Blink Layouter, heap memory was used after being freed. This could result in arbitrary code execution or data corruption.
","The mistake that was made ended up resulting from misunderstanding of how the code should work in the particular case. At one point, a variable was supposed to be false, however code was removed that verified this. This miscommunication in requirements was later clarified while fixing this vulnerability.
"
1232,CVE-2016-1646,chromium,,
1235,CVE-2016-1649,chromium,,
1236,CVE-2016-1650,chromium,,
1264,CVE-2016-1678,chromium,,
1464,CVE-2017-5100,chromium,"Use after free in Chrome Apps.
",
1241,CVE-2016-1655,chromium,"Before 50.0.2661.75, a denial of service / use-after-free vulnerability exists 
in Google Chrome where a crafted extension can be used to create an infinite 
amount of new hidden windows that each have an observer tied to it that is
not deleted on frame removal
","This was mainly a design mistake with a slight requirements mistake.
The design mistake was using observables that were not able to be cancelled.
It was never explicitlly stated, however I believe if the ability to easily
cancel them was available, a developer would have had the thought to protect
against this vulnerability. This is a requirements mistake because it was 
not specifically stated to test against this. However, this requirements 
mistake is within reason, beacuse this exploit was extremely well crafted 
and required many layers of exploitation. It is not reasonable to plan for 
this exact vulnerability beforehand. I believe this fix is a correct balance
between how invasive it is, and how well thought designed it is.
"
1244,CVE-2016-1658,chromium,,
1245,CVE-2016-1659,chromium,,
1246,CVE-2016-1660,chromium,"There was a problem in the library where attackers could cause a DoS attack 
where an input would cause an overflow error and crash the service. The function
would try to assert that the index specified is actually within the bounds of the array.
However, before the fix, the assert that would throw an error if the index was out of range
would only throw an error in debug mode. The fix caused the error to be thrown in debug or
production mode.
","I believe that the only real vulnerability that led to this mistake on the chromium side is the
fact that they trusted an outside source library to be secure, even though the outside library
was well established. I believe that the chromium team should've looked through the source before
just adding it to their project. However, with the size of the WebKit repo, I know that it is likely
impossible to look over everything.
"
1248,CVE-2016-1662,chromium,,
1249,CVE-2016-1663,chromium,,
1250,CVE-2016-1664,chromium,,
1251,CVE-2016-1665,chromium,,
1252,CVE-2016-1666,chromium,,
1255,CVE-2016-1669,chromium,,
1256,CVE-2016-1670,chromium,,
1258,CVE-2016-1672,chromium,,
1259,CVE-2016-1673,chromium,"When navigating from a new document to an empty document using Google's
*Blink* engine, the engine loaded the request without checking whether
navigation was allowed. Due to this, it was possible to execute an XSS attack
via the request, bypassing the browser's protections.
","When the vulnerability was introduced, the method containing it did not have
anything that would allow the code to adhere to the Same Origin Policy.
In that area, it took some time for parts of this system to adhere to the
policy; I would not be surprised if there were related UXSS CVEs surrounding
that code area, especially in the second navigate method.

Ultimately, it appears that the vulnerability persisted due to a series of
oversights by developers. The VCC did not understand the risk of not
validating the request before loading it; a subsequent developer made the
same error when making the second navigate method right below the first.
The vulnerability was passed over twice in code reviews, first in an
unrelated code review that accidentally reverted code, and again in a second
code review that merely sought to restore reverted code. When adding
additional parameters to the method for user gesture support, the
vulnerability remained untouched. The successive failures to recognize the
vulnerability were what allowed a critical universal cross-site scripting
vulnerability to continue to exist for almost 2 years.

It surprises me that the commit making changes to adhere to the Same Origin
Policy in the second navigate method overlooked the same occurrence four
lines above. Perhaps it lasted for so long because developers were
laser-focused in the tasks they set out to accomplish. I would credit this
task-related ""tunnel vision"" to the maintenance of the vulnerability over
time.
"
1260,CVE-2016-1674,chromium,,
1262,CVE-2016-1676,chromium,,
1263,CVE-2016-1677,chromium,,
1265,CVE-2016-1679,chromium,"The ToV8Value function has unneccessary calls of setter functions that may
crash the Google Chrome Web Browser: This is due to a lack of necessary
restrictions on these getter and setter functions in the ToV8Value function.
The ToV8Value should never call setter functions. This behavior was
unneccessary to execute its intended purpose. This flaw can be manipulated
to trigger a use-after-free, and crash google chrome (Denial of Service).
","A design/coding mistake has been made for this section of code. A setter
was introduced in an area where there was no need or reason for it, which
lead to a denial of service by crashing the site.
"
1266,CVE-2016-1680,chromium,,
1267,CVE-2016-1681,chromium,,
1268,CVE-2016-1682,chromium,"Checks to verify the content security policy (CSP) of a request were missing
from a function that registers service workers. This allowed attackers to
bypass CSP and register service workers even if they shouldn't have been
able to.
","It seems as though the developer just didn't think to check for CSP
before registering the service workers. The fix was simply adding an if
statement before registration to check the CSP, so the mistake made by the
original developer was just forgetting to make that check.
"
1269,CVE-2016-1683,chromium,,
1270,CVE-2016-1684,chromium,,
1271,CVE-2016-1685,chromium,,
1272,CVE-2016-1686,chromium,"A specific function in a PDF renderer which didn't properly handle a failure
during its initialization causes a denial of service (out-of-bounds read) via
a crafted PDF document that contained a malformed JPG image. An attacker who
knows this exploit could potentiallycause the function to halt or crash,
meaning the browser utilizing this  function may have issues resulting from
this problem.
","In my opinion, the mistakes were mostly coding mistakes, where ways of
avoiding issues such as this were already known to the coding world, however
the developer who originally wrote the functions here did not put them to
use. Simply adding wrappers and distrusting input fixed the issue.

Overall, this was a very interesting vulnerability which might not have been
obvious to most engineers tasked to do this, and I think that this only goes
to show that the scope of vulnerabilities will always be larger than what
you initially expect. 
"
1274,CVE-2016-1688,chromium,,
1276,CVE-2016-1690,chromium,,
1277,CVE-2016-1691,chromium,,
1278,CVE-2016-1692,chromium,"When downloading a style sheet, the checks on the style sheet were
insufficient. An actor could carefully craft a style sheet such that they
could inject scripting that could not only be executed, but it could have
access to native functions. This could lead to the attacker executing their
own scripting with the native functions.
","I believe this vulnerability was caused due to poor design. I don't believe
it should be the programmer's responsibility to think about all scenarios
where something could go wrong when processing stylesheets. I believe if
the Chromium team had used something a validation subsystem, where whenever
stylesheet files were being used, they must go through this validation.

I can only imagine how many places in chromium use stylesheets and would
need to validate using the validations the fix had, so it would be better
off if there was a single location where this validation occured, rather
than multiple places in the project.

Without this subsystem, it is the developer's responsibility to think
if the operation might cause some sort of vulnerability to allow
script execution. As the system scales, this sort of relaince on the
developer to think of scenarios will just lead to more of the same
XSS vulnerability.
"
1280,CVE-2016-1694,chromium,,
1281,CVE-2016-1695,chromium,,
1283,CVE-2016-1697,chromium,"Attackers were able to create javascript code that would escape from a html
specific html element known as an iframe, allowing them access a different 
page from an untrusted origin and execute javascript code on the target page.
","This vulnerability was primarily the result of an oversight in the product
design. Nobody considered how frame navigations could be used to exploit
a weakess in this product. On top of this, since frame navigations were
not a necessary function at this point of the execution, a good design
choice would have been to have them disabled by default. 
The suggested mitigation for this type of cross site scripting is minimize
the attack surface. Disabling frame navigatons while detatching a frame
completely cuts out the portion of the attack surface that is exploited
by this vulnerability. The fix completely mitigates this exploit, since 
frame navigations cannot be exploited if they are entirely disabled. 
This change, however, was only applied to one part of the code. It may be
worthwhile to review other similar areas of the attack surface and determine
whether security by default can be applied to these areas of the code to 
prevent similar exploits from happening in the future.
"
1302,CVE-2016-2845,chromium,"The Content Security Policy (CSP) implementation in Blink, as used in Google Chrome before 49.0.2623.75, does not ignore a URLs path component in the case of a ServiceWorker fetch, which allows remote attackers to obtain sensitive information about visited web pages by reading CSP violation reports, related to FrameFetchContext.cpp and ResourceFetcher.cpp.",
1303,CVE-2016-3679,chromium,,
1285,CVE-2016-1699,chromium,"Lack of proper distrustful decomposite design led to the inclusion of a bug, which allowed a client script access to read the contents of a computer's entire filesystem.
By design, Chrome DevTools are allowed to run unsafe-eval, and unsafe-inline javascript execution. This shouldn't be an issue, because all trusted dev tools should be hosted at chrome-devtools-frontend.appspot.com/. This url is whitelisted, and only JavaScript code the browser believes came from this source is allowed to run with these typed of permissions. This security model allows DevTools to have more power and freedom than the average web page should be allowed to have, with reasonably little attack surface for exploit vectors to enter through. The omission of proper sanitization of the src attribute attatched to iFrame elements in a page, however, exposed an elevation of privlages vulnerability by executing code that may or may not come from the whitelisted source.",
1286,CVE-2016-1700,chromium,"During the creation of an array of views for an extension, there is
nothing that prevents setters from destroying a view in one of the array
indeces, which triggers unexpected behavior when said destroyed view is
attempted to be accessed by other parts of the extension and browser.
","This vulnerability was a simple coding mistake that did not take into
account how the deletion of a single member of the array affects the access of
all data within said array. The fix takes this into account, and runs checks
to validate the integrity of the data stored.
"
1287,CVE-2016-1701,chromium,,
1288,CVE-2016-1702,chromium,,
1289,CVE-2016-1703,chromium,,
1290,CVE-2016-1704,chromium,,
1291,CVE-2016-1705,chromium,,
1294,CVE-2016-1708,chromium,"The Chrome web store inine-installation implementation in the extensions subsystem does not properly consider object lifetimes during progress observation. This allows for remote attacks to cause a denial of service. Modifications of some system files or information is possible, but the attacker does not have direct control of what can be modified.","In chrome/browser/extensions/tab_helper.cc, CHECK() is frowned upon because it allows for trivial DoS. In chrome/browser/extensions/tab_helper.cc, DCHECK(install_observers_.find(webstore_item_id) == can use install_observers_.count(webstore_item_id) == 0. There wasn't testing added for the new functionality in tab_helper.cc."
1296,CVE-2016-1710,chromium,"An architectural problem existed in the way Chromium deferred the loading of 
pages.  This problem involved pages created by frames on pages that had been
deferred not also being deferred.  This made it possible for an attacker to
craft and transfer a frame across the deferral boundary (between different
pages), essentially allowing them to inject malicious code across origins 
(sources of data).  This violates the Same-origin Policy.
 
","This was a design mistake that was simply an oversight where the developers
did not consider that an attacker could take advantage of the way they 
deferred page loads.  They didn't consider the consequences of someone
potentially bypassing the page deferral code.  This kind of mistake really
takes a high level of thinking outside of the norms to catch.  However, if
they had been more prudent about validating the origins of all data loaded
into these pages, they could have mitigated this vulnerability without
knowing it was even present to begin with.
"
1298,CVE-2016-2051,chromium,,
1299,CVE-2016-2052,chromium,,
1300,CVE-2016-2843,chromium,,
1301,CVE-2016-2844,chromium,"The ability to determine if an anonymous block wrapper existing did not work properly.  This caused a vulnerability that could allow remote attackers to cause a denial of service.
","The major cause of this vulnerability was that it was the environment. It was working until another section was corrected, and then the automated tests started failing.  Also in the comments it was shown that some people did not understand Layout or had access so it was only one subset of people that could fix this issue.
"
1385,CVE-2017-15415,chromium,"Embargoed. Pointer information disclosure in IPC call.
",
1386,CVE-2017-15416,chromium,"Embargoed. Out of bounds read in Blink.
",
1304,CVE-2016-5127,chromium,"This was a vulnerability that allowed remote attackers to attack Google Chrome 
before version 52.0.2743.82 had been released. Remote attackers can cause a 
denial of service or possibly other problems that are not specified. 

The attacks can be done using JavaScript code. The code involves @import 
at-rule in a CSS token sequence along with a rel=import attribute of a 
LINK element. This just means that the attacker is able to attack the HTML
file while the user is trying to import a file. This seems similar to the 
Cross-Site Scripting (XSS) vulnerability we discussed in class.
","This vulnerability was caused due to a lack of design. The developers did not
design the updating of the layout tree appropriately.

CWE-416 is ""Use After Free"" weakness. This is when someone references memory
after it has been freed, causing the program to crash. Presumably, the pending
files is the free memory in this scenario. The mitigation to this was to 
set free pointers to null after freeing the pointer. In this situation the 
main fix was making that intial check previousLinePosition() to not use dangling 
RootInlineBox. This ensures that the memory will no longer be free and vulnerable.

The developers seem to have done a fairly good job at patching the issue quickly and
effectively.
"
1305,CVE-2016-5128,chromium,,
1306,CVE-2016-5129,chromium,,
1308,CVE-2016-5131,chromium,"The vulnerabilitywas caused by the implementation of a function that handled the range-to
function in XML. There was code where after memory was freed, it was attempted to be used
which can cause Chrome to crash or freeze. This could be abused to intentionally make Chrome
unavailable to users or allow for remote code execution.
","I think that a misunderstanding of what range-to (in the xml markup language) did led to this vulnerability
since that what the commit message seems to imply.
""range-to is not a real function but a special type of location step which is handled in xpath.c.""
"
1310,CVE-2016-5133,chromium,"This vulnerability comes from lack of foresight during initial development,
or a misunderstanding of how the process is being used. This vulnerability 
is effectively a way for an attacker to mislead users and obtain their
credentials. 
","This vulnerability appears that it came mostly from a requrements error.
The initial investigation of transmitting the VPN password as well as how to
obtain the VPN password, when prompted, should have yielded the information 
concerning any OS's support (or lack there of at the time). Without this piece
of information from the beginning of the design process being taken, the 
information was not accurate. 
"
1311,CVE-2016-5134,chromium,"The Proxy Auto-Config (PAC) feature in Google Chrome does not ensure that the
URL information is restricted to the schema, host and port. This allows remote
attackers to discover credentials by operating a server with a PAC script.
","The major mistake which lead to this vulnerability was in the requirements.
This is a result of an imporper understanding of the PAC script or the resulting
vulnerability being overlooked. This could have also been a result of good enough
programming as it was indicated that this is an issue for other browsers as well.
"
1312,CVE-2016-5135,chromium,,
1313,CVE-2016-5136,chromium,"Referencing memory after it has been freed can lead to a variety of behaviors including crashing and corrupting data. 

In this specific CVE, when an extension is loaded or unloaded by the application, the content
of these scripts are unregistered. If this happens in the middle of an injection, the freed addresses
of these unregistered scripts are accessed causing a use after free vulnerability causing a crash. 
","After spending some time reading through the discussions held on the bug as well as looking through a plethora of commits, 
I feel like it was roughly a design mistake that led to the vulnerability. As no code was really deleted, just another variable
was added in the file along with some lines to deal with said variable in terms of handling the script.  I also feel that a lot
of Use After Free vulnerabilities are caused by a combination of coding mistakes and design mistakes. If you don't specifically
design your code or functions to account for it, it is easy to code in a way that leaves room for this vulnerability to happen. 
"
1314,CVE-2016-5137,chromium,"WebKit's schemeMatches function in the Content Security Policy does not apply
http port 80 policies to https port 443 URLs and does not apply WebSocket (ws) 
port 80 policies to WebSocketSecure (wss) port 443 URLs. 

A Content Security Policy is a security measure that can be added to a site 
to restrict what resources can be loaded in the browser. When the
schemeMatches function does not treat image resources identically through 
each protocol, an attacker can set a Content Security Policy that restricts
images from http and ws protocols. When an attacker does this they can monitor
the response time for the resources and determine if the user has visited 
the image's domain previously (if the response time is quick, then the image
is cached). This is sniffing browser history.
","This is a coding mistake.

The Chromium developers defined the proper requirements and design, 
which is apparent through their mitigation efforts, but they missed the 
specific cases when dealing with explicitly defined port numbers.
"
1315,CVE-2016-5138,chromium,,
1316,CVE-2016-5139,chromium,"A heap buffer overflow vulnerability is present in the jpeg2000. In this vulnerability
memory that is dynamically allocated has been been used passed its bounds.
",It was a simple mistake where buffer sizes were not calculated correctly in PDFium
1317,CVE-2016-5140,chromium,,
1318,CVE-2016-5141,chromium,,
1321,CVE-2016-5144,chromium,"There is a vulnerability with Chrome DevTools. Previously, when a url was 
passed in to a function and the function attempted to sanitize the url,
the sanitization algorithm was insufficient. This allowed attackers to bypass
access restrictions and inject arbitrary HTML tags into the page. The bug allowed
chrome extensions such as Google Tone to be used to execute Cross-Site Scripting attacks
through the 'chrome-devtool://' URLs.
","The coding mistake was a failure to properly sanitize inputs. The VCC author
didn't think about different inputs when he wrote his sanitization functions.

The vulnerability was introduced in two commits by the same author. He wrote a
sanitization function, but all that it check was that the url had a certain prefix.
He failed to realise that HTML tags could be injected into the site because
the input was not whitelisted. This essentially allowed malicious javascript code
to be inserted on a user's page through the url (XSS). He should have thought
more about potential url inputs.
"
1387,CVE-2017-15417,chromium,"Embargoed. Cross origin information disclosure in Skia.
",
1323,CVE-2016-5146,chromium,,
1324,CVE-2016-5147,chromium,"CVE-2016-5147, or known as Blink, is an attack that uses deferred page loadings to inject web scripts or malicious HTML.",
1327,CVE-2016-5150,chromium,"Properties are variable attributes of an object. Like color is a property for
for a Bird. Properties can also be inherented from their perent class. 
For example, Bird can inheret properties from the Animal parent class.


Key-paths are a way of storing uninvoked references to properties.
This means they refer to a property itself rather than to that property’s value. 

The vulnerability was in Google's Javascript Engine, *V8*, in an API 
implementation written in C. Getters using key-paths were
not restricted to inherited properties, allowing getters on prototypes
to be executed. 

This created a use-after-free vulnerability. Use After Free specifically refers to the 
attempt to access memory after it has been freed, which can cause a program to crash
in the best case. 
Worst case, since this is a vulnerability in a JavaScript feature, attackers could 
execute arbitrary code or even enable full remote code execution capabilities.
","As the bug report is not available, it is not clear whether this was a known issue
with the library, or if it was specific to v8's implementation of it.
If it were the latter, the mistake causing this vulnerability was improper implementation of 3rd
party library, IndexedDB, as the Google developers failed to restrict certain key-path evaluations, 
specically getter calls made to prototypes. 

On the other hand, if the library unknowingly contained the bug, then IndexedDB would
be at fault for not testing all edge cases when it came to their library's security.  
"
1328,CVE-2016-5151,chromium,"Certain early builds of the software PDFium for chrome mishandles
timers, allowing remote attackers to cause a denial-of-service by trying to reference
memory that has already been freed by the system. That or some other unspecified 
issue through the use of a created PDF Document.
",
1330,CVE-2016-5153,chromium,,
1331,CVE-2016-5154,chromium,,
1332,CVE-2016-5155,chromium,,
1333,CVE-2016-5156,chromium,"The C++ event binder would fail to add an event matcher to a list
of filtered events. After failing, the events would still be processed and
the missing event would never be run. If the missing event was followed up
with another event that required memory to be freed by the previous event, the
next event in the sequence would never be run. The event now waiting for
memory to be freed would cause a denial of service as it is just sitting
there waiting indefinitely.
","There was a coding mistake made because it was assumed events would
always be matched properly. Due to event matchers occasionally not linking
properly to events, this unexpected and unhandled edge case stopped the
system. If there were some kind of check for this linking to begin with,
the code would have failed securely and this vulnerability would not have
happened.
"
1388,CVE-2017-15418,chromium,"Embargoed. Use of uninitialized value in Skia.
",
1389,CVE-2017-15419,chromium,"Embargoed. Cross origin leak of redirect URL in Blink.
",
1390,CVE-2017-15420,chromium,"Embargoed. URL spoofing in Omnibox.
",
1391,CVE-2017-15422,chromium,"Embargoed. Integer overflow in ICU.
",
1392,CVE-2017-15423,chromium,"Embargoed. Issue with SPAKE implementation in BoringSSL.
",
1393,CVE-2017-15424,chromium,"Embargoed. URL Spoof in Omnibox.
",
1394,CVE-2017-15425,chromium,"Embargoed. URL Spoof in Omnibox.
",
1335,CVE-2016-5158,chromium,"In two places int overflows can occur, PDFium and OpenJPEG. The int overflow can be targeted to cause a denial of service this is done thorough a heap-based buffer overflow. Also this could have unspecified impact on JPEG data",The mistake really seemed to be that a manual change had to be made in Chromium so that a diffrent software peice that relayed on was updated this seemed like a easy to automate fix that would prevent this from happening
1336,CVE-2016-5159,chromium,,
1337,CVE-2016-5160,chromium,"The vulnerability was in Chrome's extensions utility. Every extension has
a manifest.json file, which holds a 'web_accessible_resources' field.
This field states every internal resource of the extension that can be accessed via
the web.
The system would allow a user to open an iframe to the settings page of the extension. Attackers could use this vulnerability to trick users into changing the settings of extensions.
","The mistake here was not a coding one, but a design/requirements one. The
correct behavior of the extension functionality needed to be revised, so the
fix involved removing old code and writing new code to match the new
requirements. Interestingly, we did not find any records of the requirements
"
1339,CVE-2016-5162,chromium,,
1340,CVE-2016-5163,chromium,"While English and many other languages are processed from left-to-right (LTR), other languages (like Arabic and Hebrew) are processed from right-to-left (RTL).  Unicode supports characters from both classifications.  Strings made up of both LTR and RTL characters must be displayed in a specific order using the bidirectional text (bidi) algorithm.
In this vulnerability, on Chrome for Android, when a user entered a URL into the address bar, if the first strong character (A character with a clear direction, either LTR or RTL.  Usually an alphabetic character) in the URL is RTL, an attacker could construct a URL that was displayed in reverse, introducing address bar spoofing by constructing URLs that appear to be visiting one domain but are actually visiting some malicious site.
For example, in the URL 127.0.0.1/ا/http://example.com , the first strong character from LTR is ا.  This character causes the neutral characters (numbers and punctuation) preceding it to take on the RTL direction, while http://example.com remains LTR.  As a result, the URL is displayed as http://example.com/‭ا/127.0.0.1, with the LTR segment appearing before the RTL segment.
The displayed URL is an example of address bar spoofing because it leads the user to believe they are visiting example.com, when they are actually navigating to localhost.  This vulnerability was found in Omnibox, which is responsible for things like URL auto-complete, instant search, and search suggestions.","It was nearly impossible to find the source of this vulnerability because the introduction of the UrlBar
and SuggestionView Omnibox code into this repo was buried so deep within a 1000+-file commit.  While
this may not have contributed to the vulnerability, the developers should consider breaking up future refactoring
efforts across multiple, smaller commits to improve traceability.

While the team clearly considered issues of bidirectional text in the code, this vulnerability seems to have
slipped by them.  Therefore, I would classify this as a coding mistake, as support for bidi seems to have
already been a part of the requirements and design.  The fix seems proper; the developer specifically chose to 
force LTR as the solution in order to align with the behavior of similar modules in the system.
"
1341,CVE-2016-5164,chromium,,
1344,CVE-2016-5167,chromium,,
1345,CVE-2016-5170,chromium,,
1347,CVE-2016-5172,chromium,,
1395,CVE-2017-15426,chromium,"Embargoed. URL Spoof in Omnibox.
",
1396,CVE-2017-15427,chromium,"Embargoed. Insufficient blocking of JavaScript in Omnibox.
",
1397,CVE-2017-15428,chromium,"Embargoed. Out of bounds read in V8.
",
1398,CVE-2017-15429,chromium,"Embargoed. UXSS in V8.
",
1399,CVE-2017-5029,chromium,"Integer overflow in libxslt. With a xslt file which generates big text nodes
it is possible to trigger an integer overflow in xsltAddTextString in
transform.c of the libxslt library. The function handles the memory management
if new data are added to a text node. The vulnerability exists because there
is no check for overflow while calculating a new size of a buffer to hold the
data of a text node. The issue can be exploited to trigger an out of bounds
write.
",
1350,CVE-2016-5175,chromium,,
1351,CVE-2016-5176,chromium,,
1352,CVE-2016-7152,chromium,,
1353,CVE-2016-7153,chromium,,
1355,CVE-2016-7549,chromium,"The reciever of an IPC message was never validated, meaning the messages could
be sent out to null, invalid or 'dead' processes. This created an opportunity
for denial of service attacks as well as an opening for arbitrary code execution.
","This vulnerability stemmed from design flaw that assumed object state.
The reason for this design flaw can be summed up by a comment from one of
the developers.

  'I see This frame being destroyed then sent a message,
  I thought that should never happen'.

This type of assuming will lead to oversights and design flaws
such as this one. The mitigation for the CWE is 'Use Static analysis tools
to check for unreleased resources'. This sums this fix introduced for this
vulnerability, checking the state of the object instead of assuming it.
"
1356,CVE-2017-0561,chromium,"Embargoed. Broadcom WiFi SoC remote kernel code.
",
1357,CVE-2017-15386,chromium,"Embargoed. UI spoofing in Blink.
",
1358,CVE-2017-15387,chromium,"Embargoed. Content security bypass.
",
1359,CVE-2017-15388,chromium,"Embargoed. Out of bounds read in Skia.
",
1360,CVE-2017-15389,chromium,"Embargoed. URL Spoofing in Omnibox.
",
1361,CVE-2017-15390,chromium,"Embargoed. URL Spoofing in Omnibox.
",
1362,CVE-2017-15391,chromium,"Embargoed. Extension limitation bypass in Extensions.
",
1363,CVE-2017-15392,chromium,"Embargoed. Incorrect registry key handling in PlatformIntegration.
",
1364,CVE-2017-15393,chromium,"Embargoed. Referrer leak in Devtools.
",
1366,CVE-2017-15395,chromium,"Embargoed. Null pointer dereference in ImageCapture.
",
1367,CVE-2017-15396,chromium,"Embargoed. Stack overflow in V8.
",
1368,CVE-2017-15397,chromium,"Embargoed. Use of plaintext network protocols in ChromeVox.
",
1369,CVE-2017-15398,chromium,"Embargoed. Stack buffer overflow in QUIC.
",
1370,CVE-2017-15399,chromium,"Embargoed. Use after free in V8.
",
1371,CVE-2017-15400,chromium,"Embargoed. CRLF and code injection in printer zeroconfig.
",
1372,CVE-2017-15401,chromium,"Embargoed. Out of bounds memory access in V8.
",
1373,CVE-2017-15402,chromium,"Embargoed. Privilege escalation in PageState.
",
1374,CVE-2017-15403,chromium,"Command injection in network_diag.
",
1375,CVE-2017-15404,chromium,"Symlink traversal in crash_reporter. The crash handler for non-chrome
processes copies files to /tmp/crash_reporter/<crashed pid>/ as root.
",
1377,CVE-2017-15406,chromium,"Embargoed. Stack overflow in V8.
",
1378,CVE-2017-15407.yml,chromium,"Embargoed. Out of bounds write in QUIC.
",
1379,CVE-2017-15408,chromium,"Embargoed. Heap buffer overflow in PDFium.
",
1380,CVE-2017-15409,chromium,"Embargoed. Out of bounds write in Skia.
",
1381,CVE-2017-15410,chromium,Embargoed. Use after free in PDFium.,
1382,CVE-2017-15411,chromium,"Embargoed. Use after free in PDFium.
",
1383,CVE-2017-15412,chromium,"Embargoed. Use after free in libXML.
",
1384,CVE-2017-15413,chromium,"Embargoed. Type confusion in WebAssembly.
",
1403,CVE-2017-5033,chromium,"Bypass of Content Security Policy in Blink. By loading a new document using
window.open("""",""_blank"") and document.write-ing into it, (being in
about:blank), you can circumvent the CSP restrictions put on the document
your js code was running on and reach out to other sites.
",
1404,CVE-2017-5034,chromium,"Use after free in PDFium.
",
1405,CVE-2017-5035,chromium,"Incorrect security UI in Omnibox.
",
1406,CVE-2017-5036,chromium,"Embargoed. Use after free in PDFium.
",
1407,CVE-2017-5037,chromium,"Multiple out of bounds writes in ChunkDemuxer.
",
1409,CVE-2017-5039,chromium,"Use after free in PDFium.
",
1410,CVE-2017-5040,chromium,"Information disclosure in V8.
",
1411,CVE-2017-5041,chromium,"Address spoofing in Omnibox. When a ""Confirm Form Resubmission"" box appears
and the Form submission is sent to another web site, the location bar shows
the URL and the SSL indicator of website targeted but the content of the
previous webpage continues to be shown.
",
1412,CVE-2017-5042,chromium,"Incorrect handling of cookies in Cast. When a user starts the browser, it
immediately sends a UDP multicast SSDP request to 239.255.255.250:1900. The
purpose of this request is to gather info from other local network devices
that Chrome could later use for screen casting. The problem is that the effect
of this functionality is that the browser asks the network to suggest a set of
URLs that it should run HTTP GET requests on at startup. Then it runs the
requests, all without any user interaction or awareness.
",
1413,CVE-2017-5043,chromium,"Embargoed. Use after free in GuestView.
",
1414,CVE-2017-5044,chromium,"Heap overflow in Skia.
",
1415,CVE-2017-5045,chromium,"Information disclosure in XSS Auditor. Attackers can exploit the XSS Auditor's
blocking mode in leaking information of any webpage from a different origin.
",
1416,CVE-2017-5046,chromium,"Information disclosure in Blink.
",
1417,CVE-2017-5052,chromium,"Bad cast in Blink.
",
1418,CVE-2017-5053,chromium,"Out of bounds memory access in V8.
",
1419,CVE-2017-5054,chromium,"Heap buffer overflow in V8.
",
1420,CVE-2017-5055,chromium,"Use after free in printing. When the cross process navigation occurs, the
onunload event of the iframe calls print() and
PrintPreviewHandler::HandleGetPreview is called and manipulates freed memory.
",PrintPreviewDone() got called multiple times and failed its internal state DCHeck(). These mistakes were found after the team created unit tests for the fix.
1421,CVE-2017-5056,chromium,"Embargoed. Use after free in Blink.
",
1422,CVE-2017-5057,chromium,"Type confusion in PDFium.
",
1423,CVE-2017-5058,chromium,"Heap use after free in Print Preview.
",
1424,CVE-2017-5059,chromium,"Type confusion in Blink.
",
1426,CVE-2017-5061,chromium,"URL spoofing in Omnibox.
",
1427,CVE-2017-5062,chromium,"Embargoed. Use after free in Chrome Apps.
",
1428,CVE-2017-5063,chromium,"Heap overflow in Skia.
",
1429,CVE-2017-5064,chromium,"Use after free in Blink. Under certain conditions, setting the z-index of an
animated node during its animation (with -webkit-animation) then removing this
node from DOM before the end of the animation will cause this crash.
",
1431,CVE-2017-5066,chromium,"Incorrect signature handing in Networking. As for a certificate, when the
declared signature algorithm identifier (e.g. Sha1WithRSAEncryption) is
different from the actually used signature algorightm identifier (e.g.
Sha256WithRSAEncryption), the certificate should be rejected. However, Chrome
accepts such a certificate without any warning.
",
1432,CVE-2017-5067,chromium,"URL spoofing in Omnibox.
",
1433,CVE-2017-5068,chromium,"Race condition in WebRTC. When a new iframe is inserted, the order of frames
on the page becomes ambiguous.
",
1434,CVE-2017-5069,chromium,"Cross-origin bypass in Blink. By setting up a header of ""X-XSS-Protection: 1;
report=cross-domain-uri"" it is possible to send cross-origin post request with
content-type value of ""application/json"". Any request containing content-type
of ""application/json"" should trigger a pre-flight request - but this is not
happening. Imagine a situation where an application isn't expecting any
parameters for an endpoint of https://app.com/user/1000/delete for a POST
request and the only CSRF-Protection is based on CORS - this would bypass this
restriction.
",
1437,CVE-2017-5072,chromium,"Address spoofing in Omnibox. The URL bar is the only reliable security
indicator in browsers and if the only reliable security indicator could be
controlled by an attacker it could carry adverse affects. For instance
potentially tricking users into supplying sensitive information to a malicious
website due to the fact that it could easily lead the users to believe that
they are visiting is legitimate website as the address bar points to the
correct website.
",
1438,CVE-2017-5073,chromium,"Use after free in print preview.
",
1439,CVE-2017-5074,chromium,"Embargoed. Use after free in Apps Bluetooth.
",
1440,CVE-2017-5075,chromium,"Information leak in CSP reporting. Adding a Content-Security-Policy header
containing a report-uri can lead to the leak of the current URL fragment to
the web server, even though it should never be sent. This turns an otherwise
active attack (serving an evil JavaScript file to the user to make it leak the
fragment) into a passive and deferred attack, using a mechanism otherwise made
to improve the security.
",
1441,CVE-2017-5076,chromium,"Address spoofing in Omnibox. ""Canadian Syllabics"" unicode breaks URLs.
",
1442,CVE-2017-5077,chromium,"Heap buffer overflow in Skia.
",
1443,CVE-2017-5078,chromium,"Possible command injection in mailto handling.
",
1444,CVE-2017-5079,chromium,"UI spoofing in Blink. Usually, window.open() deactivates the origin window
and validation bubble on the origin window is closed. However, if
window.print() is executed, it suspends message loop of the window, and
deactivation isn't noticed until print dialog is closed.
",
1445,CVE-2017-5080,chromium,"Use after free in credit card autofill. Duplicate instances of SaveCardBubble
fail to get cleaned up.
",
1446,CVE-2017-5081,chromium,"Extension verification bypass. There is an approach to bypass extension's
content verification mechanism in Chromium-based browsers. This approach is
used by malware / adware writers and there are malicious extensions droppers,
which use this mechanism ITW. The nutshell of the bug is a lack of
verification in extensions locale folder. So, it's possible to create
extension, which consists of only content script, for example, and this
script is located in _locales folder.
",
1448,CVE-2017-5083,chromium,"UI spoofing in Blink.
",
1449,CVE-2017-5084,chromium,"Local access to local files via dbus.
",
1450,CVE-2017-5085,chromium,"Inappropriate javascript execution on WebUI pages. From a security POV this
doesn't seem terribly interesting (the attacker must convince the user to add
a dangerous bookmarklet, navigate to a privileged page, and invoke the
bookmarklet).
",
1451,CVE-2017-5086,chromium,"Address spoofing in Omnibox.
",
1452,CVE-2017-5087,chromium,"Sandbox Escape in IndexedDB. When an IndexedDB transaction is created,
indexed_db_connection.cc stores a map from transaction id to a unique_ptr
containing the IndexedDBTransaction, and schedules some actions with the raw
pointer. A compromised renderer can create a new transaction with the same
id, leading to UaF when one of the raw pointers is accessed.
",
1453,CVE-2017-5088,chromium,"Out of bounds read in V8: v8::wasm::module-decoder. This discloses sensitive
information in the heap.
",
1454,CVE-2017-5089,chromium,"Domain spoofing in Omnibox. The character ""U+0F8C"" when used in a domain name
in Chrome looks just like a space. This can be abused to spoof a legitimate
domain followed by a chain of the character. This is a Mac OS-specific
vulnerability.
",
1455,CVE-2017-5091,chromium,"Use after free in IndexedDB. In normal scenarios, a cursor is created and
passed off to a callback function, however, if there are no callbacks, the
cursor gets destructed, but the pointer to it remains within the system.
",
1456,CVE-2017-5092,chromium,"Use after free in PPAPI. The sandbox process sends an IPC message to the
browser, but the browser is unable to verify its authenticity. This results
in the browser reading uninitialized memory from the heap and crashing.
",
1458,CVE-2017-5094,chromium,"Embargoed. Type confusion in extensions.
",
1459,CVE-2017-5095,chromium,"Out-of-bounds write in PDFium.
",
1460,CVE-2017-5096,chromium,"User information leak via Android intents. URL can be used to navigate from
HTTP to FILE.
(i.e. ""googlechrome://navigate?url=file:///sdcard/Download/a.html"")
",
1461,CVE-2017-5097,chromium,"Out-of-bounds read in Skia.
",
1462,CVE-2017-5098,chromium,"Use after free in V8.
",
1463,CVE-2017-5099,chromium,"Out-of-bounds write in PPAPI. When the sandbox process fails to verify the
authenticity of a message, fake data can be inserted, resulting in elevation
of privilege.
",
1465,CVE-2017-5101,chromium,"URL spoofing in OmniBox. By changing the location hash and calling a modal
dialog at the same time a user focuses on the omnibox it's possible to spoof
the URL and the HTTPS lock. After the spoof, if the user tries to interact
with the webpage the URL will return to normal, but this can be circumvented
by putting the user in fullscreen after his first click.
",
1466,CVE-2017-5102,chromium,"Uninitialized use in Skia. Uninitialized value was created by an allocation
of ""color"" in the stack frame of the ""ReadBuffer"" function.
",
1467,CVE-2017-5103,chromium,"Uninitialized use in Skia. Uninitialized value was created by an allocation
of ""src"" in the stack frame of the ""ReadBuffer"" function.
",
1468,CVE-2017-5104,chromium,"UI spoofing in browser. Secure/Not Secure label next to URL could be spoofed
on Mac OS.
",
1469,CVE-2017-5105,chromium,"URL spoofing in OmniBox. Spoofing occurs when inserting ""U+0650"" into
the URL.
",
1470,CVE-2017-5106,chromium,"URL spoofing in OmniBox. Similar to CVE-2017-5105, spoofing occurs when
inserting Cyrillic characters into a URL.
",
1472,CVE-2017-5108,chromium,"Type confusion in PDFium.
",
1474,CVE-2017-5110,chromium,"UI spoofing in payments dialog. PaymentRequestAPI shows the native payment UI.
An attacker can change the origin of payment from this screen. Basically, you can
spoof the payment screen so that it changes where the payment screen comes from.
This allows an abuser to use the spoofing to change the what is being paid out and to where.
","The main mistake here was not realizing that their data has a vulnerable layer
or a layer that could be removed and replaced interchangeablely with a malicious surface.
The possibility for interchangeable parts here is what allowed the system to have this spoofing problem,
however that doesn't make the inherent software design wrong,
but instead it means that the software design should have considered the
fact that there may have been a need to swap that layer out in the future,
and the security aspect of it should have been considered in the architecture choosing-phase.
"
1475,CVE-2017-5111,chromium,"Embargoed. Use after free in PDFium.
",
1476,CVE-2017-5112,chromium,"Embargoed. Heap buffer overflow in WebGL.
",
1477,CVE-2017-5113,chromium,"Embargoed. Heap buffer overflow in Skia.
",
1478,CVE-2017-5114,chromium,"Embargoed. Memory lifecycle issue in PDFium.
",
1479,CVE-2017-5115,chromium,"Embargoed. Type confusion in V8.
",
1480,CVE-2017-5116,chromium,"Embargoed. Type confusion in V8.
",
1481,CVE-2017-5117,chromium,"Embargoed. Use of uninitialized value in Skia.
",
1482,CVE-2017-5118,chromium,"Embargoed. Bypass of Content Security Policy in Blink.
",
1483,CVE-2017-5119,chromium,"Embargoed. Use of uninitialized value in Skia.
",
1484,CVE-2017-5120,chromium,"Embargoed. Potential HTTPS downgrade during redirect navigation.
",
1485,CVE-2017-5121,chromium,"Embargoed. Out-of-bounds access in V8.
",
1486,CVE-2017-5122,chromium,"Embargoed. Out-of-bounds access in V8.
",
1487,CVE-2017-5124,chromium,"Embargoed. UXSS with MHTML.
",
1488,CVE-2017-5125,chromium,"Embargoed. Heap overflow in Skia.
",
1489,CVE-2017-5126,chromium,"Embargoed. Use after free in PDFium.
",
1490,CVE-2017-5127,chromium,"Embargoed. Use after free in PDFium.
",
1491,CVE-2017-5128,chromium,"Embargoed. Heap overflow in WebGL.
",
1492,CVE-2017-5129,chromium,"Embargoed. Use after free in WebAudio.
",
1493,CVE-2017-5130,chromium,"Embargoed. Heap overflow in libxml2.
",
1494,CVE-2017-5131,chromium,"Embargoed. Out of bounds write in Skia.
",
1495,CVE-2017-5132,chromium,"Embargoed. Incorrect stack manipulation in WebAssembly.
",
1496,CVE-2017-5133,chromium,"Embargoed. Out of bounds write in Skia.
",
1497,CVE-2017-6991,chromium,"Embargoed. Pointer disclosure in SQLite.
",
1,CVE-2008-4340,chromium,,
1498,CVE-2017-9417,chromium,"BroadPwn security bug. A bug in Broadcom's WIFI chipsets allows remote access
to billions of Android and iOS phones.
",
2,CVE-2008-4724,chromium,,
3,CVE-2008-5749,chromium,,
4,CVE-2008-5915,chromium,,
5,CVE-2008-6994,chromium,,
6,CVE-2008-6995,chromium,,
7,CVE-2008-6996,chromium,,
8,CVE-2008-6997,chromium,,
10,CVE-2008-7061,chromium,,
11,CVE-2008-7246,chromium,,
12,CVE-2008-7294,chromium,,
13,CVE-2009-0276,chromium,,
14,CVE-2009-0374,chromium,,
15,CVE-2009-0411,chromium,,
16,CVE-2009-1412,chromium,"An error related to handling URLs containg a ""chromehtml: protocol"" could allow
an attacker to run malicious scripts or search files on the local disk. Visiting
an attacker-controlled web page in Internet Explorer could launch Google Chrome,
open multiple tabs, and load scripts that run after navigating to a URL of the
attacker's choice. This argument injection vulnerabilty allows for universal cross-site
scripting.
","This vulnerability seemed to stem from the result of another vulnerabilty not being handled properly.
The chromehtml feature seemed to be giving the team problems for months and
was ultimately completely removed in the end. This would be easily categorized as
a maintainabilty mistake as the chromehtml feature was not maintainable.
"
19,CVE-2009-1441,chromium,"This vulnerability was a heap-based buffer overflow accessible via Google Chrome's IPC messaging. 
This could allow attackers to malicously access the Bitmap Renderer and cause a denial of service (application crash) 
or possibly execute arbitrary code via vectors related to a large bitmap that arrived over the IPC channel. This means that 
arbitrary data inputs were not properly verified and sanitized when data was passed to the Renderer. This overflow could allow 
for arbitrary execution meaning the attacker could control the system and perform more advanced attacks once they know what inputs
are controlled by the user and how the system handles input data.

This vulnerability would only be accessible after an attacker has gained control of the system and jumped here from another 
previously discovered vulnerability. This is due to the subsystem not being customer-facing, and no actual user input is passed here.
The attacker would have to exploit other inputs to the system to utilize this heap overflow, due to IPC messages.
","There was mainly the input sanitization and verification mistake, this was probably just lazy coding, as that is common.
The fix of verifying inputs to methods is being done with the vcc. However there was a flaw with the design of the system as
the team later mentioned that the vulnerability would only be possible with the interactions with other systems via IPC messages,
therefore they should not have trusted the data given to them to be well formed, as in this case it can lead to vulnerabilities.
"
20,CVE-2009-1442,chromium,,
21,CVE-2009-1514,chromium,,
22,CVE-2009-1598,chromium,,
23,CVE-2009-1690,chromium,,
25,CVE-2009-2071,chromium,,
26,CVE-2009-2121,chromium,,
27,CVE-2009-2352,chromium,,
28,CVE-2009-2555,chromium,,
29,CVE-2009-2556,chromium,,
30,CVE-2009-2578,chromium,,
31,CVE-2009-2816,chromium,,
32,CVE-2009-2935,chromium,,
33,CVE-2009-2955,chromium,,
34,CVE-2009-2973,chromium,,
35,CVE-2009-2974,chromium,,
36,CVE-2009-3011,chromium,,
37,CVE-2009-3263,chromium,"Cross-site scripting (XSS) vulnerability in Google Chrome 2.x and 3.x before 3.0.195.21 
allows remote attackers to inject arbitrary web script or HTML via a (1) RSS or (2) Atom feed, 
related to the rendering of the application/rss+xml content type as XML ""active content.""
",
38,CVE-2009-3264,chromium,,
39,CVE-2009-3268,chromium,,
40,CVE-2009-3456,chromium,,
41,CVE-2009-3931,chromium,,
42,CVE-2009-3932,chromium,,
44,CVE-2010-0315,chromium,,
45,CVE-2010-0556,chromium,,
48,CVE-2010-0645,chromium,,
49,CVE-2010-0646,chromium,,
50,CVE-2010-0647,chromium,,
51,CVE-2010-0649,chromium,,
52,CVE-2010-0650,chromium,,
53,CVE-2010-0651,chromium,,
54,CVE-2010-0655,chromium,,
56,CVE-2010-0657,chromium,,
57,CVE-2010-0658,chromium,,
58,CVE-2010-0659,chromium,,
60,CVE-2010-0661,chromium,,
62,CVE-2010-0663,chromium,"This vulnerability can be described as a buffer overread, in which an
attacker can force an array index to read beyond the bounds of the array.
An attacker can use this to induce a system crash or to potentially read
memory they shouldn't have access to.
This vulnerability occurs in chromium's bitmap buffers. The bitmap buffer
itself and the row size of the bitmap buffer are given
by two different sources which can fall out of sync, causing the bitmap
reader to read beyond the contents of the actual buffer (e.g. if the given
buffer is small).
","This problem arose from the fact that certain properties of the data
being used were derived from different sources of truth. Namely, the
size of a bitmap buffer could be calculated from the buffer itself,
however in one instance, a function accepted a parameter which it used as
it's source of truth for the buffer size. This led to the possibility that
the actual size of the buffer could be different than the size given by
the parameter, which led to logical inconsistencies. This potentially
allowed for a buffer overread as well as limited escalation.
"
64,CVE-2010-1029,chromium,,
65,CVE-2010-1228,chromium,,
66,CVE-2010-1229,chromium,,
67,CVE-2010-1230,chromium,,
105,CVE-2010-2298,chromium,,
463,CVE-2011-3062,chromium,,
464,CVE-2011-3063,chromium,,
465,CVE-2011-3064,chromium,,
69,CVE-2010-1232,chromium,,
70,CVE-2010-1233,chromium,,
71,CVE-2010-1234,chromium,,
72,CVE-2010-1235,chromium,,
73,CVE-2010-1236,chromium,,
74,CVE-2010-1237,chromium,,
75,CVE-2010-1500,chromium,,
76,CVE-2010-1502,chromium,"Attackers are able to traverse local google files by using vectors related to
""developer tools"" in the Chromium Browser.
","The major coding mistake was that for two years, chromium did not sanitize its url input, allowing for attackers to access local files.
The vulnerability was introduced in the initial commit, and was unnoticed by the developers up until it was eventually exploited. Two google employees were asked to review the code for  security vulnerabilities, where they came across it. They ran into some problems fixing it, since the function itself could not be changed without updating more of the system, resulting in a more messy solution.
There were no unit tests to check for this vulnerability prior to its fix, prompting developers to add on for future updates and security issues."
80,CVE-2010-1506,chromium,,
81,CVE-2010-1663,chromium,,
82,CVE-2010-1664,chromium,,
83,CVE-2010-1665,chromium,,
84,CVE-2010-1731,chromium,,
85,CVE-2010-1767,chromium,,
86,CVE-2010-1770,chromium,,
87,CVE-2010-1772,chromium,,
88,CVE-2010-1773,chromium,,
89,CVE-2010-1822,chromium,,
90,CVE-2010-1823,chromium,,
91,CVE-2010-1824,chromium,,
92,CVE-2010-1825,chromium,,
93,CVE-2010-1851,chromium,,
94,CVE-2010-1992,chromium,,
95,CVE-2010-2105,chromium,,
96,CVE-2010-2106,chromium,,
97,CVE-2010-2107,chromium,"This was an error that caused chromes memory to become corrupted. The issue would occurr when a user attempted to connecto to a site that was marked for malware that no longer existed, clicked continue anyway and then refreshed the page during the long loading time. This would cause memory corruption that could be used to execute code outside of the original memory space.",This seems to have been a coding error. The vulnerability was possible mainly because of an extra check that would enter an error state when a specific method was called twice.
98,CVE-2010-2108,chromium,"This vulnerability allows remote attackers to bypass the whitelist of
acceptable plugins. The whitelist is part of the host-based settings. The 
whitelist works as intended when navigating, because all webpages will have a
host. The issue is when a new tab is first created, there is no host and thus
the plugin whitelist will not be applied.  

The fix for this vulnerability was having new windows inherit host-based settings
from the parent.
","I think a few mistakes went into the creation of the vulnerability. First
of all, I believe there may have been miscommunication within the team. 
When reading the thread detailing the vulnerability, there seemed to be 
disagreement on whether this was a UI decision. It's possible that when
the vulnerability was first introduced, the programmer considered it a 
UI design decision. This can also lead to it being a mistake in the
requirements. It's very possible that the default blocking of plugins
was not a requirement. This also could be the result of the programmer 
not understanding the system as a whole. If the programmer did not completely
understand how the creation of a new window works, this vulnerability would
have gone unnoticed. Going forward, vulnerabilities like this can be avoided
with a couple steps. First, teammates always need to be on the same page when it
comes to requirements. Next, if something is unclear in the requirements,
developers should review it with the team. Finally, developers should also make
sure that they understand the system they are working in completely before making
changes.
"
99,CVE-2010-2109,chromium,,
100,CVE-2010-2110,chromium,,
101,CVE-2010-2120,chromium,,
102,CVE-2010-2295,chromium,,
103,CVE-2010-2296,chromium,,
104,CVE-2010-2297,chromium,,
106,CVE-2010-2299,chromium,"There are certain objects that are read in through the DispatchObject()
function as clipboard objects. One of the types of objects that could be
read through this function, CBF_SMBITMAP to be exact, contains information
that points to a shared memory object. If someone who normally does not have
access to the shared memory object obtains access, they could potentially
modify the object which may affect other processes using it. This dangerous
process is normally okay since there are other methods that make it secure.
However, there was a particular instance where said methods were not used,
resulting in an unsecure use of the CBF_SMBITMAP object.
","It seems that the main cause of this issue was a small oversight by the
developers. The developers could have run through all possible Clipboard
objects that are run through the dispatchObject function. If this had been
done, they would have realized that one of the objects leads to the
vulnerability. Likewise, due to the fact that this was likely a minor
oversight by the developers, the vulnerability is also something that should
have been able to have been caught by looking at the code review a bit more
closely.
"
107,CVE-2010-2300,chromium,,
108,CVE-2010-2301,chromium,,
109,CVE-2010-2302,chromium,,
110,CVE-2010-2645,chromium,,
111,CVE-2010-2646,chromium,,
112,CVE-2010-2647,chromium,,
113,CVE-2010-2648,chromium,,
114,CVE-2010-2649,chromium,,
115,CVE-2010-2650,chromium,,
116,CVE-2010-2651,chromium,,
117,CVE-2010-2652,chromium,"This vulnerability pertains to the availability of the browser. If it was
exploited, the chromium web browser would crash. Websites can create and allow 
the user to view Javascript dialogs. These dialogs can be queued so that another 
may pop up when one closes. The crash would occur when a dialog that is in the queue 
closes. In order to do this, multiple tabs must be opened in the browser. If both
pages open a dialog simultaniously it would trigger the vulnerability.
","This was a design mistake. The initial implementation lacked any checking to 
validate that the modals were as expected. The orginal author was most likely not 
aware of modal queues when working on the functionality. The CWE doesnt mention any
obvious ways to mitigate this issue. In this situation, the author should have done more
research on the functionality of dialogs.
"
118,CVE-2010-2897,chromium,,
120,CVE-2010-2899,chromium,,
121,CVE-2010-2900,chromium,,
122,CVE-2010-2901,chromium,,
123,CVE-2010-2902,chromium,,
124,CVE-2010-2903,chromium,"The security information dialog in Chrome incorrectly displayed the hostname.
In Windows, the hostname became merged with the following line and in Linux
it was truncated. This could potentially result in an attacker using a long
hostname to spoof another website.
","This bug was due to simply not validating the hostname. An extremely long
hostname may not have even been considered in the design, however it did
become an issue later.

It was present in the very begining when the method was written over two
commits. As the vulnerability was considered very low severity after
discovery, it was likely just an oversight during design and implementation.

There was initial disagreement that the issue required a fix at all. It was
still considered unlikely that enough ""important"" or frequently used websites
with long enough hostnames to allow an exploit existed. After establishing
that spoofing was indeed possible, it was filed as low severity.
"
125,CVE-2010-3111,chromium,"A workaround was created for a Windows kernel bug that was triggered by hinting malformed fonts. Hinting is the process of rasterizing the vector fonts into bitmaps for specific display resolutions and is only applicable with the Compact Font Format (CFF) since raster information is stored in the TTF format.  
",
126,CVE-2010-3112,chromium,"Versions of Chrome prior to 5.0.375.127 do not properly implement file dialogs, allowing attackers to cause denial of service attacks.",
127,CVE-2010-3113,chromium,,
128,CVE-2010-3114,chromium,,
129,CVE-2010-3115,chromium,,
130,CVE-2010-3116,chromium,,
133,CVE-2010-3119,chromium,,
134,CVE-2010-3120,chromium,,
239,CVE-2011-1118,chromium,,
240,CVE-2011-1119,chromium,,
466,CVE-2011-3065,chromium,,
467,CVE-2011-3066,chromium,,
138,CVE-2010-3249,chromium,,
142,CVE-2010-3253,chromium,,
143,CVE-2010-3254,chromium,,
144,CVE-2010-3255,chromium,,
146,CVE-2010-3257,chromium,,
147,CVE-2010-3258,chromium,,
148,CVE-2010-3259,chromium,,
149,CVE-2010-3412,chromium,,
151,CVE-2010-3414,chromium,,
153,CVE-2010-3416,chromium,,
154,CVE-2010-3417,chromium,,
155,CVE-2010-3729,chromium,,
156,CVE-2010-3730,chromium,,
157,CVE-2010-4008,chromium,"An invalid memory access flaw was found in libxml2, a library providing
support to read, modify and write XML and HTML files. A remote attacker could
provide a specially crafted XML file that, when processed by an application using libxml2,
would lead to an read at an invalid memory address, causing an application
crash (denial of service).
 read XPath expressions (a method used to navigate through elements and
attributes in an XML file), an attacker could craft an XML document with
malformed XPaths that would cause an application crash.

This is due to the way libxml2 reads XPath expressions, which are a method t navigate
through elements of an XML file. As libxml2 parses XML, it creates ""contexts"" (looks
to be similar concept as scope) as it goes through the tree structure. The XPath most likely
cause a reference to an invalid or null context, resulting in an invalid memory access.

This could be done by creating an XML file that forces the parser to attempt to
read from an invalid memory location, leading to a crash. This is the example
given by the reporter of the vulnerability.
","The mistake that was made was trusting that if an xml node were null/not null that it would
be correctly formatted (depending on the situation). Because of this there wasn't an extra
check to ensure that the node contained the correct information in it (i.e. not malicious/malformed).
The fix here appears to be proper as it now checks that the xml nodes are of the correct
type before returning on them or performing extra checks. Additionally, due to this happening
when an XPath was being processed, additional validation of the nodes should have been performed.

While the file involved with the vulnerability had a related test file, this was not discovered
by testing. Additionally, the related test file was not updated to include specific tests for
this vulnerability, which is most likely an oversight by the dev(s) working on it. Possibly adding
a fuzzer for different XPaths or XML structures could have been implemented to help find/prevent
vulnerabilities like this.
"
159,CVE-2010-4034,chromium,"Does not handle form input in a safe manner allowing attackers to crash the application (DoS) due to a stale pointer bug, a programming error during dynamic memory allocation.","At first, it seemed to be a minor coding mistake. The issue was that Chrome needed to check the frame after it created the frame. However, after that was quickly fixed, other engineers pointed out that it was still crashing. This began to label the error as a release blocker. At one point, the engineers were discussing backup plans if the current fix was too risky. The easiest way around the issue was to remove Autofill, but the engineers decided against removing such a useful consumer tool. Eventually, the team found the issues to lie with Webkit. Interestingly, even though they found where the memory leaks happened, one can see that the code in 2018 no onger even uses this form manager."
162,CVE-2010-4037,chromium,,
163,CVE-2010-4038,chromium,,
165,CVE-2010-4040,chromium,,
166,CVE-2010-4041,chromium,,
167,CVE-2010-4042,chromium,,
168,CVE-2010-4197,chromium,,
169,CVE-2010-4198,chromium,,
170,CVE-2010-4199,chromium,,
171,CVE-2010-4201,chromium,,
172,CVE-2010-4202,chromium,,
173,CVE-2010-4203,chromium,,
174,CVE-2010-4204,chromium,,
175,CVE-2010-4205,chromium,"The vulnerability was in Google Chrome where they did not check the data type
of an event object returned from a page click.

The implementation, which was done in C++, didn't properly check if the event
object it got back was a mouse event before executing it.  This could result
in a crash or other unexpected events.

The way this could be exploited would be if an attacker found out about this
vulnerability and used it to purposely crash the site.  This could prevent
other people from accessing the site, also known as denial of service.
","The vulnerability was a simple oversight where the programmer expected to always get
a mouse event object and did not put a conditional in to make sure that it was one.

Even though it is reasonable to expect to always get a mouse event from a mouse click,
it is always good to distrust input and checking the input provides defense in depth
against an attacker who purposely injects a different type of object into the function.

The fix was simply adding a conditional and looks proper for this specific vulnerability,
but the developers should keep in mind to always check a returned value's type in other
cases. Also, writing tests with different types of objects as inputs could help prevent
future similar vulnerabilities in the future.
"
176,CVE-2010-4206,chromium,,
177,CVE-2010-4482,chromium,"The vulnerability is such that Chrome is able to open a webpage as a pop-up, which can be abused as malicious users will generate unwanted pages by bypassing the pop-up blocker using cross site-scripting (and by extension, cross-origin scripting). Chrome did not check whether the input was generated by an actual user. It is basically an example of improper input validation.
",The mistake concerned design issues in processing input. The design failed to account for input-checking as to whether the user actually initiated the input or it was inserted as a script. The fix is appropriate as the developers have whitelisted the input.
178,CVE-2010-4483,chromium,,
180,CVE-2010-4485,chromium,"Before 8.0.552.215, Google Chrome has a vulnerability that allows an attacker 
to create an infinite amount of file dialogs that can crash the browser by 
consuming all available memory. This vulnerability was proven to be present
through a crafted extension 
","Coding and design mistakes are what led to this vulnerability. It
started out with a design mistakes to refactor how untrusted code is 
handled, and then turned into a coding mistakes when the refactoring exposed
the function to content scripts directly to be executed by windows that are 
not visible, allowing an attacker to create new invisible windows to then 
open up file chooser dialogs. I believe this fix is a correct balance
between how invasive it is, and how well thought out it is.
"
181,CVE-2010-4486,chromium,,
184,CVE-2010-4489,chromium,,
186,CVE-2010-4491,chromium,,
187,CVE-2010-4492,chromium,,
188,CVE-2010-4493,chromium,,
189,CVE-2010-4494,chromium,"There is a double free vulnerability in libxml2 2.7.8 and other version as used in gogole chrome before 8.0.552.215.
The vulnerability allows one to pop an XPath object off the stack, and since the object won't be null, it can be popped again.
Double free vulnerability is a common memory corruption error when developers free the same memory location twice by calling free() on the same
 allocated memory. 

 This vulnerability may allows remote attackers to cause a denial of service or possibly have unspecified other impact relate to the Xpath in this case.
","Double free vulnerability is a common memory corruption error if the developers don't write a proper check case before they free memory
In this case, it seems like a developer simply forgot or was not aware of this. It can also be very hard to catch, as the chromium code base in incredibly large, and can not be easily combed through.
I believe that the vulnerability was fixed correctly, as they understood the complete problem and fixed it properly. 
"
193,CVE-2010-4577,chromium,,
194,CVE-2010-4578,chromium,,
195,CVE-2010-5069,chromium,,
196,CVE-2010-5073,chromium,,
197,CVE-2011-0470,chromium,"This issue was reported on Oct. 5 2010 by chromium user 'Eroman', and fixed by
user 'johnnyg' on Dec. 1 2010

from the chromium Notifications subsystem

Google chrome did not properly handle an extensions notifications, thus allowing
remote attackers to cause the application to crash (denial of service) through the
use of unspecified vectors.
","This vulnerability is a result of chrome not properly handling extensions
notification, allowing remote attackers to cause a system crash. The root
of this problem could be found in the notifications subsystem. Generally,
when you have something open in your code, when you finish using it, it is
important to properly collect and close anything that is left. The issue
that occured here is that the notification 'balloons' were not properly
collected before attempting to close them. This led to a race condition
that happened on shut down. The browser would stop all rendering and force
windows to close. The code in the notifications subsystem would then detect
the renderer being shut down as well, and attempt to close the window a
second time. The fix was introduced by properly collecting all notification
balloons on shut down, and closing all of those first. This way, there is
nothing left to try and close the window a second time after the window
already shuts down. This looks like a proper fix, and addresses the issue
at multiple points in the system.
"
198,CVE-2011-0471,chromium,,
199,CVE-2011-0472,chromium,,
200,CVE-2011-0473,chromium,,
201,CVE-2011-0474,chromium,,
202,CVE-2011-0475,chromium,,
203,CVE-2011-0476,chromium,,
468,CVE-2011-3067,chromium,,
204,CVE-2011-0477,chromium,"Google Chrome before 8.0.552.237 and Chrome OS before 8.0.552.344 do not properly handle a mismatch in video frame sizes, which allows remote attackers to cause a denial of service (incorrect memory access) or possibly have unspecified other impact via unknown vectors. 
","An attacker could provide a webm video that when decoded via FFMPEG, would cause a segmentation fault, causing Chromium to cease running. It seems that the instance of decode_engine_ would be uninitialized under some circumstances, possibly leading to the mismatch in frame sizes. The fix seems to be to always uninitialize the decode_engine_.
"
205,CVE-2011-0478,chromium,,
206,CVE-2011-0479,chromium,,
207,CVE-2011-0480,chromium,,
208,CVE-2011-0481,chromium,,
209,CVE-2011-0482,chromium,,
210,CVE-2011-0483,chromium,,
211,CVE-2011-0484,chromium,,
214,CVE-2011-0777,chromium,,
215,CVE-2011-0778,chromium,,
217,CVE-2011-0780,chromium,,
218,CVE-2011-0781,chromium,,
219,CVE-2011-0782,chromium,,
220,CVE-2011-0783,chromium,"Faulty logic for checking volume of audio caused the browser to crash, with
potential for a large scale attack.
","An oversight on validating data, that was replicated across functions and files caused
the vulnerability. Developers should have considered edge cases and all types of
potential input to avoid this vulnerability.
"
222,CVE-2011-0981,chromium,,
223,CVE-2011-0982,chromium,,
224,CVE-2011-0983,chromium,,
225,CVE-2011-0984,chromium,,
226,CVE-2011-0985,chromium,,
228,CVE-2011-1107,chromium,,
229,CVE-2011-1108,chromium,"A function meant to handle javascript dialog cleanup was not
properly implemented and would lead to site crash. This meant
that an attacker had the means to invoke a site crash or
denial of service attack. The vulnerability also left the application
open to arbitrary code execution though no instances were reported.
","This vulnerability was caused by bad code implementation but also a lack of
testing. If unit tests had been put in place, it would have been clear that
the function was not working as designed. Since tests were not put in
place, the function stayed even after multiple different patches.
The CWE chosen is CWE-710, the developers should have followed better
coding standards and implemented testing to catch logic/functionality
errors such as this.
"
230,CVE-2011-1109,chromium,,
231,CVE-2011-1110,chromium,,
232,CVE-2011-1111,chromium,,
235,CVE-2011-1114,chromium,,
236,CVE-2011-1115,chromium,,
237,CVE-2011-1116,chromium,,
238,CVE-2011-1117,chromium,,
241,CVE-2011-1120,chromium,"The WebGL implementation in Google Chrome allowed remote attackers to cause a 
denial of service (out-of-bounds read) via unspecified vectors.  This means that the
application was not verifying the inputs to the system properly and an attacker could
have utilized this vulnerability to crash the application, or perform more advanced exploits.

This vulnerability only presented itself when ran with a specific command line flag for
handling WebGL versions and the system had certain checks that were not performed
When this flag was set.
","There were inconsistencies in the implementation of WebGL that led to the cause of the vulnerability
and they were not discovered until edge cases were tested.  This vulnerability is essentially a
buffer overflow allowed by lack of verification of inputs to the methods that utilize WebGL, so the fix
was sufficient in dealing with the problem.
"
242,CVE-2011-1121,chromium,,
243,CVE-2011-1122,chromium,The WebGL implementation in Google Chrome before 9.0.597.107 allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors.,"I believe the code in question handles rendering in the browser using OpenGL or OpenGL ES2.
In transitioning to OpenGL ES2, they initialized a buffer that was needed by OpenGL but not OpenGL ES2.
Under specific circumstances, the buffer could overflow and lead to out of bounds memory access.
"
244,CVE-2011-1123,chromium,,
245,CVE-2011-1124,chromium,,
246,CVE-2011-1125,chromium,,
247,CVE-2011-1185,chromium,,
249,CVE-2011-1187,chromium,,
250,CVE-2011-1188,chromium,,
251,CVE-2011-1189,chromium,,
252,CVE-2011-1190,chromium,,
253,CVE-2011-1191,chromium,,
254,CVE-2011-1192,chromium,,
255,CVE-2011-1193,chromium,,
256,CVE-2011-1194,chromium,,
257,CVE-2011-1195,chromium,,
259,CVE-2011-1197,chromium,,
260,CVE-2011-1198,chromium,"This vulnerability present in Google Chrome's video feature could cause a denial of service attack because it allowed remote attackers to execute arbitrary code causing an ""out-of-bounds"" error and crashing the system.This is due to code that miscounts thread numbers.","Unaccounting for threads in addition to out-of-bound errors depending on thread count. Additionally, this was a high security bug that required the team to fix it early on rather than waiting for another release."
261,CVE-2011-1199,chromium,,
262,CVE-2011-1200,chromium,,
263,CVE-2011-1201,chromium,,
264,CVE-2011-1202,chromium,,
265,CVE-2011-1203,chromium,,
266,CVE-2011-1204,chromium,,
267,CVE-2011-1285,chromium,,
268,CVE-2011-1286,chromium,,
269,CVE-2011-1291,chromium,,
270,CVE-2011-1292,chromium,,
271,CVE-2011-1293,chromium,,
272,CVE-2011-1294,chromium,,
273,CVE-2011-1295,chromium,,
274,CVE-2011-1296,chromium,,
275,CVE-2011-1300,chromium,,
276,CVE-2011-1301,chromium,,
277,CVE-2011-1302,chromium,,
278,CVE-2011-1303,chromium,,
279,CVE-2011-1304,chromium,,
453,CVE-2011-3052,chromium,,
454,CVE-2011-3053,chromium,,
284,CVE-2011-1436,chromium,,
285,CVE-2011-1437,chromium,,
286,CVE-2011-1438,chromium,,
287,CVE-2011-1439,chromium,"This vulnerability is related to incomplete sandboxing around the chrome
renderer process and chrome extensions. By tracing process ids and messages
it would be possible for an attacker to spoof parts of chrome and execute
arbitrary code.

The vulnerability did not effect Windows, but on Linux it was possible for
attackers to escape their sandbox and install their own extensions remotely.
This is Linux specific because on Linux it was possible for sandboxed processes
to interfere with each other due to requirements for chrome's crash reporting
system, breakpad. 

It is unclear in the chrome bug reporting whether the vector of attack was
directly through breakpad, but the interprocess communication with breakpad
allows for improper information disclosure of process IDs. This is what
exposes the system to spoofing.
","This vulnerability seems to be an issue of design mistakes and maintainability. It appears that the design of the renderer and breakpad functionality did not properly account for the sandboxing that was supposed to happen between processes. The intention to make the processes secure was clearly there, but the follow through was lacking.
The maintainability aspect of the mistake comes in that a large part of this vulnerability was interaction with the external libraries and dependencies, like breakpad or the Linux kernal signals. As these dependencies evolved, the code was not upkept. In the bug reports the team mentions that a lack of signal verifiability stems directly from failure to amend the code when new features were added.
This vulnerability falls squarely under the CWE-265 category - Privelege/Sandbox Issues. This vulnerability closely aligns with CWE-250 - Execution with Unnecessary Priveleges. The vulnerability was caused by unnessary exposure of process IDs, which led to conditions where a sandboxed process could unsafely execute code and break it's sandbox. Another CWE which it relates to is 267 - Privelege Defined With Unsafe Actions. In this vulnerability code used it's privleges improperly and unsafely exposed process IDs. A mitigation mentioned for 267 is to explicitly manage trust zones in the software, which appears to be the route Google took here."
288,CVE-2011-1440,chromium,,
289,CVE-2011-1441,chromium,,
290,CVE-2011-1442,chromium,,
291,CVE-2011-1443,chromium,,
292,CVE-2011-1444,chromium,,
293,CVE-2011-1445,chromium,,
294,CVE-2011-1446,chromium,,
295,CVE-2011-1447,chromium,,
296,CVE-2011-1448,chromium,,
297,CVE-2011-1449,chromium,,
298,CVE-2011-1450,chromium,,
299,CVE-2011-1451,chromium,,
300,CVE-2011-1452,chromium,,
301,CVE-2011-1454,chromium,,
302,CVE-2011-1455,chromium,,
303,CVE-2011-1456,chromium,,
305,CVE-2011-1691,chromium,,
306,CVE-2011-1793,chromium,,
307,CVE-2011-1794,chromium,,
308,CVE-2011-1795,chromium,,
309,CVE-2011-1796,chromium,,
310,CVE-2011-1798,chromium,,
311,CVE-2011-1799,chromium,,
312,CVE-2011-1800,chromium,,
313,CVE-2011-1801,chromium,,
314,CVE-2011-1804,chromium,,
315,CVE-2011-1806,chromium,,
316,CVE-2011-1807,chromium,"Heap-based buffer overflow in Google Chrome's blob URL handling code. 
The vulnerability allows remote attackers to execute arbitrary code via 
unspecified vectors that trigger an out-of-bounds write.

The fix for this vulnerability is to free memory as the very last step in the
affected function.
","The vulnerability seems to have been coding mistake. At first glance, it is not obvious that one the functions involved frees memory when called. As mentioned earlier the size of the commit was rather large (+1721 lines, -64 lines) and it affected 37 files. Perhpas the author or reviewers would have caught this if there were fewer concurrent changes to consider."
317,CVE-2011-1808,chromium,,
318,CVE-2011-1809,chromium,"The Accessibility UI attempts to use memory after it's been freed. This allows for exploitable memory corruption, denial of service, or other impact via unknown attack vectors.
","This vulnerability looks to be the result of a design oversight combined with a coding mistake. Its introduction was as part of a large change of almost 700 lines for another issue. This bug was missed, but ultimately found a day later by a fuzzer.
"
319,CVE-2011-1810,chromium,,
1499,CVE-1999-1199,httpd,,
1500,CVE-2000-0505,httpd,,
1501,CVE-2000-0913,httpd,,
1502,CVE-2000-1204,httpd,,
1503,CVE-2000-1205,httpd,,
1504,CVE-2000-1206,httpd,,
1505,CVE-2001-0729,httpd,,
1506,CVE-2001-0730,httpd,,
1507,CVE-2001-0731,httpd,,
1508,CVE-2001-0925,httpd,,
1509,CVE-2001-1342,httpd,,
1510,CVE-2002-0061,httpd,,
1540,CVE-2004-0493,httpd,"A component involved in parsing HTTP headers can be used for a remote denial of
service attack by triggering a memory leak by using long header lines with a large
amount of space or tab characters.
","This is a design mistake, as the developer did not factor in the need to have an HTTP header with certain syntax"
1511,CVE-2002-0392,httpd,"This vulnerability was caused by a lack of error-checking which could allow HTTPD
to use an invalid size during memory allocation, potentially causing a
denial-of-service (availability failure) by using all available memory for
the Apache daemon, or on 64-bit systems, an elevation of privilege attack
allowing attackers to execute arbitrary code by altering return addresses
on the system stack.
","This issue may have been mitigated if the system included additional unit test cases.
The test suite failed to include a case which evaluated this particular type of
invalid input, and it brought about a vulnerability. The issue is that this particular
avenue of attack was never brought to mind and as such, the vulnerability passed
by unnoticed.
"
1512,CVE-2002-0654,httpd,,
1513,CVE-2002-0661,httpd,"This vulnerability was a simple example of directory traversal. Strings were 
sanitized for '/', but for nothing else. This allowed attackers to user '\' 
instead to bypass sanitization. This, paired with '..' could be used to traverse 
the directory and access whatever files the attacker wishes.
","The code mistake made here was only checking for '/' when sanitizing a 
potential path traversal vulnerability. If I try to put myself into the 
minds of the developers, I imagine they, likely with mostly UNIX experience, 
simply did not consider that backslashes could be used for path traversal 
in other operating systems. Even one developer who looked at and commented 
on the code in question between the VCC and the fix did not catch the issue 
before release. This shows the importance of thoroughly testing and viewing 
your software from different perspectives, which might reveal new problems.
"
1514,CVE-2002-0839,httpd,,
1515,CVE-2002-0840,httpd,"Apache Server Side Include Cross Site Scripting Vulnerability.  
This is an input validation error.  Input request headers HTTP/1.1 ""Host"" are improperly filtered. 
It is possible to maliciously hijack web sessions and compromise servers by injecting javascript.  
The following URL will demonstrate the attack http://%3CIMG%20SRC%3D%22%22%20ONERROR%3D%22alert%28document2Ecookie%29%22%3 . 
",The mistake that were made was trusting input and not validating it
1516,CVE-2002-0843,httpd,,
1517,CVE-2002-1156,httpd,"Remote attackers can potentially view Apache source code of one of the CGI 
scripts by directing a POST request to a directory with both WebDAV and CGI 
enabled. This is a very easy vulnerability to exploit with considerable 
impact to confidentiality.
","This vulnerability was due to a fundamental flaw in the design of CGI generation
system. Fortunately this bug was addressed quickly, however it would not have 
taken very much technical knowledge to take advantage of this vulnerability and
this was a major breach to confidentiality. This could have been prevented by
having proper code reviews for any new systems and forcing teams to spend
more time on architecture design.
"
1518,CVE-2002-1592,httpd,,
1519,CVE-2002-1593,httpd,"There is a module that handles remote Web content authoring
operations. This module was looking for versioning hooks, which are versions
of the content using a pointer.
This pointer was not being checked for its existence. Therefore a null pointer
could attempted to be used and would cause the system to crash. The crash of
the system would cause a denial of service issue.
","There was a coding mistake made that caused this vulnerability. It
seemed to be a simple missed check for a null pointer. There was a general
error check when getting the value that the pointer held, but it was not
being checked if the pointer existed in the first place. It was just assumed
that the pointer existed. Maintainability-wise, this code was fixed in the
non backwards compatabile Apache release. So there was never a work around
for this bug. This no longer needs to specifically be worried about unless
something is using Apache <2.0.42
"
1520,CVE-2003-0016,httpd,,
1521,CVE-2003-0017,httpd,,
1522,CVE-2003-0020,httpd,"Certain terminals are susceptible to exploits in the form of harmful inputs.
Take, for example, escape sequences. An escape sequence starts with the ASCII
escape character and is followed by some arguments. This particular vulnerability
was caused by a failure to filter escape sequences out of the terminal when
outputting error logs. Attackers were able to intentionally inject escape
sequences into terminals, which caused certain malicious behavior.
","This vulnerability was caused by code written decades ago. In those
years, software vulnerabilities were not as well known as they are today. It's
easy to imagine that the original author of the code was simply unaware of the
possibility of escape sequence injection through error logs. The most popular
mitigation for this type of vulnerability is input validation. The recommended
mitigation for CWE-150 is specifically whitelist input validation. However,
the author who wrote the fix for this vulnerability chose to implement code
more akin to a blacklist, rather than a whitelist, which was explicitly not
recommended as a mitigation.
"
1523,CVE-2003-0083,httpd,Lack of a filter for terminal escape sequences when writing to access logs. This can cause vulnerabilities in certain circumstances where the logs are viewed with a terminal emulator that has vulnerabilites related to escape sequences.,There was a failure during sanitization to identify all special characters of importance. This is most likely a requirements error.
1524,CVE-2003-0132,httpd,,
1525,CVE-2003-0134,httpd,,
1526,CVE-2003-0189,httpd,,
1527,CVE-2003-0192,httpd,,
1528,CVE-2003-0245,httpd,,
1529,CVE-2003-0253,httpd,"MPM's are multi-processing modules which are used to bind to network ports on a 
machine, accept requests, and handle requests. This vulnerability occurs when
the MPM binds to a specific uncommonly used network port. When the C accept() 
method (accepts a connection on a socket ) is called it would return an error, 
causing a temporary denial of service. 
","A lot of factors came to allow this vulnerability to occur. The original author
wasnt confident in the comments that the code would work all of the time. Edge 
cases in the code weren't properly met. Its possible that there was confusion 
in the requirements and the task wasnt descriptive enough to who was working on 
it. Unit tests were not made to ensure it the code worked as intended. 
The mitigations for this fix on the CWE was to run fault injection tests. These
tests weren't applied before and after the fix. This is one reason for the
vulnerability to appear.
"
1530,CVE-2003-0254,httpd,,
1531,CVE-2003-0460,httpd,,
1532,CVE-2003-0542,httpd,,
1533,CVE-2003-0789,httpd,,
1534,CVE-2003-0987,httpd,,
1535,CVE-2003-0993,httpd,,
1536,CVE-2004-0113,httpd,"Accessing an SSL enabled server port with a plain HTTP request would cause a
memory leak due to a bug in the mod_ssl implementation. This vulnerability
opens up the possibility of denial of service attacks by sending many plain
HTTP requests.
","This vulnerability was due to two mistakes. A poor judgement call to avoid
having to reimplement/fix a feature that no longer worked, and an assumption
that the memory for something would eventually be freed sometime somewhere else,
instead of the proper place for it to be freed.
The fix looks proper, but the lack of testing done around the issue leads me
to believe that there are probably plenty of other similar, if not identical issues
present in the code base.
"
1537,CVE-2004-0174,httpd,Apache HTTP Servers before v2.0.48 contain a race condition when handling short lived connections. Such a connection on a rarely used socket can cause new connections to be blocked.,"Leaving dead code for too long without any sort of testing. The socket causing the issue was rarely used and had barely been touched since its initial implementation. If more maintenance or testing had been done, this issue may never have occured."
1538,CVE-2004-0488,httpd,"This issue with this CVE was a buffer overflow in Apache HTTP Server 2.0.50. By using a user with trusted CA (Certificate Authority) a remote attacker could
execute arbitrary code via a client certificate with a subject DN (Distinguished Name) which exceeds 6K in length.
",The cause of this error was most likely a design flaw. Whoever wrote the code did not account for a trusted user to exploit a buffer overflow and this lack of foresight is what led to this vulnerability.
1539,CVE-2004-0492,httpd,,
1569,CVE-2007-6421,httpd,,
1701,CVE-2003-0866,tomcat,,
1702,CVE-2005-0808,tomcat,,
1703,CVE-2005-1753,tomcat,,
1541,CVE-2004-0747,httpd,"The application fails to validate length for user-inputed strings through the form of
.httaccess and or httpd.conf config files which can, when malicious, cause a buffer overflow 
when this string is parsed, expanded, and copied into a finite buffer. This
can affect an environment variable and gives the user elevated privledges locally.
","The mistakes that were made were primarily coding mistakes as the code written worked as intended but failed
to check for boundary cases in which overflows could occur. Lots of changes were made between the VCC and the fix,
and even a patch to the fix was made. It appears there are a lot of factors not considered initially and during the
lifetime of the vulnerability, as different developers had to keep coming back to the logic. This seems like simple
miscommunication. They didn't cover all their tracks.

Looking over their solution, it appears that they opted for the implementation mitigation of CWE-119, 
as they rewrote all the logic for the function in question, adding length checks, casting, etc. to check for
extraneous inputs and to avoid harmful overflows. This fix needed one patch, and that was to handle a different 
use case of the function separate from the issue (miscommunication once again). Since then the function was moved 
to a different file but not modified. For these reasons, it appears the solution was ultimately proper.
"
1542,CVE-2004-0748,httpd,,
1543,CVE-2004-0751,httpd,"The vulnerability occurs in the char_buffer_read function in the mod_ssl module.
This allows for a segmentation fault in the char_buffer_read function when 
reverse proxying to an SSL server. A malicious SSL server can force an HTTPD child
process to crash by sending a specially-crafted response header. As a result, a 
remote attacker can cause a denial of service attack. This vulnerability is 
classified as low impact since it does not allow for execution of arbitrary code
and does not represent a significant denial of service attack. Requests can be
handled by other Apache child processes if one does crash.
","This vulnerability was a result of a coding mistake in which there is no
check to the memory consumption when running in speculative mode. A possible
mitigation is to check to make sure that the buffer is large enough to read
in data.
"
1544,CVE-2004-0786,httpd,,
1545,CVE-2004-0809,httpd,"Once the WebDAV undergoes an indirect lock, the wrong memory address is accessed and it results in a segmentation
fault that could cause a system crash.
","The fix presented did make it seem like a coding mistake as I interpret their was a typo causing the wrong memory address to be altered. But looking further in the commits
I realize the whole way the system was designed had a lot of faults so there definitely was some design flaws with the way locking worked.
"
1546,CVE-2004-0811,httpd,"This CVE involves an internal structure in Apache's HTTPD software that controls how
authentication directives (used for password protection) and access directives interact with 
each other. In this particular case, the internal structure was broken such that a request
could result in access being granted despite any configured authentication. The user who discovered this
found that if requests were ordered a certain way, this vulnerability could happen.
","It seems that there was a somewhat simple coding mistake in the way the satisfy directives were aggregated in memory from the .htaccess file. 
The vulnerability was never actually public, since it was only in a specific revision that was never publicly released.
"
1547,CVE-2004-0885,httpd,It is possible for remote clients to bypass restrictions on resources by using Apache's SSLCipherSuite directive. This can be done by using any cipher suite that is recognized by the server.,"This vulnerability occured because the developers misinterpreted how the software packages they were using would handle events.
The fault does not lie in the packages they were using, but they misunderstood how the system would react when a very specific series of events occured.
In order to prevent this from occuring again, the developers should thoroughly study their packages documentation, even to a minute detail (especially when security is a factor)."
1548,CVE-2004-0940,httpd,,
1549,CVE-2004-0942,httpd,"If a request is sent that contains tons of whitespace in an HTTP header, the
server consumes an excessive amount of CPU or memory (various sources
disagree on which it is; maybe it's both) while attempting to parse it.
","Unfortunately there appears to be no public discussion of the bug; it was
just quietly fixed 3 days after the report. Thus, it is difficult to tell
what led to the vulnerability. It appears that it was just a simple coding
mistake that was not caught by either the author or the two code reviewers.
A more notable mistake is in commit 3d5263. That commit fixed the inital
vulnerability of ""lots of whitespace."" However, it did not fully fix the
issue; instead, it changed it to ""lots of whitespace on lots of lines.""
This indicated that they were aware of the vulnerability, and *still*
didn't consider how their code could be exploited. The vulnerability could
likely have been fixed at that commit in June (rather than in November) had
the author or reviewers tried to think like a hacker and try to break their
own code.
"
1550,CVE-2004-1834,httpd,"The mod_disk_cache is a tag that sets the program to use disk based storing of cashes,
this casheing in included client headers on the users local hard disk. Users can then
potentially access this information retreiving sensitive data, which includes
authentication information.
","The initial developers did not understand either the funcionality of the tools
they were using for cacheing or the full content of the header of which they
were caching.
"
1551,CVE-2005-1268,httpd,"The vulnerability was in http's processing of certificate revocation lists in
debugging mode in its SSL module (mod_ssl).

The problem is that mod_ssl allocates a buffer of N bytes, and then tells
BIO_Read that it can read N bytes of text into the buffer. BIO_Read returns a
count of how many bytes it read, and the function uses that count to append a
NULL character to the end of the text. However, that returned value can be up
to N, which when used as an index is the n+1th index, more than the buffer can
hold. This could lead to memory corruption, or even a segmentation fault that
would bring down httpd.

Before the vulnerability-contributing commit (VCC) the buffer allocated for
reading was of size N+1, but BIO_Read was told it could only read up to N
bytes, thus there was always space for the null terminator.

Some background, certificate revocation lists are used to revoke a
certificate in case its private key has been compromised, or the keys used to
sign it.
","The mistake was a simple coding mistake made during a cleanup, the entire
portion of ssl_callback_SSLVerify_CRL that performs debug printing was
rewritten, and the developer forgot to account for the null terminator when
allocating size for the buffer and for when they copied the data into it.

The CWE entry only gives one mitigation, to use the correct size when
copying data, which is what the fix did.
"
1552,CVE-2005-2088,httpd,"This vulnerability occured when the HTTP Server was acting as an HTTP proxy.
The vulnerability allowed remote attackers to perform an attack now known as Http Request Smuggling. Essentially attackers could send an HTTP request to the proxy
with two kinds of Headers (Transfer-Encoding chunked"" header and a Content-Length header). This caused apache to process the body of the request in such way and forward it so that the 
receiveing server would process it as a seperate request. This opened a vulnerability to Cross Site Scripting. 
","This mistake seems to be a design flaw at its core, rather than a coding mistake. 
It also could have been a series of misscommunication about what was truly needed in this parrt of the project. 
The flaw (HTTP Request Smuggling) has four mitigations suggested by CWE. These are to use SSL only communication, use strict HTTP Parsing, and terminating the client after each request. 
It seems like of these three, in the inital fix back in 2005, the termanting the client mitigation was used. 
This can be avoided in the future by making sure to think about what is being forwarded when dealing with data that comes from the outside world. 
"
1553,CVE-2005-2491,httpd,,
1554,CVE-2005-2700,httpd,"When using mod_ssl (required certificates) for the web server client certifcates are not enforced
if the configuration in the virtual host specifies that client authication is optional. 
","This mistake was a design a mistake because it failed to verify client certificates during 
a certain configuration. It appears that different virtual hosts would effect each other if their verification
was set to optional. This mistake could have been prevented had the was a seperation of privledge between the hosts.
"
1555,CVE-2005-2728,httpd,"There is a non-limited byte-range weakness that can cause a denial of service attack. 
A byte-range is the buffer size of the input. If an attacker decided to fill an HTTP 
header with a large amount of information, then it can cause the memory consumption to 
increase exponentially. This memory leak can eventually lead to the crash of all servers 
with the same resource allocation. 
","In my opinion this was just a mistake of negligence. I think that the lesson
yagni really applies here. There were comments in the code talking about 
how they knew there was no range limit. So they could have just added the check
to make sure that there was an end to the input, however this vulnerability existed
due to this negligence. According to the CWE, they are mitigating it correctly, 
by implementing input validation.
"
1704,CVE-2005-1754,tomcat,,
1705,CVE-2005-2090,tomcat,,
1706,CVE-2005-3164,tomcat,,
1556,CVE-2005-2970,httpd,"What makes the Apache HTTP Server widely used is its robustness and ability to support a plethora of 
various platforms and environments. It facilitates this with the use of Multi-Process Modules (aka 
MPMs) MPMs are responsible for binding to network ports, taking in requests, and releasing children 
to handle these requests. Webmasters can choose which MPMs to load onto their server depending on 
their platform and environment.

This CVE pertains to the ""worker"" MPM. The ""worker"" MPM supports a multi-process and multi-threaded 
server. It is capable of handling a multitude of requests and can keep multiple processes open with 
each process possessing multiple threads. Failure to properly close processes leads to memory that 
is not released when it is no longer needed. Attackers can remotely take advantage of this by constantly 
aborting connections without closing them. This causes memory depletion and eventually, there is 
no longer any memory available to be reused for future connections, rendering denial of service.
","A lack of tests seems to be a mistake that may not have led to the vulnerability but more of something 
that led to the vulnerability being found later than it could have. They mention in their tests README 
that their tests only cover ""various bits"" of Apache HTTPD so what they have in the repo is not the most 
extensive. Perhaps they have exclusive tests that have not been publicized."
1557,CVE-2005-3352,httpd,"This a vulnerability that can be exploited by an attacker using cross-site scripting.
The imagemap processing module can cause the referer header to be output without being
escaped in HTML. An attacker who is able to influence the referer header will be able
to use cross-site scripting to attack.
","This vulnerability seems to be a result of design mistakes and a lack of maintainability.
They didn't consider this scenario when they were designing the project at all. The fix
for this problem isn't applicable to all aspects of the project so I would say that the 
maintainability is fairly low as well.

CWE-80 is ""Basic XSS."" It is when the software does correctly neutralize special characters.
This is the case here. The referer header is being escaped in the HTML because the special 
characters were not being handled correctly. The mitigation for this is checking each input.
All data in the request, including hidden fields, cookies, headers, the URL itself, and so 
forth must all be checked. In this particular situation they just added a conditional.

The vulnerabilities fix does not seem very maintainable. The patch doesn't apply everwhere. 
If the software is not understood, repairable or enhanceable it can't be considered maintainable.
The fact that the patch can't be applied everywhere implies that the software isn't understood
or repairable. 

Overall it seems like the fix was effective. Even though it doesn't apply everywhere they know
that they can just remove the referer where it doesn't apply. It seems like the solution is not 
ideal but it is working so it's alright. 
  
"
1558,CVE-2005-3357,httpd,"There was a component of httpd where, if the user had a specific type of a 
Secure Socket Layer (SSL) and created a custom error page, they could cause 
a denial of serivce through making the application crash. This was done by 
submitting an unsupported request to a certain type of port, which would 
cause a Null Pointer Expection.
","The main mistake with this vulnerability was the lack of handling if ssl
was null. The team never accounted for a non-ssl request to be made on a ssl
port when if ssl is not currently in use. They seem to have had it written
so that all requests that came to an ssl port would go through a ssl control
check, regardless of the state of SSL.

The fix that was implemented seems to effectively eliminate the problem as
it immediately stops the problem from arising before it has a chance to
raise an NPE. It was changed from only checking if the ssl protocol was on
to verifying that ssl was acutally in use and not null, otherwise it would
stop, as it was no longer relevant.
"
1559,CVE-2006-3747,httpd,"This was a vulnerability that affected people who used Apache HTTPD versions 1.3 from 1.3.28 and 2.0.46.
This vulnerability allowed malicious users to perform remote attacks that cause denial of service or random code executions. This vulnerability makes use of a off-by-one error which is when data being added to a stack overwrites an extra bit. This situation was only able to happen when certain functions of the rewrite module was used with Lightweight Directory Access Protocol (LDAP) urls. The rewrite module is capable of manipulating urls so that requests from one url can be sent to another url.
When data overflows past its intended boundaries, it allows for the next section of code in the stack to execute or it could even crash the whole program.","It seems like the fault was in the code. The fix was a simple change by decreasing a variable in an if statement by 1. Considering that the change was a simple fix of just editing one line of code, the cause was likely due to accidently overlooking a size limit when the code was made. Vulnerabilities that have to do with size boundaries are easily overlooked which is why I think additional boundary checking should have been done. Boundary tests should always check for extreme cases like maximum inputs."
1560,CVE-2006-3918,httpd,,
1561,CVE-2006-5752,httpd,"when a module in apache is activated on a public page that shows 
diagnostic data on server such as number of requests and cpu usage,
an attack would be able to inject malicious html code due to the
browser detecting a charset instead of specifying one.
","Mistake The team did not give existing functionality a passover once new technologies are implemented, in this case being charset detection.
Lessons we could Learn Emerging technology can and will expose vulnerabilities in existing code.
Notes Looking through previous iterations of the code, specifying a charset seemed to not be on any of the teams' minds. Originally, I believe it was not an oversight from the team."
1562,CVE-2007-1862,httpd,"When using HTTP for communication, headers are included that contain information about the data being sent. Due to changes in memory allocation, when Apache would copy header data for a response header it sometimes tried to copy from a location in memory that had already been cleared. New data could have been put in the old location, and this data could be sensitive. This would result in any data a user is entering or viewing potentially getting leaked to the header, which would not necessarily be secure.","It seems that when they began using the APR memory pool they made
an incorrect assumption about how long their data would remain in its
table. While automated testing may have eventually caught it, it's
understandable that a few manual tests might have missed this (as nothing
appears to be wrong if you get lucky and nothing else takes up the freed
location in memory). Better understanding their tools and using automated
tests could have helped catch or prevent this. CWE-825 lists mitigations
that wouldn't be useful in the situation: use a language that manages 
memory automatically and set pointers to null after freeing. They
weren't in a position to stop using C code and, as the CWE site points 
out, complex data structures (like the new APR memory pool) reduces the
effectiveness of setting pointers to null.
"
1563,CVE-2007-1863,httpd,,
1564,CVE-2007-3304,httpd,,
1565,CVE-2007-3847,httpd,"In HTTPD, which is an open source web server for unix-like systems, remote
servers can cause denial of service when using threaded MPM by sending a
malicious date header that triggers buffer over-read. Threaded MPM refers to
using multi-processing modules that handle tasks such as binding network
ports, and accepting requests. The triggered buffer over-read refers to when
the code attempts to read adjacent memory beyond the current buffer, where
sensitive data could be stored that is not supposed to be accessed.
","The date input causing the issue seems to have been trusted without doing
all of the proper validation and checking before using it. As mentioned
earlier I believe this vulnerability could have been avoided if boundary
checks were performed. To prevent vulnerabilities of this kind in the
future, each component is supposed to distrust outside inputs and perform
the necessary validations to reject bad inputs.
"
1566,CVE-2007-5000,httpd,"An attacker could inject malicious HTML/Javascript code into the input of the image
mapping function of this program in order to compromise the integrity of the system.
This vulnerability works if the module is enabled and the imagemap files are publicly
available.
","I think that it was a coding mistake since, when the code was first written,
there wasn't any sort of string escaping to mitigate XSS attacks, even though there
should have been from the start. I think that the mitigation looks proper since it
follows the input validation mitigation on the CWE entry.
"
1567,CVE-2007-6388,httpd,"Where the server-status page was enabled, a cross-site scripting vulnerability
was possible because where only numbers should have been viable input, code
could be injected.
","This is an implementation mistake. A case was not added to input to verify
that the input was an expected value. The fix looks proper. It seems like
an obvious thing to look and test for now. Hopefully the whole system is
under more scrutiny now, I imagine it is since the fixing commit was
created 11 years ago.
"
1568,CVE-2007-6420,httpd,"This was a cross-site request forgery (CSRF) vulnerability in the balancer-manager in
mod_proxy_balancer file for Apache HTTP Server 2.2.x allows remote attackers to
gain privileges via unspecified vectors.
The vulnerability is due to the insufficient authentication checks on requests to the
balancer-manager web interface.  An attacker could exploit the vulnerability by
convincing a user to follow a link to a malicious website.  When visited, the site could
send malicious HTTP requests to the balancer-manager interface on behalf of the user.
","This vulnerability was seen as medium severity in that if exploited, it
could cause a denial of services. However, I did not find records of the
vulnerability being exploited. There was a mentions of the fact that the
malicious user would need to be authenticated to perform and exploit, this
is probably why the vulnerability was not exploited since it was less likely
happen at the time. I also saw some documents that stted there was no need for
authentication for the bug to be exploited so I am not entirely sure what the
actual case was. I also found that the fix was not placed urgently but
rather addressed in a later release. Looking at the logs, it seemed like not
very much was done in order to combat the bug early on, the fix was placed in
2008.
This flaw just shows me that code needs to be tested extensively before being
released. A lot of other code bases relied on this particular servlet and were
in turn ""affected"". I assume some of them may have had to place ""quick fixes""
of their own before adopting the fixed version.
"
1570,CVE-2007-6422,httpd,"On sites with a specific setting (mod_proxy_balancer) enabled remote users could
craft a request that would cause the process handling it to crash. If the server
for the site was also multi-threaded this would lead to a denial of service attack
on the site. 
","They weren't correctly checking possible requests that could come into their
server through a large chunk of data. They didn't sanitize the input allowing
users to take down the server. They also just didn't think of the outliers in the
situation. Both having the mod_proxy_balancer and multi-threaded servers on were 
not the default so they didn't build their security around this. That is also why
the CVE was considered only low priority because not many sites had this combo. 
The solution was to put a check for the correct balancer name which is a fix for this
specific issue but a better fix may be to sanitize their inputs in the first place and not
just add to the if statement every time an issue arises.
"
1571,CVE-2008-0005,httpd,"Upon sending HTML for web pages, the software did not specify a text encoding.

Because browsers can auto-detect encoding, this meant any encode could effectively
be used. This includes UTF-7, which uses + and - characters to deliminate characters
with special meanings in order to construct certain other characters. < and >
characters may therefore be written in UTF-7 without using those actual characters.

This means anyone who knew their way around UTF-7 could create cross-site script
to run arbitrary JavaScript code.
","This appears to have been an oversight at the inception of specifying content types that was
not addressed until someone proved it to be a vulnerability. This is true even though several
other commits reworked the way content types were set.

The mitigation taken is quite straighforward. The charset was explicitly specified as ISO-8859-1.
This prevents any other encoding from being used, and it may then be sanitized much more effectively.
"
1572,CVE-2008-0456,httpd,"If HTTPD is serving static files, and those static files have extraneous CRLFs,
they can inject headers into the HTTP response. Redhat says this isn't an issue
since you shouldn't have nasty files in the first place.
It also seems like HTTPD actually errors out (it gives either a 406 or 300),
so this vulnerability can't modify seemingly fine responses, just cause errors.
",Mainly lack of review and automated testing. Need smaller commits that are reviewed better.
1573,CVE-2008-2364,httpd,"A flaw was discovered when a server would have to handle excessive interim responses. In a situation where a user who is using the proxy is tricked into visiting a 
malicious web-server, the proxy would need to use stack or heap memory. If this was continually done
it could exhaust stack/heap space and crash the server.
","This is an oversight in design and probably occured simply because it was never discussed. Somewhere in the planning phase there must have been a diagram depicting the interaction between the proxy and the web server. There was no consideration of how the system could be harmed given that the proxy was used to communicate with a malicious web server.
This vulnerability falls under the Availability category in the CIA model because it could be used to exhaust stack/heap space and create a DOS attack. The fix for this vulnerability was a simple flag which checked the amount of interim responses done by the forward proxy."
1574,CVE-2008-2939,httpd,"There was a cross site scripting vulnerability which allowed attackers to
inject javascript or html. This was via a wildcard in the last pathname of a FTP URI.
The vulnerabilities were in the proxy_ftp.c and mod_proxy_ftp.c files.
","The mistake that was made was a coding mistake. The design or developers did
not think to validate input coming from requests from Apace HTTP servers. All an attacker
needed to do is compose one wildcard charater in the last directory component of the path
to use this vunerability as an exploit. Always distrust input and do you own validation.
"
1575,CVE-2009-0023,httpd,,
1576,CVE-2009-1191,httpd,Http requests containing a non-zero content-length header value and not containing a body can cause apache to serve content that was intended for another user through the use of a second malformed http request.,"This vulnerability was caused by a coding mistake. If an incomplete request was received which contained a non-zero content-length header field, the connection was kept alive and reused instead of being closed."
1577,CVE-2009-1195,httpd,"The Options=IncludesNOEXEC in configuration for Apache HTTP Server is not handled
properly on the AllowOverride directive. By default the code allowed a local user
to execute code, and the language used in naming this option was counter intuitive.
The vulnerability led to a local user being able to execute code that could escalate
their privileges and help further attack the system.
","This was a design mistake, since the system wasn't defaulting to secure
options but rather had a configuration option to keep local users from
executing file inputs. The solution they opted for was to add code to
AllowOverride so that it does not permit Includes with exec= enabled to
be configured in an c file so user can't input code to execute
in those files. They also made semantic changes so that the OPT_INCLUDES
doesn't default to with exec (using with instead of without makes it
more clear). I think the most important thing here was the semantic change
as it honors security by default and helps avoid user error. 
"
1578,CVE-2009-1890,httpd,,
1579,CVE-2009-1891,httpd,,
1580,CVE-2009-1955,httpd,,
1581,CVE-2009-1956,httpd,,
1582,CVE-2009-2412,httpd,,
1583,CVE-2009-2699,httpd,,
1584,CVE-2009-3094,httpd,,
1585,CVE-2009-3095,httpd,"This vulnerability allowed authorized attacks to send commands to an
FTP server due to inadequate input validation.

The attack involved sending special characters to the server that
would cause unintended behavior when parsed.

This allowed attacks to bypass access restrictions for target FTP
servers as they were capable of executing arbitrary commands.
","The mistake that lead to this vulnerability is a simple coding mistake.
Specifically, a lapse in requirements for input validation.
"
1586,CVE-2009-3560,httpd,,
1587,CVE-2009-3720,httpd,,
1588,CVE-2010-0010,httpd,,
1589,CVE-2010-0408,httpd,,
1590,CVE-2010-0425,httpd,"The Apache mod_isapi (module that implements the internet server extension API. Allows Internet Server extensions) module can be forced to unload a specific library before the processing of a request is complete, resulting in memory corruption. This vulnerability may allow a remote attacker to execute arbitrary code.","This vulnerability was due to the developers overlooking it and not quite understanding what was happening in a piece of their code. The fix for the vulnerability was simply deleting 2 lines of code which unloaded the ISAPI.dll module in the middle of a request which created oprhaned callback pointers. Based on this fix it seems that the unloading of the ISAPI.dll method call at that point in the code was completely unecessary as the system seemed to work completely fine without it. The biggest takeaway from this vulnerability is, it is important to not add unnecessary pieces of code to a system and understand what unintended consequences adding additional functionality can have on the system."
1591,CVE-2010-0434,httpd,,
1592,CVE-2010-1452,httpd,"When the caching or WebDAV modules are enabled in a specific configuration, a process
crash can be triggered by sending a request without a path component. This is caused
by an invalid read which assumes a path was present in the request.
","This issue seems attributable to a coding mistake. The affected areas
did not consider the case in which a path segment could not be parsed from
a request.
"
1621,CVE-2014-0231,httpd,"A CGI (Common Gateway Interface) is a protocol used by web servers that runs command-line interface scripts in response to client requests. Apache HTTP Server has a module ""mod_cgid"" which is responsible for running CGI scripts.
CVE-2014-0231 was a vulnerability in Apache HTTP Server's mod_cgid module where users could create a denial of service attack by causing the process which ran these scripts to hang indefinitely. mod_cgid did not have any timeout feature. If an attacker found a request that caused one of a server's CGI scripts hosted in mod_cgid to halt, this would deny service to other users of the server's CGI scripts.","This is a particularly interesting case of finding a way to make the system fail gracefully. The issue - the process responsible for running CGI scripts hanging indefinitely - is an issue that occurs when a script fails to handle certain inputs properly. The failure to anticipate and handle this special case is what left open the opportunity for a DOS attack on the system.
Lack of unit testing is probably the most clear mistake here. The unit test suite for the project as a whole is relatively sparse, and an issue like this (a rare failure case) can be difficult to anticipate without thorough testing."
1707,CVE-2005-3510,tomcat,,
1593,CVE-2010-1623,httpd,"When HTTPD processes non-SSL (unencrypted) traffic, the way they process that
data was flawed that allowed for memory to fill up. With carefully timed
packets, an attacker could make the HTTPD process fill up on memory and cause
a denial of service. The logic has to do with how timeout policies are
enforced across core multiple modules in HTTPD.

The subsystem, mod_reqtimeout, is designed to be ""a convenient way to set
timeouts and minimum data rates for receiving requests. Should a timeout occur
or a data rate be to low, the corresponding connection will be closed by the
server"" (from https://httpd.apache.org/docs/trunk/mod/mod_reqtimeout.html).
It is a filtering module, which works with HTTPD's ""bucket brigade"" model of
accepting and parsing network data into the HTTPD quickly.

In this vulnerability, the policy was loose by allowing 30 seconds to ""linger""
when a connection was scheduled for closing. This gives ample time for
attackers to send crafted packets and fill up RAM. Instead, the policy was
changed to 2 seconds, along with a big rewrite of how the policies are
enforced.
","The fix to this vulnerability was a signifiant rewrite of the original
functionality. The issue was not a small coding mistake, but a poor algorithm
choice and poor defaults. More integration testing would have helped with this,
especially with a memory management tool like Valgrind.
"
1594,CVE-2010-2068,httpd,"This vulnerability is an information disclosure to unintended recipients. A timeout detection flaw can allow a response
to be sent to a request belonging to a different user. This timeout flaw is where apache is connected with
a tomcat server and apache is configured to timeout before tomcat, putting the connection in a pool where it can be mistakenly given to another user.
","This was an information disclosure vulnerability. The vcc code at low level did not have any protection from returning a response to an incorrect user. A lack of testing was also a mistake for this vulnerability. Most of the code had tests except for the proxy subsystem. 
A lot of changes were made in between the fix and vcc without testing which was likely the reason that the vulnerability did not get caught sooner.
"
1595,CVE-2010-2791,httpd,,
1596,CVE-2011-0419,httpd,,
1597,CVE-2011-3192,httpd,"This vulnerability involves denial of service by resource exhaustion leading to a denial of service
due to improper handling of overlapping byte ranges in http requests. The eventual fix, nearly 7 years later,
involved reducing the memory used by these requests, such that byteranges were 
validated to ensure that they were reasonable in the context of the request.
","The main mistake here seems to be a result of both coding errors and design
problems. The ability to specify overlapping byteranges in a header allows for countless
exhaustion issues. Further, lacking proper validation and restriction of inputs
opens the door for major issues that could impact countless sites relying on httpd.
"
1598,CVE-2011-3348,httpd,,
1599,CVE-2011-3368,httpd,,
1600,CVE-2011-3607,httpd,,
1601,CVE-2011-4317,httpd,,
1602,CVE-2012-0021,httpd,,
1603,CVE-2012-0031,httpd,"Local users can cause a denial of service attack by modifying a certain field
within a scoreboard shared memory segment. Resulting in an invalid free call.
","This seems like a coding mistake. The CWE entry for this vulnerability
doesn't list mitigations.
"
1604,CVE-2012-0053,httpd,,
1605,CVE-2012-0883,httpd,,
1606,CVE-2012-2687,httpd,,
1607,CVE-2012-3499,httpd,,
1608,CVE-2012-3502,httpd,,
1609,CVE-2012-4557,httpd,,
1610,CVE-2012-4558,httpd,,
1611,CVE-2013-1862,httpd,,
1612,CVE-2013-1896,httpd,"The http protocol has grown over the years, and has gained multiple extentions
to serve different purposes.  One such extention is WebDAV (Web Distributed
Authoring and Versioning) which extends the http protocol to add request methdos
such as COPY, MOVE, etc. to allow for remotely interacting with a servers
resources or documents.  One place WebDAV is used is in version control over
HTTP (as opposed to SSH).  Appache HTTPD is one of the few web servers that
have native support for WebDAV.
One thing that must be ensured when implementing WebDAV is that any URIs
being modified in the context of WebDAV must be on a server that implements
WebDAV.  Depending on your implementation, forgetting to check for WebDAV at
the URI you are trying to access can cause issues.  This could be used by an
attacker to specifically try to make a request involving URI that does not have
WebDAV and crash the server.
","Although at it's core, the patch for this was just originally a coding mistake
placed in the wrong function, overall, this is an architectural design mistake.
The patch for this was simply adding a single if statement to check a specific
case, but there was a real possibility that more places to include URIs could
have been added in the future.  This means that all URIs that are being used to
make WebDAV requests should be checked, not just this one.  A much stronger
architecture would be one that has a subsystem dedicated to making WebDAV requests
that does not trust input from the subsystem that handles WebDAV requests.
"
1613,CVE-2013-2249,httpd,"A mod_session_dbd had a session fixation flaw, and this vulnerability caused
by incorrectly handling user sessions in a web application. A user's session
is usually tracked by a cookie, which is assigned when the user visits the
page with the web application for the first time. This flaw in mod_session_dbd
caused it to proceed with save operations for a session without considering
the dirty flag and the requirement for a new session ID.
","The major mistake that led to this vulnerability was a design error. When executed save operations for a session, without considered the dirty flag and invalidated any exsit session identifier would gave an attacker the opportunity to steal authenticated sessions."
1614,CVE-2013-4352,httpd,,
1615,CVE-2013-5704,httpd,,
1616,CVE-2013-6438,httpd,,
1617,CVE-2014-0098,httpd,"An attacker would be able to send a specific truncated cookie that would cause
a crash. This would only open a vector for a denial of service in a threaded
MPM. This issue was in one of the cookie logging files that improperly
truncated the cookies.
","While this seems like an edge case, mistakes were made in not implementing a
failsafe. The code that ended up fixing the bug were if statements, ensuring
that a cookie's name and value matched their addresses, and then properly
performed the truncation in a way that would not enable a denial of service
attack. These types of vulnerabilities are very difficult to spot, as it is
often one specific string that may break it; something that likely would not
have been thought of by the developer(s) testing the code.
"
1618,CVE-2014-0117,httpd,"The HTTP Connection headers is left blank like 'Connection ;' so that the parser
will get an empty string and then it will skip over the semi colon and place it as the value of
the variable connection. This makes it so when the code for the proxy token is used it uses logic 
based on whitespaces and deliniated by commas and semi-colons. This is a vulnerability because
they use an inherent assumption that the input being passed is already sanitized and compatible.
","I think there was a simple error of not thorough enough tests. Having an empty
Connection Header does not seem like an over-complicated input to test. I understand
it was a more niche situation as it was while use of the proxy module, but proxy servers themselves are not
niche at all. I think they just need to extend their unit tests to test data passing between modules as well.
"
1619,CVE-2014-0118,httpd,,
1620,CVE-2014-0226,httpd,,
1694,CVE-2002-2007,tomcat,,
1695,CVE-2002-2008,tomcat,,
1622,CVE-2014-3523,httpd,"A flaw was found in the WinWT MPM in httpd 2.4.1 to 2.4.9 when using the default AcceptFilter for that platform. Because a buffer was not cleared after being potentially filled, an attacker may send requests that can leak memory and cause a denial of service.","The only mistake that was made for this vulnerability was a coding mistake. The developers did not remember to free up a buffer after it was full in a particular area of code, which led to memory leaks and denial of service. This vulnerability was fixed with a simple if statement that, when entered, freed the buffer. This followed the mitigation of ensuring protocols have specific limits of scale placed on them."
1623,CVE-2014-3581,httpd,"There was a flaw in how a module handled Content-Type headers. The service would crash
and lead to a denial of service attack if attackers supplied an empty Content-Type 
header, since it would be a NULL pointer dereference and lead to an application crash.
","The mistake that lead to this vulnerability was most likely improper testing, 
and a lack of maintainability. Since the start of the project, the code that 
was involved in the vulnerability was present, and it had not been caught for 
around 10 years.Content-Type headers were assumed to contain something, and
having it deferenced in the code at a certain point lead to this vulnerability.
"
1624,CVE-2014-3583,httpd,"Apache Description - An out-of-bounds memory read was found in mod_proxy_fcgi. 
A malicious FastCGI server could send a carefully crafted response which could lead
to a crash when reading past the end of a heap memory or stack buffer. This issue
affects version 2.4.10 only.

When an Apache HTTPD server is sent a long HTTP header from a FastCGI server, there is
a potential for a buffer overflow error. Apache HTTPD will read long headers and end up
reading memory past the end of the header that was sent in. This caused denial of service
issues due to the potential for segmentation faults from buffer overflow.

FastCGI is a protocol (similar to how HTTP is a protocol) that allows servers to execute
CGI (Common Gateway Interface) scripts on a web server. CGI is used as middleware to 
allow servers to pass data to/from an application or web server. For example, CGI could be
used to send data between a database and web server.
","This was a coding mistake, and to an extent, a design mistake. When Apache was
initially writing this function, they assumed that any header coming in from another
server would include the buffer end character, '\0'. This null character is the only
mechanism that stops C from reading memory past the end of the string. 

In C, every string allocated includes a null character at the end. However, the
vulnerability specifically relates to large headers coming specficially from a remote
FastCGI server. One good principal in secure coding is to not trust an input's validity
if it is coming from outside a trust boundary. In this case, the Apache developers
placed too much trust on the assumption that any header would include a null character.
It lead to them writing code that relied solely on the existence of an end character in input
to prevent overflow errors. The developers should have not trusted the validity of 
outside input and placed checks to prevent memory from being read

The fix is extremely simple - check the length of an incoming string and read only up to the 
length of that string. This is a good fix, since there isn't a reliance on outside input - the
headers are checked after they are received. Another potential fix Apache could consider
implementing is to simply limit the length of the headers, since this vulnerability specifically
appears on headers over a certain length. The drawback of this approach is that it may be temporary.
Because HTTP standards are always changing, longer headers may be the norm in the future and such
a fix will eventually have to be re-fixed properly in the future.

The mistake can also be considered a design mistake. It was interesting to see that the vulnerability
affected this module specifically. HTTP headers are not unique to FastCGI - they come from everywhere.
The question becomes how many other modules are doing their own HTTP header parsing, and why would
only this module specifically be affected? It may be prudent for Apache to consider a single HTTP
header parser so that the entire code base can reference one uniform parser.
"
1625,CVE-2014-8109,httpd,"The Apache http server did not support a configuration that contained a Lua 
authorization provider that was used twice with different arguments for a different
context. This would allow attackers to bypass intended access restrictions under 
specific circumstances with multiple require arguments. By separating the auth
provider from the arguments that are passed with it the issue is avoided.
","This is a common mistake of not accounting for a specific case of input data
with the same name as another input causing issues of acquisition. These 
are vulnerabilities that are hopefully thought of when considering defensive
coding practices and inputs like these are good canidates for unit cases to 
catch potential edge cases like these.
"
1626,CVE-2015-0228,httpd,,
1627,CVE-2015-0253,httpd,,
1628,CVE-2015-3183,httpd,"The HTTP server improperly parsed headers which allowed remote 
attackers the ability to execute a HTTP request smuggling attack.
","From what I can tell the issue didn't directly stem from this code, this is
just where the solution to something else happened to be implemented. 
"
1629,CVE-2015-3185,httpd,,
1630,CVE-2016-0736,httpd,,
1631,CVE-2016-1546,httpd,"This vulnerability effects The Apache HTTP Server 2.4.17 and 2.4.18.
It only is relevant when mod_http2 is enabled. The issue is that no limits on
simultaneous stream workers are put into place, meaning that any client that can
craft a request that results in high numbers of stream workers, can cause a denial
of service for stream processing by starving the system of resources.
","Lack of testing and review. The vulnerability was introduces to add a feature, but no checks were
put in place (that I could see) to make sure that new features don't introduce new bugs.
"
1632,CVE-2016-2161,httpd,"A remote attacker could write malicious input to a data stream that would cause
the server to crash. Once the server is crashed, subsequently valid requests will continue to crash
the server.
","This vulnerability is the result of a coding mistake. More specifically, a missed edge case
that can be used maliciously for a dos attack. The vulnerability was created in a single commit but
the allocation functions had been rewritten a few times previously. It does not appear that prior functions
covered this edge case either.

This vulnerability falls under the Availability category in the CIA model and is classified as a High threat
due to it's ability to bring down the system. The fix appeals to an input validation strategy and distrusts the memory allocation of another function.
It does so by stepping through the memory to ensure that adequate space exists in the shared memory.
"
1633,CVE-2016-4975,httpd,,
1634,CVE-2016-4979,httpd,,
1635,CVE-2016-5387,httpd,httpd sets the environment variable HTTP_PROXY based on the proxy field in the received http request header. This is done to pass the proxy information to CGI scripts. This can be abused to execute a MITM attack or to cause httpd to send requests to an arbitrary server.,"This was a design mistake. Environment variables probably shouldn't be used to pass the proxy information to CGI scripts. This is especially true if the proxy information is provided by any remote, unauthenticated user."
1636,CVE-2016-8740,httpd,"A specific module, the modhttp2 module did not offer data length restriction for the request headers. This means that malicious sources could potentially send through large amounts of information, and block out threads, stopping others from being able to use it. This could lead to a denial of service attack.","One of the biggest mistake is the lack of integration/unit tests that verify for strange inputs and weird situations. In addition, better coding practices like quality assurance testing would go a long way in resolving this issue. Overall better design to verify input size could have assisted."
1637,CVE-2016-8743,httpd,"Uncommon whitespace patterns are accepted in requests and included in responses.

When the server is working with backends, proxies, or other servers that do not
properly handle this whitespace or have special meaning for such whitespace,
multiple responses could be generated. This can cause some backends to wrongly
associate one response with a different request, causing cache pollution or more
serious problems down the chain.
","This issue is primarily a design flaw in the original request parser.
Rather than simply ignore any combination of whitespace, it should have
been validating that specific required and common patterns were used so that
collaborative components not controlled by the project could accept this input
without issue.

The vulnerability is easily fixed by validating that the input meets the whitespace
criteria and in some cases sanitizing it for other components/servers. That is essentially
what was done in this case, except that configuration modes were added so that
strict validation takes place by default, but an unsafe mode preserves the old behavior.

Between the time the parser was originally introduced to the repository in 1999 and when
the fix was applied in 2016, the parsing logic remained largely the same, with the exception
of moving it back and forth between a few modules. (This is why no interesting commits are listed).
"
1638,CVE-2017-15710,httpd,,
1639,CVE-2017-15715,httpd,,
1640,CVE-2017-3167,httpd,,
1641,CVE-2017-3169,httpd,,
1642,CVE-2017-7659,httpd,"In HTTPD, an open source web server for Unix-like systems, HTTP/2 requests
could be crafted in a way that could cause mod_http2 module to dereference
a NULL pointer and crash the server process. The code causing the
vulnerability was attempting to dereference the pointer before checking
it and ensuring it is not NULL, so a request with a NULL pointer crashed the
process. HTTP/2 requests refer to HTTP/2.0 which is a revision of the HTTP
network protocol.
","I am sure its not as simple as it seems but I think replacing a module that
was being reused could be a mistake. I am sure the development team had
valid reasons at the time for doing so but I cant help but wonder why they
felt the need to do it. The replaced module did not seem to belong to a
third party which meant they had control over it. In the future, to avoid
this kind of vulnerability, outside input must always be validated before
inner components put it to use.
"
1696,CVE-2002-2009,tomcat,,
1697,CVE-2003-0042,tomcat,,
1698,CVE-2003-0043,tomcat,,
1699,CVE-2003-0044,tomcat,,
1700,CVE-2003-0045,tomcat,,
1643,CVE-2017-7668,httpd,"When parsing HTTP request headers, the ap_find_token() function in the Apache
HTTPD server would overrun the string buffer when searching for a specific
token. If line being searched contained a NUL (\0) character in the last
token of the string, then the function would continue to read past the end of
the string resulting in a buffer overrun.
This occurs because of how the ap_find_token() function searched for the
beginning of a token. If a NUL character was found, the function would skip
past it and continue processing the memory beyond the NUL character.
","A concious, documented decision was made to not check for NUL characters
when searching for the start of a token in the input string. When working
in C, where string parsing is a ripe target for buffer overruns, this
should have raised some alarms.
Normal HTTP headers should never contain NUL characters, so when one shows
up somewhere it isn't expected, the server should treat it as a malformed
request and stop attempting to process it normally. Workarounds should not
be implemented in case a NUL character is encountered in the middle of a
string, because that's not something that should be happening in the first
place. Additionally, for software as widespread as Apache HTTPD,
implementing non-standard behavior only encourages nonconformity to the
established standards.
"
1644,CVE-2017-7679,httpd,"This CVE describes a vulnerability related to the mod_mime module, which itself
is responsible for associating meta-data to a file requested from the server.
Meta-data includes behaviors and attributes, such as the language, encoding,
character set or mime-type of the file.

The vulnerability states that this module is able to ""read one byte past the
end of a buffer when sending a malicious Content-Type response header"". In other
words, if a user sends an HTTP request with some unexpected Content-Type field,
the Apache server will attempt to read up to one byte of additional memory next
to the content requested by the user.

This leads to a buffer overread error, in the mod_mime module which (if not
handled properly) has the potential to impact availability of the server by
crashing it (DOS), or violating integrity if the data is read without error
and returned to the user with potentially sensitive data. Currently, all
documentation points to potential denial-of-services as being the biggest
threat.
","After researching the purpose of the module and looking at the
function where the vulnerability exists in the greater context of its file,
I'm fairly confident that a simple coding mistake led to this vulnerability.

At the end of the day, the vulnerability was fixed simply by removing one
null check and adding another null check in.
"
1645,CVE-2017-9788,httpd,,
1646,CVE-2017-9789,httpd,,
1647,CVE-2017-9798,httpd,"Users are able to corrupt the global methods table by setting the Limit
directive in their .htaccess file or if their httpd.conf has unexpected configurations.
This results in unpredictable behavior and allows attackers to read data from
process memory that they do not have access to. An attacker can deliberately trigger
the  vulnerability and attempt to access data from freed memory.

A good explanation can be found at: https://blog.fuzzing-project.org/60-Optionsbleed-HTTP-OPTIONS-method-can-leak-Apaches-server-memory.html
","This vulnerability was caused by a design error. The CWE suggests choosing
a language that provides automatic memory managaement or freeign pointers 
and setting them to null during implementation. These were not applied in the 
fix. Instead the fix sought to prevent .htaccess exploits by only allowing 
methods that were registered at initialization.
"
1648,CVE-2018-11763,httpd,,
1649,CVE-2018-1283,httpd,,
1650,CVE-2018-1301,httpd,,
1651,CVE-2018-1302,httpd,,
1652,CVE-2018-1303,httpd,,
1653,CVE-2018-1312,httpd,,
1654,CVE-2018-1333,httpd,,
1655,CVE-2018-17189,httpd,,
1656,CVE-2018-17199,httpd,,
1657,CVE-2018-8011,httpd,,
1658,CVE-2019-0190,httpd,,
1659,CVE-2019-0196,httpd,,
1660,CVE-2019-0197,httpd,,
1661,CVE-2019-0211,httpd,,
1662,CVE-2019-0215,httpd,,
1663,CVE-2019-0217,httpd,,
1664,CVE-2019-0220,httpd,,
1665,CVE-2019-10081,httpd,,
1666,CVE-2019-10082,httpd,,
1667,CVE-2019-10092,httpd,,
1668,CVE-2019-10097,httpd,,
1669,CVE-2019-10098,httpd,,
1670,CVE-2019-9517,httpd,,
1671,CVE-2020-11984,httpd,,
1672,CVE-2020-11985,httpd,,
1673,CVE-2020-11993,httpd,,
1674,CVE-2020-1927,httpd,,
1675,CVE-2020-1934,httpd,,
1676,CVE-2020-9490,httpd,,
1677,CVE-2000-0672,tomcat,,
1678,CVE-2000-0759,tomcat,,
1679,CVE-2000-0760,tomcat,,
1680,CVE-2000-1210,tomcat,,
1681,CVE-2001-0590,tomcat,,
1682,CVE-2001-0829,tomcat,,
1683,CVE-2001-0917,tomcat,,
1684,CVE-2001-1563,tomcat,,
1685,CVE-2002-0493,tomcat,,
1686,CVE-2002-0682,tomcat,,
1687,CVE-2002-0935,tomcat,,
1688,CVE-2002-0936,tomcat,,
1689,CVE-2002-1148,tomcat,,
1690,CVE-2002-1394,tomcat,,
1691,CVE-2002-1567,tomcat,,
1692,CVE-2002-1895,tomcat,,
1693,CVE-2002-2006,tomcat,,
1708,CVE-2005-4703,tomcat,,
1709,CVE-2005-4836,tomcat,,
1710,CVE-2005-4838,tomcat,,
1711,CVE-2006-3835,tomcat,,
1712,CVE-2006-7195,tomcat,,
1713,CVE-2006-7196,tomcat,,
1714,CVE-2007-0450,tomcat,,
1715,CVE-2007-1355,tomcat,,
1716,CVE-2007-1358,tomcat,,
1717,CVE-2007-1858,tomcat,,
1718,CVE-2007-1860,tomcat,,
1719,CVE-2007-2449,tomcat,,
1720,CVE-2007-2450,tomcat,,
1721,CVE-2007-3382,tomcat,,
1722,CVE-2007-3383,tomcat,,
1723,CVE-2007-3384,tomcat,,
1724,CVE-2007-3385,tomcat,,
1725,CVE-2007-3386,tomcat,,
1726,CVE-2007-5333,tomcat,,
1727,CVE-2007-5342,tomcat,,
1728,CVE-2007-5461,tomcat,,
1729,CVE-2007-6286,tomcat,,
1730,CVE-2008-0002,tomcat,,
1731,CVE-2008-0128,tomcat,,
1732,CVE-2008-1232,tomcat,,
1733,CVE-2008-1947,tomcat,,
1734,CVE-2008-2370,tomcat,,
1735,CVE-2008-2938,tomcat,,
1736,CVE-2008-3271,tomcat,,
1737,CVE-2008-4308,tomcat,,
1738,CVE-2008-5515,tomcat,,
1739,CVE-2009-0033,tomcat,,
1740,CVE-2009-0580,tomcat,,
1741,CVE-2009-0781,tomcat,,
1742,CVE-2009-0783,tomcat,,
1743,CVE-2009-2693,tomcat,"The vulnerability allows for an attacker to create, modify, or delete files using a specially crafted Web Application Resource (WAR) file. Tomcat fails to check for directory traversal commands in directory paths using ../ and that is what the attacker uses to craft the WAR file. When the WAR file is deployed on the Tomcat server, the directory traversal command can be used to modify files outside of the web root directory. The files can be created, modified, or deleted. Secure information from the web server could be moved out of sccope, or a key file for the server could be deleted which could cause a denial of service.","The mistake that was made here was simple. The developer neglected to consider that someone might try to navigate outside of the root directory and never put in test cases and exceptions for when that happens. Since there was a lack of unit testing, the directory traversal was never tested for and stayed in the code for a while unnoticed. This isn't exactly a mistake but more of an oversight on the developers part. The vulnerability was fixed by adding checks for ""../"" for any path that was being constructed."
1744,CVE-2009-2901,tomcat,"By default, Tomcat automatically deploys any directories placed in a host's appBase.
This behaviour is controlled by the autoDeploy attribute of a host, which defaults to
true. In the event of any failure encountered while undeploying (cleaning up) files, any
remaining files left to be cleaned up will be deployed as a result of the autodeployment
process. Depending on circumstances, files normally protected by one or more security
constraints may be deployed without those security constraints, making them accessible
without authentication. This issue only affects Windows platforms.
","From the looks of it, this is a simple coding mistake. What the developers
assumed was a solid undeployment strategy was not, and they were not doing
any logging or validation to verify that the WAR was correctly stopping and
getting cleaned up until this fix. As this relates to CWE-212, I believe that
they are doing a much better job of verifying that all of their WAR-related
artifacts are being properly cleaned.
"
1745,CVE-2009-2902,tomcat,"This vulnerability allows a user over a network to create a specially crafted WAR (Web Application Resource, including JAR files, JavaServer pages, static files, etc.) file that could be deployed by an authorized user. The WAR could potentially overwrite files on the system running Apache Tomcat under the ""work/<engine-name>/<hostname>"" directory. This vulnerability is an example of improper limitation of a pathname to a restricted directory because a user without access to the system can violate the integrity of files they should not have access to.",In my opinion this was a coding mistake. It could have been prevented by a thorough code review from a knowledgable Software Engineer that is familiar with common software security vulnerabilities. A seasoned engineer that is familiar with software security could have caught this vulnerability before it made it to production code.
1746,CVE-2009-3548,tomcat,"The Windows installer for Apache Tomcat uses a blank default 
password for the administrative user, which allows remote attackers to gain privileges easily.
This is obviously aggergious because it gives anyone admin access without having to
provide any credentials.
","This appears to have been a design issue. The way the engineers designed the system, this vulnerability
was inherent. They didn't keep in mind the core security principle of secure by default. It wasn't until 
someone who was investigating security found this issue 3 years later that it was patched. It even mentioned 
in the response to the vulnerability report that the system behaved contrary to how it was described in the docs.
The contrast between actual system behavior and the docs was clear midcommunication within the team.
The mitigation was to simply modify the default password to not be blank, so this mitigation seems sufficient 
within the scope of the vulnerability.
"
1747,CVE-2009-3555,tomcat,"Regulation of the transfer of data within the network is open to ""man-in-the-middle"" remote attacks that allow the attacker to inject data into a secure communication between two parties. The remote attacker can masquerade as the original party that initiates this communication. This allows the attacker to execute requests on behalf of the victim. Sensitive data may be compromised due to the inadequate or inconsistent verification of identities. In relation to Tomcat, Tomcat encrypts data along a communication channel between two parties. Tomcat supports renegotiation, which allows the user to interact with a system before authentication, then change their status to an authenticated user while also saving the user's activity, data, etc. The vulnerability comes in when a remote attacker intercepts the renegotiation and poses as the user. The attacker is then able to modify the communication.","The vulnerability was the product of a variety of mistakes. There seemed to be
lack of testing for both commits mentioned above. Testing in general would ensure
that something works the way it was intended to work. There were also coding mistakes
that resulted in either end of the communications channel to not be fully authenticated.
The design mistake that was potentially a factor could be that access for each entity 
was not properly checked for authority.
"
1748,CVE-2010-1157,tomcat,"A portion of Tomcat that handles http authentication via DIGEST and BASIC strategies had the potential to allow
for the viewing of the local name or IP address of the server running Tomcat. The header for the authentication 
via these strategies includes a <realm-name> element.
If a <realm-name> element is specified for the application in one of the configuration files, it will be used. 
However, if a <realm-name> is not specified then Tomcat will generate a realm name and
in some circumstances this can expose the local host name or IP address of the machine running Tomcat. 
","It seems that this vulnerability was an oversight with regards to how the configuration and authentication code
interacted. The fix was to provide a default realm name that did not contain sensitive data, instead of 
generating a string that used the actual hostname and port. What lead to this vulnerability was most likely
a simple ignorance to the value of a server's hostname information.
"
1749,CVE-2010-2227,tomcat,,
1750,CVE-2010-3718,tomcat,"In Tomcat, web applications are normally allowed access to a particular work
directory on the user's system. The applications are granted both read and write
permissions to that directory so that they are able to use temporary files. Tomcat
has an attribute that dictates the location of that directory. To prevent web
applications from changing the work directory, they should not be able to modify
that attribute. However, as a result of this vulnerability, applications were
able to change that attribute, which meant that malicious web applications
could read and write to any area on the user's file system.
","The main mistake that lead to this vulnerability was a lack of testing.
The author was aware that it was necessary to set the work directory
attribute to read-only. However, due to the way it was implemented,
the actual code that set the attribute to read-only was ineffective.
A fairly simple test should have been able to catch this issue.
One of the potential mitigations for CWE-269 is to carefully manage
the handling of privileges. The fix created for this vulnerability
seems to employ this mitigation in a proper way.

Fortunately, this vulnerability had fairly low impact and exploitability
scores. Confidentiality and availability were not affected whatsoever as
a result of this vulnerability. However, integrity was affected since
an attacker was able to modify the user's files. There were no known
reports of this vulnerability being exploited. Since the Tomcat security
team discovered this issue themselves, they were able to fix it before
it became a bigger issue.
"
1751,CVE-2010-4172,tomcat,,
1752,CVE-2010-4476,tomcat,"A method used in the Java Runtime Environment, the one responsible for parsing
and converting double binary floating-point numbers, may lead to an infinite
loop of estimations while converting. An example of this is attempting to convert
the number 2.2250738585072012e-308 with the method.

This exploit can enable a denial of service from a remote attacker using a
crafted string that will trigger this infinite loop by causing a hang or a
repeatable crash on the affected programs.
","This was a very obscure vulnerability to find, as it only works in a very
small range of numbers. The ""magic number"" may have just been found by chance,
and it breaking PHP led to others trying it in other languages. If not for
that original bug in PHP, this potentially would not have ever been found.
The fix for this looks proper, as it avoids the infinite loop in checking
how good the quality of the parsed number is after parsing it.
"
1753,CVE-2011-0013,tomcat,"An interface in Apache's software that controls the HTML Manager interface
is vulnerable. It can be affected by someone injecting a script into the
url which alters the appearance or data of any manager page that was 
followed by a user with administrator privileges.
       
","It seems that filtering input was overlooked and forgotten while developing.
If security had been addressed during the design of the manager subsystem,
this could have been caught then. This may due to an agile development process
which focused on feature implementation, rather than security. The fix does
look proper, since all raw input sent to the user now is filtered through a
filter function.
"
1754,CVE-2011-0534,tomcat,,
1755,CVE-2011-1088,tomcat,"Apache Tomcat is a Java Servlet Container system for helping run Java Servlets.
Java Servlets are simple additions to a basic server that help exend functionality.
Tomcat uses two separete methods for allowing developers to enforce permissions
on urls, one of which is the @ServletSecurity annotation. For Tomcat 7.0 - 7.0.10
these annotations were ignored, allowing any user to access any route that should
have been protected by these annotations were freely accessable without any protections
or authentication
","This was mostly a coding bug, as the annotations were simply forgetten about
for version 7.0.0 of Tomcat. Security permissions were enforced if they were
defined in the XML. Tomcat did not properly parse the @ServletSecurity
annotations within the code themselves Any security settings in these
annotations were not enforced as a result. This shows that it was an
oversight when moving to Tomcat 7.0.0, as previous versions were unaffected
by this bug.
"
1756,CVE-2011-1183,tomcat,"The basic configurations for a Tomcat web application are set in the web.xml file. 
This file includes a config called ""login-config"" which sets a level of security 
for the application by whitelisting url's based on a user's role. This bug occurred 
when this configuration was not set and a configuration called ""metadata-complete"" 
was set to true, unintentionally allowing users to ""bypass intended access restrictions"" 
through HTTP requests.
","This mistake seems mostly to be a maintainability issue in the project. The reason I say this is because
the vulnerability was introduced from a fix of two completely seperate issues in combination with some old logic.
Given that the code can produce unexpected new problems from other bug fixes leads me to beleive that this code
is difficult to maintain, especially given the size and number of contributors on the prject. 
"
1757,CVE-2011-1184,tomcat,"Attackers can look at all the messages being sent between the server and client, and get 
autheticated information. Then the attacker can use it by repeatedly sending the server the 
information. The server at this moment would authenticate the attacker because the message sent
has the correct username and password. The server should have seen the message was used already or 
old and dropped the message. In this case the server will give the attacker autheticated privlidges. 
","I think this problem comes down to a coding mistake. So it seems that
nonce is usually sent and authenticated by default in security libraries. The 
developer went around it and did not implement the functionality. This could 
also be a design mistake because when the design of the authentication was planned
this idea of nonce never came up. We can tell it never came up because they added 
a full function to check the nonce. But in the end this is a fix to the problem, 
since the user will never be able to reuse an authenticated message. 
"
1758,CVE-2011-1475,tomcat,"HTTP piplining is not handled properly in this Apache Tomcat version. This
gives remote attackers the ability to read responses intended for other
clients and examine the application HTTP packets.
","It seemed that this mistake was the result of simple coding mistakes.
I personally believe that certain Agile methods of programming (like paired
programming) and proper testing could have easily fixedthis issue before it
started. It was interesting to see how a simply misplacing some processor
calls, and how leaving out some try catch blocks that should be implemented,
could leave a sufficiently sized vulnerability.
"
1759,CVE-2011-1582,tomcat,,
1760,CVE-2011-2204,tomcat,"In Apache Tomcat, you can use a MemoryUserDatabase to load defined users, groups,
and roles into an in-memory data structure. The way Tomcat has implemented this
functionality is through an MBean from Java Management Extensions (JMX). JMX is
a built-in Java technology that provides an architecture for dynamically
managing resources by making the overall system more configurable. In this
context, an MBean is a ""managed bean"" and is being used to represent an in-memory
database of users, MemoryUserDatabaseMBean. In older versions of Tomcat, when
using a MemoryUserDatabase to create users, an unauthorized local user can access
sensitive user information (e.g. passwords) in local logs. This is because
sensitive user data is not filtered out when logging error information. In fact,
the entire User object is being written to the log file in the event of a runtime
error. As a result, a malicious local user can obtain sensitive information by
causing a runtime error and then reading the log file. Though this vulnerability
only discloses sensitive information in logs on the server-side, if an attacker
were able to gain local file access to the server through some other means or if
they were able to exploit some other Tomcat file-reading vulnerability, they could
feasibly read from that log file and have unauthorized access to that sensitive
user information.
","In my opinion, the mistake made here by the developer was a very simple and
straightforward coding and requirements oversight. Generally when logging,
you as a developer want as much useful information as possible to help you
debug. As such, it's likely the developer assumed it would be fine to write
the entire User object to log in the event of a runtime error, instead of
only writing out the username. I mean, how often would this exception be
thrown? Who would even try to read the logs other than the developers? Who
would know to look? The developer likely did not think of these possibilities
and went with the conceptually simpler ""print the whole object"" approach
instead of taking the time to consider logging only the information needed.
"
1761,CVE-2011-2481,tomcat,,
1788,CVE-2014-0095,tomcat,"If Content-Length is explicitly set to 0 in a particular type of request, the
thread handling that request will hang.
","As far as I can tell, this vulnerability is triggered by normal use of the
system, not abuse or even misuse of it. It can simply manifest in normal
use, and it happens to be an accidental DOS. Thus, better application of
security checking would quite possibly not have prevented, discovered, or
fixed the vulnerability.
I can only see two mistakes here. The first is that the case of content
length being zero was apparently not correctly checked in the VCC. The
second, and in my opinion more interesting, mistake is that a unit test for
that case was never made. While the first mistake is just a standard coding
error that's mostly unavoidable, the second seems like it was an important
detail that was overlooked. Perhaps a code review would have caught this
mistake.
There are two preemtive mitigations for the CWE that could have been
helpful. If implemented, ""ensure that the program fails gracefully"" or ""use
system limits"" would make the error more noticable while also making it not
consume an entire thread. It would still result in a bug that would need to
be fixed, but that bug would not be an exploitable DOS vulnerability.
"
1762,CVE-2011-2526,tomcat,"Apache Tomcat 5.5.x before 5.5.34, 6.x before 6.0.33, and 7.x does not validate certain request attributes, which allows local users to bypass intended file access restrictions or cause a denial of service (infinite loop or JVM crash) by leveraging an untrusted web application.",Lack of input sanitization that didn't get caught for a while since it was an edge case.
1763,CVE-2011-2729,tomcat,"Jsvc is an abstraction layer that allows Java applications to run on UNIX more easily.  The vulnerablity in this service can allow applications to access files belonging to superuser (this could be password files, superuser logs, sysystem configuration, etc.).","The requirements for the wrapper were not clearly specified.  Had they been, proper unit tests could have been developed. The requirements should have the wrapper inputs and outputs and their associated data types and ranges. The requirements should also include how error are handled. The unit tests could include that type safety was guaranteed. The unit test could inject a broad range of bad data and bad data types to ensure that there are no unexpected behaviors. Bad data could include bad data types, out of range values, pointers that point to other sections of memory or routines, encapsulated programs, and malware."
1764,CVE-2011-3190,tomcat,"Certain versions of Apache Tomcat are vulnerable to a data breach, due to a lack
of input sanitation when processing requests through AJP protocol connectors. An
attacker can create another request within an existing message body, allowing them to
bypass authentication. This occurs specifically when debug mode is enabled.
","The developer did not test the code against edge cases that may put the system into an invalid state, which ultimately caused a design mistake"
1765,CVE-2011-3375,tomcat,,
1766,CVE-2011-3376,tomcat,"Tomcat includes a component that provides administrative functions for
web applications such as deployment, reloading, and starting/stopping an
application called Manager.  Manager did not restrict untrusted web apps'
ability to access its servlets.  This allowed untrusted applications to
use the functionality of the Manager application to do things like run and
deploy additional applications without the consent of the server owner.
This vulnerability is primarily a concern for environments such as shared
hosting, where clients' web applications are not considered trusted.
","This vulnerability seems to be ultimately a design flaw in how the affected
class was designed.  Because it did not include any checks to ensure
applications access it were trusted, there was no mitigation
servers administrators could perform to resolve it and users of a shared
hosting environment could execute arbitrary actions in the Tomcat Manager
without any impediment.

This fix for this vulnerability appears to work as intended, as the code is
now creating a trust boundary for access between ""trusted"" and ""untrusted""
applications by explicitly checking the trust status of web applications.
"
1767,CVE-2011-5062,tomcat,,
1768,CVE-2011-5063,tomcat,,
1769,CVE-2011-5064,tomcat,,
1770,CVE-2012-0022,tomcat,Apache Tomcat (An open source implementation of the Java Servlet) 5.5.x did not use a proper approach for handling a large number of parameters. There was no limit to the size of a request so attackers could utilize this to cause a denial of service via requests that contained many parameters which in turn caused a large amount of CPU to be used. The vulnerability was handled by making Tomcat parameter handling code efficiently process large numbers of parameters and parameter values.,"From what I have seen, it seems like a design mistake led to this vulnerability. It appears that when created, the original code did not account for the possibly of large/excessive parameters.This could be due to the fact that the developer never anticipated that their system could be abused in such a way. I also found it interesting that the vulnerability was found from investigating another vulnerability. This shows that it is important to consider how 1 vulnerability may be applied or affect another part of a system."
1771,CVE-2012-2733,tomcat,,
1772,CVE-2012-3439,tomcat,"This entry involved several issues that allowed the authenticator to be bypassed.
Prior to the fix, client nonces (random number issued for authentication) were 
tracked instead of server nonces, allowing attackers to bypass authentication by 
reusing valid requests. Replay attacks (attacks where valid requests are repeated 
or delayed) were made possible because the system cached information about the
user in the sessision state and did not check for correct credentials and stale
nonce values. 
","This vulnerability was most likely made due to a design mistake. This is 
an exploit with a high probability of occurrence and should have been considered
in the design of the architecture. The mitigations listed suggest utilizing
sequences or time stamping along with a checksum to ensure messages are only
parsed once. The fix addresses this by using server nonce values instead of client
nonce values as well as checking for stale nonce values and forcing reauthentication.
The fix appears complete in addressing all problem areas where the exploit can occur.
"
1773,CVE-2012-3544,tomcat,,
1774,CVE-2012-3546,tomcat,,
1775,CVE-2012-4431,tomcat,,
1776,CVE-2012-4534,tomcat,,
1777,CVE-2012-5568,tomcat,,
1778,CVE-2013-1571,tomcat,,
1779,CVE-2013-2067,tomcat,,
1780,CVE-2013-2071,tomcat,"The vulnerability stemmed from a lack of exception handling. 

Some objects would like to be notified when an event occurs and are therefore
""listening"" for an event. In the situation where one of these listeners threw
a runtime exception, the web request associated with the event would not be
properly recycled as it should be. This resulted in subsequent requests having
information from that previous request. Such information is then present 
where it should not be available.
","The mistake here was overlooking the potential for an asynchronous listener
implementation to throw a runtime exception. When the error handling was
implemented over the course of two commits, the only expected error was
an IOException. This handling proved to be too narrow.

From the discussion on the bug report, it is clear the implementer does not
believe an asynchronous listener should ever throw a runtime exception. 
However, tomcat should protect against it in the case that an application
chooses to do so.

The assumption of no runtime exceptions being thrown led to unexpected
behavior within tomcat. This behavior ultimately created a security
vulnerability in the form of a leak of information.
"
1781,CVE-2013-4286,tomcat,,
1782,CVE-2013-4322,tomcat,,
1783,CVE-2013-4444,tomcat,"This vulnerability allows attackers to upload and execute JavaScript programs
on a Tomcat server. The Tomcat security team views this vulnerability as
important rather than critical because the circumstances required for it to
occur are limited.

The implementation allowed unrestricted reading of files. It was not obvious
that files were checked for scripting. This may allow remote code execution by
attackers using JavaScript files.
","Even after doing the research, it is not very clear what happened that
lead to this vulnerability other than not checking for edge cases that
might cause vulnerabilities such as outdated versions of languages and
frameworks that might not be compatible with software being built.

In addition, it's interesting that the fix wasn't focused on fixing the issue
but instead it was an overall ""code cleanup"" that included the fix.
"
1784,CVE-2013-4590,tomcat,,
1785,CVE-2014-0033,tomcat,,
1786,CVE-2014-0050,tomcat,"A software package offered by Apache Tomcat for hosting websites allowed attackers to consume near 100% of the host's CPU, creating a Denial of Service attack. This exploit involved an attacker crafting an HTTP Content-Type header when uploading a file to the server. Changing the boundary to be more than 4091 caused the system to enter into an infinite loop.","The mistake that led to this vulnerability likely occured during implementation. Looking at the code, the implementation failed to fulfill the design. During implmentation an edge case was missed in their software packages.
The fix was generally easy to make once it was identified, but for a time the vulnerabilty was present in their software.
In order to prevent a mistake like this from occuring in the future, Apache should invest in testing edge cases more often."
1787,CVE-2014-0075,tomcat,,
1789,CVE-2014-0096,tomcat,,
1790,CVE-2014-0099,tomcat,,
1791,CVE-2014-0119,tomcat,,
1792,CVE-2014-0160,tomcat,,
1793,CVE-2014-0227,tomcat,,
1794,CVE-2014-0230,tomcat,,
1795,CVE-2014-7810,tomcat,,
1796,CVE-2015-5174,tomcat,,
1797,CVE-2015-5345,tomcat,,
1798,CVE-2015-5346,tomcat,,
1799,CVE-2015-5351,tomcat,"Apache Tomcat includes a web application called the Manager. This tool is used to deploy new web applications, to undeploy currently deployed web applications, to reload existing web applications, and to perform other operations to change and monitor the availability of the user's web applications.
Another web application included in Apache Tomcat is the Host Manager. The Host Manager is used to manage the different virtual hosts (server-sharing wesites) on the user's Tomcat server.
CVE-2015-5351 refers to a vulnerability in the Manager and Host Manager web applications. An unauthenticated user attempting to accessing the index page of either of these web applications would be issued a redirect from the server with a valid CSRF token. An attacker may use this token to send requests to the web application which would have been considered invalid without the token's inclusion.
It is worth noting that because these applications are intended for managing the user's apache server, they are not usually exposed to the internet.","No changes were made to the file housing the vulnerability in the time between its introduction and its correction. When the vulnerability was finally fixed, it was done by the same person who had introduced it 5 years prior. It seems like one of the issues that may have lead to this bug was lack of eyes on the code. When a component does not have many maintainers, and when those maintainers do not interact with it often, any bugs it contains are likely to last a long time.
This bug is also a good illustration of the damage caused by a technology not being ""secure by default"" - in this case, JSPs which create a session with the client by default, regardless of whether one is needed."
1800,CVE-2016-0706,tomcat,,
1801,CVE-2016-0714,tomcat,,
1802,CVE-2016-0762,tomcat,,
1803,CVE-2016-0763,tomcat,"A method that set the global context of the system was publicly available to be called from a web appliction, and could potentially set a malicious global context.","I think that this was simply an oversight. They likely ran into a scenario where they wanted to complete this action without authentication. So rather than do the legwork and properly authenticate, instead all authentication for the function was stripped out. I'd classify this as a coding mistake or a design mistake, not in the sense that it was a literal typo, but rather the system wasn't critically thought about. Security should not be an after-thought, and the scope of setting something called the global context should set off some alarm bells I'd hope."
1804,CVE-2016-3092,tomcat,"The multipart stream area of the system doesn't check the length of a boundary string. This
means that a user can potentially use an extremely long boundary string to cause a denial of
service attack.
","I think this was a coding mistake because, when getting string input, it is good
practice to check the length of the string to make sure that it won't cause any
problems. I think the fix looks proper because it sets the buffer size to the
boundary length times two if the boundary string is too large. This helps to prevent
the DoS vulnerability. I think that another good fix would have been to not
directly append prefixes.
"
1805,CVE-2016-3427,tomcat,,
1806,CVE-2016-5018,tomcat,,
1807,CVE-2016-6794,tomcat,,
1808,CVE-2016-6796,tomcat,,
1809,CVE-2016-6797,tomcat,,
1810,CVE-2016-6816,tomcat,,
1811,CVE-2016-6817,tomcat,"The HTTP/2 header parser was found to have entered an infinite loop if a header 
was larger than the available buffer. This means a denial of service attack is possible.
","In my opinion, this was a coding mistake. This specific vulnerability is based off an edge-case that, at the time, 
developers did not think would ever occur. The founder of the vulnerability, barney2k7, discovered 
such edge case when trying to parse a header of about 30kb. The fix of this vulnerability involves 
increasing the buffer size if the capacity were to be less than the size of the header. The CWE entry for this 
has mitigations which the fix follows. The fix checks to make sure if the size is larger than the capacity 
and if it is, increase the capacity. 
"
1812,CVE-2016-8735,tomcat,,
1813,CVE-2016-8745,tomcat,,
1814,CVE-2016-8747,tomcat,"A regression was introduced when a Java class was refactored to use the standard ByteBuffer class rather than a byte array. The issue is in the cleanup code which prepares the buffer for the next HTTP request. Because of faulty cleanup logic, some information could leak between HTTP requests.","This is a coding mistake that resulted during a refactor from using a regular java array with the byte type to the ByteBuffer that was introduced in Java 7. There does seem to be sufficient justification for the change, as ByteBuffer has significant performance-enhancing features. Unfortunately, this seems to be a case where the developer was not well versed in the new technology before performing the refactoring. This is hinted to by follow-up commits from the same author. The author attempted to 'drop-in' the new code in place of the old but did not notice that subsequent operations were required to manipulate the ByteArray class pointers.
"
1815,CVE-2017-12615,tomcat,"By adding a '/' onto the end of the file extension for apache tomcat, you can bypass the 
file extension checks; therefore leaving a gap to exploit the vulnerability - the server would
run the code in the file that was appended.
","In my opinion, there was a big coding and design mistake. When they were designing the 
system they should have planned for the impact that having an attack in one portion of the code
would not impact all portions. They should also have sanitized the urls and input so that a file 
could not be put into the url; if the input would have been sanitized, it would have prevented this.
This was a very simple and fixable mistake in the code. 
"
1816,CVE-2017-12616,tomcat,"The use of the class VirtualDirContext, which is intended to expose
multiple directories of the filesystem under a single webapp, made it possible for
an attacker to insert a specially crafted request that would enable them to bypass
security constraints and view the source code for JavaServer Pages.
","Not enough testing to be able to catch the unexpected behavior. The fix
is just to upgrade to the latest release, which seems like a reasonable
solution since the vulnerability patch requires at most a minor release
upgrade. The thing that made this vulnerability particularly bad is that
since it gave access to source code it opened the JSPs to further attacks.
"
1817,CVE-2017-12617,tomcat,"This was a vulnerability that affected people who used Apache Tomcat versions 70, 80, 85, and 90.
The vulnerability allowed people to upload a Java Server Page (JSP) file to a server if the Java servlet had HTTP put enabled and had a setting called readonly set to false. A JSP file is written in Java and it allows the web server to execute the code to produce HTML that the user sees. The file is only able to get uploaded to the servlet if it is sent through a specially crafted request.
Users who request that file intentionally or unintentionally will cause the server to execute the code on the JSP file which can be malicious.","I wouldn't really call it a mistake, but I find it strange that there is a setting for the readonly parameter since most, if not all, people would want it be set to true. I am guessing that it was relevant in the past and they need to maintain that setting for previous technologies. I would say this is a form of miscommunication since the people who are exposing themselves to this exploit don't have a complete understanding of what the settings do.
The lesson to be learned here is to always review the code when introducing new systems and to update documentation so that users can understand what each configuration does even if it may be considerd old or not as relevant."
1818,CVE-2017-15706,tomcat,The documentation of the algorithm used by a module in the (Common Gateway Interface) Servlet did not match the existing functionality. This could cause some scripts to not execute as expected and caused other scripts may have been executed unexpectedly. This was caused by a previous fix to a bug in mapping requests to script paths where the documentation was updated incorrectly.,The biggest mistake seems to be simply not proofreading of the documentation to check if the documentation matches the functionality of the system. Rewriting the documentation is a quick and complete way of fixing this issue.
1819,CVE-2017-5647,tomcat,,
1832,CVE-2018-8034,tomcat,,
1820,CVE-2017-5648,tomcat,"While investigating bug 60718, it was noticed that some calls application listeners did not use the appropriate facade object. when running an untrusted application under a security manager, it was possible for that application to retain a references to the request or response objects and thereby acces or modify information associated with another web application.
In the error page mechanism in Tomcat's Default servlet. A crafted HTTP request could cause undesired side effects, possibly including the removal or replacement of the custom error page.","The major mistake that led to this vulnerability was design mistake that was exposes a resource to the wrong control sphere, providing unintened actors with inappropriate access to the resource. Resources such as files and directories may be inadvertently exposed through mechanisms such as insecure permissions, or when a program accidentally operates on the wrong object."
1821,CVE-2017-5650,tomcat,"This CVE describes a Denial of Service attack done through the network via malicious HTTP requests, which are responsible for enabling communication between the client and the server. More specifically, the flaw can be encountered in the HTTP/2 GOAWAY frame. This component is responsible initiating shutdowns betweeen connections. This was exploited because its associated streams that were waiting for closure before allowing the application to write more data. These waiting streams each consumed a thread. Therefore, an attacker could generate a DoS attack through a malicious client that constructed a series of HTTP/2 requests that would consume all available processing thread, thus bringing the system down.","This vulnerability could have been easily avoided by doing proper penetration testing and making sure to evaluate all the different edge cases and applications for this software. It is imperative for software of this caliber to have a security design that avoids this kind of attacks. Thankfully, the fix involved few lines of code that addressed the issue without any further concerns. A more strict testing approach would have avoided this issue."
1822,CVE-2017-5651,tomcat,"This vulnerability occurs when a http request results in a send file action.
The mistaken removal of the http processor cleanup step during refactoring,
makes it possible for a http processor to be re used for another request.
This could result in a user receiving a response intended for another user,
potentially disclosing confidential information.

When a request is received resulting in a send file action, an http processor
is popped from a cache. Another thread then completes the send file action
and pushes the http processor back into the cache. Milliseconds later, the
thread that popped the http processor pushes it back into the cache, causing
the same http processor to be in cache twice. This may lead to unexpected errors
or a response mixup which may disclose priviliged information.
","This vulnerability was an oversight in terms of not preserving program
behavior during refactoring. The http processor recycle step was mistakenly
forgotton in the VCC and then reimplemented in the fix. Considering the use
of concurrency, extra caution should have been taken during refactoring.
"
1823,CVE-2017-5664,tomcat,,
1824,CVE-2017-6056,tomcat,,
1825,CVE-2017-7674,tomcat,"Apache Tomcat does not add an HTTP Vary header with an Origin parameter to
CORS responses, which could result in a ""cache poisoning"" attack where one
origin could manipulate the cached response for another origin.
When responding to Cross-Origin Resource Sharing (CORS) requests, Apache
Tomcat did not add an HTTP Vary header to the response that would indicate
that the response could be different based on the Origin header in the
request. Since CORS requests can be made from multiple different origins, the
server could have a different response based on the origin that is making the
request. For example, if the resource being requested is an image with text
in it, the image returned in the response may be different for French and
English versions of the page. These different versions could be served at
different origins, such as www.example.fr or www.example.com.
Including the Vary header in the CORS response tells a caching server that it
needs to cache different responses based on a specific parameter - in this
case, the content of the Origin header in the request. Without the Vary
header, a caching server will only cache a single response for all the
origins. This will allow anyone making a request from one origin to load an
invalid response into the cache for all users from all other origins.
","The major mistake that led to this vulnerability is a design error. When
adding the new filter, the author did not consider the use of the Vary
header to make sure caching servers interacted with the server properly.
This oversight can be seen in the original Bugzilla report requesting a
CORS filter be added (https://bz.apache.org/bugzilla/show_bug.cgi?id=55046)
and in a linked diagram showing the operation of the CORS filter
(https://bz.apache.org/bugzilla/show_bug.cgi?id=55046).
While some bugs are difficult to find because of complex code, this bug was
difficult to find because of complex systems. In this case, multiple
different systems had to interact together in an architecture that the
authors may not have originally considered or intended.
"
1826,CVE-2017-7675,tomcat,"This vulnerability involves the processing of an HTTP request
where one of the path parameters is a URL with the ability to traverse outside
of the folder where the module is pointing, depending on the URL string that
the user passes to the server.

This ultimately happens because, for that particular parameter (and maybe
others) a number of existing security checks were skipped over in the
implementation. 
","Based on the comments surrounding the original implementation, as well as
the brief history of commits revolving around the chunk of code containing
the vulnerability and the lack of targeted unit tests; this vulnerability
was most certainly caused by a lack of proper risk assessment. 

With a comment like ""This is almost certainly wrong and needs to be decoded"",
it seems like this part of the code didn't receive the proper amount of
attention to determine that it may lead to some vulnerabilities if not
properly tested. 
"
1827,CVE-2018-11784,tomcat,When the default servlet in certain Apache Tomcat versions returned a redirect to a directory (e.g. redirecting to '/foo/' when the user requested '/foo') a specially crafted URL could be used to cause the redirect to be generated to any URI of the attackers choice. The lack of validation and sanitization of the URL left an opening for attackers to exploit. They could extend the url to form a URL of their own to which the user would be redirected.,Overall this was a coding mistake and specifically an err in assumptions. It was a pretty simple fix which shows that it was something that could've been avoided had more extensive tests been written and/or executed.
1828,CVE-2018-1304,tomcat,,
1829,CVE-2018-1305,tomcat,"Security constraints were only applied once a Servelet was loaded. That means 
they were applied only to the URL pattern. So depending on the order the Servlets
were loaded you could cause some constraints to not be applied. This then leaves 
open holes for exploits such as elevated privilege. You instead need the Servlets
to all load first so all the security constraints are taken care of. 
","It seems their issue was both a design mistake and a bit of an oversight on 
their part. Initally back in 2010 they believed they wanted to be able to
deploy servlets at different times. This still is true. But what they didn't
think was that in the future the servlets would have secuirty constraints placed
on them and this order would be exploitable. They mitigated this risk by forcing
the servlets to run their security checks on web application start instead of on
their own time. This solution seems wise to me. Now the timing doesn't really matter
because it is all happening before the application launches. 
"
1830,CVE-2018-1336,tomcat,"Use of supplementary characters, such as those found on certain international keyboards, 
can lead to overflow causing an infinite loop. This then causes denial of service.
","This was an implementation mistake. CWE-153 says that all characters should
be manipulated to ""ensure only valid, expected and appropriate input is 
processed by the system"". The fix looks proper, it looks like rather than
managing characters they are managing the overflow caused by the characters.
I would say this falls under the ""expected"" portion of the mitigation advice.
"
1831,CVE-2018-8014,tomcat,,
1833,CVE-2018-8037,tomcat,"If an async request was completed the same time as the async timeout,
a race condition existed that could result in a user seeing a response intended for a different user.
An additional issue was present in connectors that did not correctly track the 
closure of the connection when an async request was completed by the application and timed out by the container at the same time.
This could also result in a user seeing a response intended for another user.

There essentially was a race condition where if the timeout and request were the same,
undefined behavior and other responses would be observed
","The coding mistake was not accounting for the undefined edge case where an async
request was completed at the same time as an async timeout.
The fixes are proper and account for async behavior.
It is interesting that most of the code for this bug/bug fix and the surrounding code
is written by one man. He must of missed this condition. Making sure that other async code that exists
in tomcat covers the async race condition is crucial to prevent similar bugs in the future.
"
1834,CVE-2010-1870,struts,"This vulnerability allows remote attackers to modify server-side context objects.
This is allowed through a permissive whitelist for HTTP parameters, which are
converted to Java code using an open-source Expression Language. The whitelist
disallowed ""#"", which is a sensitive character for context variables. The issue
was that the whitelist did not account for the Java unicode representation of ""#"",
""\u0023"".
",
1835,CVE-2011-1772,struts,"Multiple vulnerabilities allowed attackers to execute XSS attacks, executing potentially harmful outside scripts by using an input that contains an existing action or method name.","Request parameters were used to dynamically generate an action name but were not being escaped, and when raw input is parsed into code in this way it leaves attack vectors very open to vulnerabilities.  In addition, this was a bug in the underlying XWork code added to the system, and that code should have been thoroughly tested and analyzed for vulnerabilities before it was added into the project."
1836,CVE-2011-3923,struts,"Apache Struts' ParameterInterceptor class did not properly handle specific 
user supplied inputs from HTTP requests. The improper handling of requests 
allowed for a remote user to bypass security measures, and perform an exploit of 
this vulnerability by using OGNL (Object-Graph Navigation Language) expressions 
to modify server-side resources and potentially run arbitrary Java code on the 
target system.
","I feel as if the mistakes that were made that led to this vulnerability
were based in coding. The developers simply forgot to handle an edge case,
which was the presence of parentheses to construct and make OGLN 
calls. The chosen CWE for this vulnerability (CWE-94) marks input validation
and testing as a couple of the possible mitigations, and in the case of this
CVE, the struts development team were already doing both, just not to the 
degree that was required to handle this vulnerability. Tests existed for this
area of the code and some other characters were also blacklisted from requests,
just not the characters that were needed to fully elminiate the possbility of
malicious OGLN code execution.
"
1837,CVE-2012-4386,struts,"The validation which checks tokens in Struts was insufficient, allowing
a malicious user to craft a CSRF attack by adding a token of their choosing
to the URL. This token would then be saved to the system without any error
checking.
","The thing that stuck out to me about this vulnerability is that the attack
vector does not come from a user parameter. The attack occurs when a user
takes a value set by the developer (the name of a URL query parameter) and
hijacks it, setting it to a new, specially-crafted value which creates a
Cross-Site Request Forgery. It is important to note that even though the
developer chooses query parameter names, these can be modified with a few simple
keystrokes in a browser's address bar, and so should also be validated.
"
1838,CVE-2012-4387,struts,"Request parameters handled by Struts 2 are effectively treated as OGNL expressions,
which may take some time to process if they're sufficiently complex. A possible DOS
attacker might craft requests to a Struts 2 based application with extremely long
parameter names. OGNL evaluation of the parameter name then will consume significant
CPU cycles, thus promoting the effectiveness of the DOS attack.
","This was caused by not properly validating user inputs that were being translated
to complex expressions with the potential for exploitation, which I would classify
as a coding mistake. As this is critical to the overall function of the application,
extra care needed to be taken to handle these sensitive inputs, and a number of test
cases should be written to test different scenarios, which is was completed. Aside
from a redesign that treats these inputs differently, this was an appropriate solution
to the problem.
"
1839,CVE-2013-1965,struts,"The vulnerability was in the XWork core library of Struts 2. OGNL code--an expression 
language which can get and set fields and call methods in Java--could be injected 
as a parameter name.  Although this was partially handled in earlier bug fixes 
(S2-003, S2-005, and S2-009), these fixes did not account for a specific case in 
which the parameter name could still be evaluated as OGNL code during a redirect, 
a sort of double-evaluation.
","The problem which caused this vulnerability was one of design. The conclusion 
eventually reached was that OGNL evaluation in XWork core simply cannot easily 
be implemented in a secure manner. After multiple attempts to sanitize input, 
the solution was to just disable OGNL evaluation by default.

Additionally, the multiple attempts at fixes show that testing may not have 
been thorough enough to push those fixes to production. New edge cases kept 
popping up and requiring small adjustments until this final solution was 
reached.
"
1840,CVE-2013-1966,struts,"URL requests containing parameters were not properly handled and sanitized.  
This allowed malicious code in the Apache Object Graph Navigation Language (OGNL) to be executed by typing commands in the URL parameters.
","There were two major mistakes that likely led to this vulnerability being created.  First was importing the XWork files without fully considering what vulnerabilities they may create.  Second, the input through URL parameters, which are very easily modifiable, were not being properly sanitized, which allowed code to be executed very easily, which is a major problem in software systems."
1841,CVE-2013-2115,struts,"A specially crafted request parameter could be used to inject arbitrary
code, which could then be used as request parameter of a URL or anchor tag.
Then the URL/anchor tag tries to resolve every parameter present in the
original request. This lets malicious users put arbitrary statements into any
request parameter and have it evaluated to enable method execution and execute
arbitrary methods, which bypasses any library protections. This vulnerability was
introduced as a partial fix to a previously identified bug.
","This vulnerability was due to a fundamental flaw in the design of the url rendering
system and the subsequent fix in 2.3.14.1 did not fully address all possible attack
vectors. Rearchitecting the url rendering subsystem to not pass any vulnerable
parameters and changing the allowStaticMethodAccess property to be immutable seemed
to completely fix the original vulnerability reported in 2010.
"
1842,CVE-2013-2134,struts,"By using wildcard matching (using a generic case that will match if a specific case is not provided),
an attacker can execute (inject) Java code that is not in the source code.
","I think that the mistake that was made here was the lack of consideration for unsanitized inputs.
If there was consideration for the fact that a wildcard action would allow for attackers to send in unsanitized and unmonitored inputs,
the developers would have coded more defensively to begin with.
So in short it was a design mistake to allow this layer of code to be directly interacting with inputs that were not sanitized.
In the design phase, a defense layer where inputs could get sanitized before being sent to the rest of the code should have been brought up.
"
1843,CVE-2013-2135,struts,"Struts was not performing adequate input validation when mapping requests to controllers. 
In certain configurations, when a request URL included crafted input in the form of the templating 
language used by Struts (OGNL), it would be unintentionally evaluated as such. This evaluation 
allowed arbitrary Java code execution to occur.

This vulnerability was made possible by a lack of input validation and a ""double evaluation""
issue in the templating language parser.
","The two issues involved in this vulnerability seem to fall under two different mistake categories.
The lack of input validation is likely a design issue in not considering dynamic inputs.
The double evaluation issue falls under a coding mistake, as it was made possible by an implementation error in the parser.
"
1844,CVE-2013-2248,struts,"A vulnerability in struts allowed an attacker to use certain URL parameters with special
meanings, redirect and redirectAction, to set their value to any website and automatically
redirect the user to that website. The vulnerability was fixed by removing code that performed
the redirect actions entirely
","There was a design mistake in the actions, allowing redirects from URL parameters without
requiring any authentication is dangerous. Given that the solution was to entirely remove
the behavior, it could be said that they reduced the attack surface. It's noted that
any user could reimplement the behavior on their own by copy-pasting the pre-fix code
into a custom action mapper class, so the vulnerability fundamentally still exists in the
system. However, it is likely impossible to remove that behavior without disallowing desired
functionality.
"
1845,CVE-2013-2251,struts,"The 'action' and 'redirect' parameters were added to streamline navigation to buttons within forms. However, these methods took unsafe client side input and executed it without sanitization. This allows for a malicious actor to execute arbitrary Object-Graph Navigation Language (OGNL) expressions. This is a remote code execution vulnerability.","Inputs were not sanitized and defense in depth was not applied. This lead to remote code execution and is completely unacceptable. The developers introduced additional inputs to their previous code, yet no sanitization was done such as was done with previous inputs. In the future, developers can look at the security practices implemented in similar portions of their project, or in other projects."
1846,CVE-2013-4310,struts,"Struts 2 controls actions using a special prefix parameter in the body of some
requests. This information is then read directly without validation. Providing
the correct information for the prefix parameter can lead to bypassing security.
","Security should have been addressed more in the design of mapping actions,
specifically considering cross site scripting vulnerabilities. This may
have been caused by a lack of security requirements, or miscommunication,
since other parts of struts already had implemented filtering mechanisms.
To prevent this from happening again, developers could standardize reviewing
code for cross site scripting vulnerabilities, or enforce security reviews 
for relevant commits.
"
1847,CVE-2013-4316,struts,"Struts 2 introduced a new feature called Dynamic Method Invocation (DMI). This
allowed developers to call specific public methods by passing them through the
url after an exclamation point. This opened up the possibilty for users to call
other methods by abusing this feature. Abusing this was as simple a modifying the
url of the request. ""http://example.com/route!method1"" would call the function
""method1"", while ""http://example.com/route!method2"" would call method2 instead,
opening many other potential attack vectors. DMI is defaulted to on for Struts versions
2.0.0 through 2.3.15.1. Users were not warned about the potential security risks
of leaving this enabled.
","A big mistake that contributed to this was defaulting a potentially insecure
configuration option to be on. By defaulting Dynamic Method Invocation to on
users did not have a prior warning on what vulnerabilities this potentially
introduced. If this were to be defaulted to on, a whitelist should have been
included by default, so users would still have to opt into the insecure option.
"
1848,CVE-2014-0050,struts,"This vulnerability allows for an infinite loop to occur, meaning the program is thus vulnerable for
a DoS (Denial of Service) attack. The exploit would come in the form of sending an HTTP request with a Content-Type header
with an extremely high length.
","I would say that this would be a coding mistake. In the implementation of this piece of code, the author had mentioned
in the Git log that he had attempted to account for all of the ""sneaky boundary cases"". This goes to show just how
sneaky they can be in that there was a bug stemming from input being above a certain length.

That said, it is difficult to blame this on the programmer, given that the vulnerability could only be exploited by an attack
vector specifically meant to be strange and unlikely.
"
1849,CVE-2014-0094,struts,"Apache Struts could allow a remote attacker to bypass security restrictions,
caused by an error in the excluded parameters accessable by user input. An 
attacker could invoke a specific method on a remote Java server by specifying
it in a URL. All Java objects have a getClass() method that returns the object's
class which an unauthenticated attacker could access and manipulate into 
disclosing private Class information or possibly load a malicious class file.
","The mistakes here were reported as a design flaw and the maintainability of that
design flaw. Over years of development the parameters that users were able to access
changed and with that the security measures ment to protect from user input must 
stay up to date to avoid allowing users to have access to unintended functionality.
The users should only be allowed to input parameters that they are intended to use and
more importantly all other parameters should be blocked from being accessed at unintended times.
"
1850,CVE-2014-0112,struts,"The excluded parameter pattern intoduced in an earlier Apache version to block
access to a getClass() method wasn't detailed enough. Special requests could
allow an attacker to circumnavigate this blocker. Also a ""CookieIntercrptor""
object is vulnerable for the same kind of attack when configured to accept all
cookies. This exists because of an incomplete previous fix.
","The biggest issue of this vulnerability was that a previous vulnerability
fix was not tested thoroughly. This vulnerability (CVE-2014-0094) was the
cause of multiple other vulnerabilties afterward (CVE-2014-0112,
CVE-2014-0113, CVE-2014-0114 just to name a few). This showed that there was
a lack of unit testing and acceptance testing in the addition of this bug
fix. Thankfully, from researching, it didn't take long once these
vulnerabilities were started to be finished. To ensure testing is done
thoroughly in the future having multiple reviewers of code could be
implemented to put multiple eyes on fixes, and thus, increasing the chances
of bugs like this being caught.
"
1851,CVE-2014-0113,struts,"CookieInterceptor in Apache Struts, when a wildcard cookiesName value is used, does not properly restrict access to the getClass method, which allows remote attackers to ""manipulate"" the ClassLoader and execute arbitrary code via a crafted request.","This seems like an inherent design mistake when the CookieInterceptor class was created. You have to keep a clear idea of permissions to possibly private methods when writing code. A mitigation, besides updating to 2.3.16.2, is replacing the previous class related pattern with '(..|^|.|[('|""))class(.|('|"")]|[).*' on the list of excludeParams. In the future, testing permissions as well as the code being effected could help to mitigate a possible repeat of the mistake."
1852,CVE-2014-0116,struts,"A fix applied in a previous update didn't account for the wildcard (*) operator.
By missing this operator in the appropriate blacklist for disallowed inputs, this 
allowed attackers to bypass the safeguards in place and craft exploits for the system.
","The correct sanitization regex pattern was present in another class 
(ParametersIntercepter) but was reimplemented (incorrectly) in CookieInterceptor. 
This is a code-smell (Duplicate Code) and suggests that there was a lack of
due diligance by the developer to search for pre-existing solutions, and that
they weren't communicating effectively with their team members. The issue went 
unnoticed in large part due to there not being robust unit tests for bad inputs.
Vulnerabilities like this can be prevented in the future by following principles
like DRY (Don't Repeat Yourself) and by creating extra tests as vulnerabilities
are discovered.
"
1853,CVE-2014-7809,struts,"Due to an ineffective random number generator, observing a previous authentication
token allows for attackers to predict the next authentication token to effectively
bypass the cross-site request forgery protections.
","I would classify this issue as a simple coding mistake. The developers
likely went with a non-cryptographically secure random number generator
out of habit or perhaps they just didn't realize the potential risk associated
with using a normal pseudorandom number generator. I also think that the fix was
proper, this was a simple issue and a simple fix was used.
"
1854,CVE-2015-1831,struts,"The issue with this CVE was the input validation, checking what the user types, in Apache version 2.3.20. Specifically the excludeParams function, when added, overrode patterens in another function called DefaultExcludedPatternsChecker,
this allowed attackers to input their own expressions to gain access to excluded classes and package names that could compromise the internal state of the appliction.
","The problem was caused by poor design mistake. For Example, the choice to have the excludeParams function override those patterens in DefaultExcludedPatternsChecker was what caused the issue. It was most likely missed due to lack of oversight. Code reviews would've helped catch this issue."
1855,CVE-2015-5169,struts,,
1856,CVE-2015-5209,struts,"The Struts server was not performing adequate input validation on request
parameters.  This allowed a remote user to create a request referencing a
object that represents the root of the execution context.

A remote user could use this root object to bypass security restrictions 
and perform remote code execution on the Struts server.  This includes 
modifying the internal state of the target application, affecting container 
settings, or altering user sessions.
","The mistake made that led to this vulnerability was likely a requirements 
misunderstanding or omission, as the actual code for input validation
appears to work as expected. Since the processing of request parameters 
allows for access to critical application state, a cleverly-made request 
could access and modify this state.  The fix made for this vulnerability
looks proper, and has additional unit tests to check for that specific
vulnerability.

In the future, this could be prevented by designing the system to only allow
reflection from HTTP parameters on those explicitly specified in the code,
require parameters to conform to a framework-defined whitelisted format, or
have a well-defined blacklist that contains all critical objects that could
be accessed.

As of now, the project is performing both input validation as well as 
attack surface validation by knowing to check both request parameters as 
well as cookies.
"
1857,CVE-2016-0785,struts,"This vulnerability allows remote arbitrary code execution. Apache struts uses
a language called Object-Graph Navigation Language (OGNL). OGNL is an open
source expression language that allows for easy manipulation of properties.
When setting default properies for Struts, one property was assigned multiple
times. This forced Apache Struts to perform a double evaluation of the value
attributes assigned to certain tags. This allowed remote attackers to send
crafted attribute data that would be evaluated twice. This allows execution of
arbitrary  code. The code would have the same system privileges as the
target service.
","There were a few mistakes that led to this vulnerability. The first one was
a simple coding mistake. A line of code was written twice on different
commits. When the duplicate line was committed, the author most likely did
not see the first line. It could be a copy-and-paste mistake as well. The
second mistake was not sanitizing the attributes associated with the tags.
This is a design flaw. The fixes for this vulnerability do not appear to
have fixed this error.
"
1885,CVE-2018-1327,struts,"The Struts Rest plugin uses a library called XStream for serialization and
deserialization of Java objects. The XStream library is vulnerable to DoS
attacks when a malicious request is sent with a crafted XML file. This
vulnerability affects Struts versions 2.1.1 to 2.5.14.1.
","The mistake that the Apache Struts developers made was not fully distrusting
and isolating a third party library. When ever you implement a library into
your project, you inherit all of the vulnerabilities that the library has. In
the future it is important that input from other libraries is properly
validated and sanitized.
"
1858,CVE-2016-2162,struts,"The Apache Struts framework uses I18NInterceptor to allow users and developers
to switch language used in the framework and an application built on top of
it. The problem is that the interceptor doesn't perform any validation of the
user input while accepting arbitrary strings which can be used by a developer
to display language selected by the user. However, the framework doesn't
expose the value directly in UI. This means that the vulnerability is only
exploitable if the developer explicitly puts the string from the Locale object
onto the page.
","This seems like a design issue, as the developer did not account for the
method contracts of Java's Locale library. Since Locale doesn't perform
validation automatically, and the developers also did not do so themselves,
the user input was left unchecked and carried through the rest of the
program. This led any developer using Struts vulnerable to XSS if they
access the Locale object directly for UI code.
"
1859,CVE-2016-3081,struts,"A remote user is able to execute arbitrary code on a targeted system. This is
possible when Dynamic Method Invocation is enabled and performed through 
""method: prefix"". This provides an attacker the ability to pass a malicious
expression into user input to gain access to the system due to the lack of 
sanitization. In this case, dynamic method invocation is when HTTP parameters
are prefixed with ""method:"". In other words, an attacker can specify what method
the system should execute specified in the URL. This vulnerability is classified 
as high severity and can be solved by disabling dynamic method invocation when possible.
","I think this vulnerability is the result of a design mistake. This vulnerability
occurs when attackers execute a command that gives them a capability that they 
otherwise would not have. An attacker submits a malicious expression to the system,
and if successful, could execute arbitrary code through dynamic method invocation.
For this particular problem, disabling dynamic method invocation will solve the
problem. In general, a mitigation is to assume that all input is malicious and use 
an ""accept known good"" input strategy. Reject input that does not conform to specifications,
or modify it into something that does.
"
1860,CVE-2016-3082,struts,"The application allows for the parsing of arbitrary stylesheet when provided
with a path to the stylesheet. The implementation allowed this sheet location
to be included as a parameter to an HTTP request. Using the parameter from the 
request as the path to the resource allowed for potential remote code execution. 
","This vulnerability appears to be the result of a security oversight when
providing a way for an HTTP request to pass the location of a stylesheet.
This kind of issue can be mitigated in the future by validating the document
type and content of uploaded files. In this specific case, the ability to
pass the file location in the HTTP request was determined to be unnecessary.
As such, the code that blindly used the path provided in the location
parameter of the request was removed.
"
1861,CVE-2016-3087,struts,"Instead of writing an <action> for every method, a user could map the '*'
character with a method name with the same suffix or prefix. When this was
enabled it allowed remote attackers to execute arbitrary code via vectors
related to the '!' operator to the REST plugin.
","A mistake was made during implementation. The developer simply did not validate
that user input wasn't sequential. Because of this remote attackers were allowed
toexecute arbitrary code via vectors related to the '!' operatot in the REST plugin.
"
1862,CVE-2016-3090,struts,"This type of attack is specifically targeting the flexible nature of Expression
Languages to inject and execute arbitrary code on a system.  Expression Language
is a scripting like language that allows you to access java methods in a similar
way that you would normally, i.e. with the ""."" syntax.  Apache has made an
Expression Language that is mainly meant to access data within an object using
getters and setters called OGNL (Object Graph Navigation Language).  OGNL is
built off of a framework called ANTLR which is a parser that can help you create
simple languages.
The issue with OGNL and other such Expression Languages is that they are very
flexible and are prone to injection attacks.  The place these types of languages
are used most often is in templating languages like JSP. JSP allows you to use
OGNL to access internal object data that can be injected in the HTML created by
JSP.
Typically, this isn't an issue for injection attacks, becaues user input does
not affect the templating languages (or anything else using Expression Languages),
however it is possible for a developer to evaluate OGNL with some user provided
variables through string concatenation.  If this is done, the sanitization of the
input becomes very complicated and hard to determine what should actually be sanitized
because the precise sanitization depends on the project.
Although it is hard to find an example of the type of injection used in this vulerability,
it has to do with the underlying ANTLR framework.
OGNL is a very exploitable language if it is not used carefully, and it even played
into the equifax breach (CVE-2017-5638).
","This issue that is presented is mainly an issue due to adding more classes / sensitive
information in the future without remembering to update the list of sanitized inputs
for a method that access this information based on inputs.  This is overall, a design
mistake.  The list of sensitive data should not be updated separately and isntead should
be maintained when the senstive data is added.
A way to do this might be through the use of annotations, the list of sanitized data can
be automatically determined based off of annotated fields of the object being accessed.
This could be a great feature of OGNL, ignoring any fields (or getters/setters) that are
annotated with a certain annotation, then the issue of sanitization might not even be
an issue.  This may however not fix the issue since it is hard to know exactly what type
of input caused this vulnerability in the first place, this is just based off of the new
unit tests added in the fix.
"
1863,CVE-2016-3093,struts,,
1864,CVE-2016-4003,struts,,
1865,CVE-2016-4430,struts,"This vulnerability is a cross-site request forgery vulnerability which can allow attackers
to perform arbitrary code execution. The regular expression used to validate the URLS given by user input 
allowed multiple ""/"" characters to be present.
","The culprit was a character that was commonly used for xsrf that was not properly denied in the URL. 
This could have been lack of knowledge or a condition that the developer forgot about. The fix was proper as it limited the character to only be used in a certain way.
"
1866,CVE-2016-4431,struts,,
1867,CVE-2016-4433,struts,"A properly made request to Struts will allow an attacker to bypass permissions
and conduct a redirection attack.

A redirection attack is where the attacker can control where a page will
redirect the user to. It may for example redirect them to a fake login page
intended to harvest their username/password. The user is likely to trust this
fake page, given they just came from a trusted page.
","Looking at the fix I notice they're disallowing arithmetic expressions, so
perhaps plus symbols were being expanded to spaces later for example,
causing issues. Looking into the test added at the fix commit it expects a
method call of ""#booScope=@myclass@DEFAULT_SCOPE,#bootScope.init()"" to fail.

Given that this syntax appears to allow arbitrary method calls from a remote
source it seems like the use of it is a design flaw, as Apache will be
forever plugging holes in this system. Instead the app should be required to
define its input paths, instead of letting the client do whatever it wants.

The only real way I can think of to avoid this in the future is to not have
a feature like OGNL, instead just require the app to define its endpoints
like in a Spring app.
"
1868,CVE-2016-4436,struts,,
1869,CVE-2016-4438,struts,"An attacker can execute code in the application. It is possible by passing 
a malicious expression. If it didn't work a denial of service would ensue.
A malicious expression could be added by chaining the expression to another,
this means the code would try to execute one of the expressions but ends up
doing both.
","This is an input validation error. It is an input validation error because a user can
enter code to excute arbitraury code and failure with code can lead to a denial of service. This seems
to be a classic case of improper input validation because of the lack of input sanitization. The code 
did have input validation before but it didn't account for chained expressions. This could be avoided in
the future by testing a greater range of possible expressions.
"
1883,CVE-2017-9805,struts,"CVE-2017-9805 is a security vulnerability that could allow the execution of
arbitrary code when XML is read into the system. When the vulnerable module
received an XML payload, it does not properly validate it. This means that it
could receive a malicious payload that could execute arbitrary code.
","This vulnerability was mostly a design mistake. The developer
did not consider that the input could potentially be malicious and could be
dangerous when deserialized. As such, the XML handler did not properly
validate the input before the deserialization occurs, leading to the
potential execution of arbitrary code. The page for CWE-502 suggests
validating the input before creating a new object to store the deserialized
data. The fix for this vulnerability involved 1) upgrading the dependancy
used for XML deserializing but 2) creating a whitelist of allowed class
names. This whitelist validates that the input is trustworthy before
creating the object. If the class instance attempting to be created isn't
on that list of trusted class names, it is not created. It is interesting
how this vulnerability was found (a demonstration of a security service that
automatically queries open-source repositories for security vulnerabilities)
and that it was very quickly fixed. They also didn't annouce the
vulnerability before it was fixed, and there were no public bug reports or
anything to signify that it existed. They were also missing security tests
that could've prevented this vulnerability from occuring in the first place.
"
1884,CVE-2018-11776,struts,"This vulnerability allows remote code execution in the Apache Struts framework.
Attackers can inject their own namespace as a parameter in an HTTP request. The
attacker can inject any string that complied with Struts' Object-Graph
Navigation Language. Struts' OGNL language allows the behavior of Struts to be
highly customizable. Apache 2 versions before 2.3.35 and 2.5.17 were affected by
this vlnerbility.
","I believe the biggest lesson that can be learned from this vulnerability
is to take caution when merging outside code with your own. You should
distrust this code like you would distrust any other library or framework
you use. This means understanding how the framework/library works
very well and/or putting trust boundaries between the merged code and your own.
After discovering the vulnerability, I believe the the fix was done properly.
The fix properly sanitizes and validates the namespace which prevents any
injection from taking place.
"
1870,CVE-2016-4461,struts,"This vulnerability stems from improper input validation within Apache Struts
in relation to OGNL, more formally known as Object Graph Navigation Language.
OGNL is an expression language used to access and mutate Java Object properties,
as well as interact with other forms of metadata.
In this instance, OGNL's expression evaluation operator ""%{}"" can be used to force
double evaluation of a Struts data object attribute. Double evaluation is when an expression string is
evaluated as code such that its output is also evaluated as code. Without a defined base case, this
process can recurse indefinitely.
With respect to Apache Struts, a malicious actor can provide a string containing ""%{}"" that,
when evaluated at a later point in time, forces double evaluation. In the event a malicious actor
encodes program instructions within their provided string input, this vulnerability allows for
arbitrary code execution within the system.
It is important to note that this vulnerability stems from an incomplete solution to a prior issue
in Apache version 2.3.28, classified as S2-029 in Apache's wiki (CVE-2016-0785). 
","Overall, this vulnerability stems from failure to consider the security principle of ""secure by default"".
Failure to consider malicious use of the OGNL language, especially when forcing expression evaluations 
using ""%{}"" syntax, shows that adequate threat modeling was not done in preparation for integrating with this feature.
Likewise, failure to account for potential malicious inputs when executing expressions signifies a lack of
consideration for the increased attack surface that results from complex inputs.
Considering the predecessor issue ""S2-029"" was supposed to be fixed in the version 2.3.28 release, the
fact that the same issue re-appeared as ""S2-036"" proves a lack of understanding in regards to the core issue.
"
1871,CVE-2016-4465,struts,"In APACHE Struts 2, there is the potential for a denial of service attack due to
an unhandled exception. The vulnerability occurs in the built-in URL validator, 
when an attacker chooses to input a null value for the URL field, it will 
cause the server process to overload and crash due to the unhandled exception. 
","This was definitely a coding mistake. Whoever created the regular expression to attempt
to sanitize the input for URLs just forgot (or wasn't able) to check for all possible 
improper inputs. The CWE recommended mitigation for this vulnerability is to sanitize 
all incoming input strings so that they do not allow null bytes and/or null characters 
to get through. The trouble with this originally is due to the very complex nature of possible
valid URLs, meaning that creating a regular expression to check for all improper URLs is a 
fairly daunting task. To prevent this issue in similiar situations in the future, I would 
recommend to create a list of all blacklisted symbols, phrases, and/or possible malicious
inputs, then test each one against the created regex to verify it sanitizes the input correctly.
"
1872,CVE-2016-6795,struts,"The URL provided by the user was not fully validated which could cause the server to let an attacker go to locations 
not permitted to view and even inject code to execute remotely
","This looks like a coding mistake. Validating a valid secure URL is hard, but something as checking ../../.. should one of the first things the teams should have checked before upadating the validator. I can tell from one other commit that code is merged to master without being fully checked (commit can be found in interesting commits section)"
1873,CVE-2016-8738,struts,"This vulnerability may overload the server process with a specially crafted
URL. If a special URL is put in a form field and validated using Struts' built
in URLValidator, the validation may cause a DoS. The URL validation is done
using regular expressions. This vulnerability affects Struts versions 2.5 to
2.5.5. Checkout CVE-2017-9804 and CVE-2016-7672 for similar CVEs.
","I believe the biggest lesson you can learn from this vulnerability is make
sure your unit testing is complete. While complete coverage of every possible
input is impossible, testing should cover as much as possible. This is especially
the case when creating a fix. This vulnerability was not fixed completely and led
to CVE-2017-7672 and CVE-2017-9804. You should always create new tests to make the
fix was done correctly. Another lesson that can be learned is be careful with regex.
While regex can be exremely useful, make sure you know exactly what it does. This
can be difficult if it becomes long, like in the case of URLValidator.
"
1874,CVE-2017-12611,struts,"An RCE (remote code execution) attack is possible when developer is using wrong
construction in Freemarker tags. Freemarker is a template engine used to
generate HTML.
","This is a good example of how just because code is problematic, that
doesn't mean it is obvious. This code was implemented in 2006 but it didn't
show itself as problematic until 2017. This is a simple fix that could have
been implemented in 2006 when the class was developed. Just because it seems
small when you write it, that doesn't mean it can't become big later.
"
1875,CVE-2017-15707,struts,"Struts was using an outdated library in order to read and process JSON files.
As a result, a special type of JSON file could be created that could cause a
Denial of Service (DoS) attack. Since the library was outdated and no longer being supported, this
problem would never be resolved.
","The main mistake that was made was keeping around old, outdated libraries
and still using them, despite them not receiving any security updates. The
team began using this library in 2007 and didn't stop using it until it was
discovered that a user could cause a DOS attack.

The team seems to have taken the proper initiatve of replacing the old
library with a new one (Jackson), that is still being worked on and
receiving security updates. It did take some time for them to switch things
over to using Jackson though as can be seen in some later commits showing
them switching to Jackson up to two months after the initial switch was
made. It was also noted that instead of fully removing the ability to use
the outdated json-lib library, they instead leave it as an optional thing,
with Jackson acting as the defualt JSON reader. They seem to be making proper
steps towards preventing the vulnerability, but still have some work to do,
as there was no mention of removing json-lib as optional.

The team does have a good reason to keep json-lib though. There may be some 
applications that other teams have developed that use struts with json-lib.
"
1876,CVE-2017-5638,struts,"Apache Struts utilizes multipart parsers to handle HTTP POST requests, and there are 
two types available, Jakarta and Pell. The Jakarta Multiparser was the one that had 
the vulnerability, and it generates an exception when parsing the Content-Type. It 
raises this exception and includes the invalid data in the error message, and does 
this by parsing the input and treating the parsed result as an OGNL expression. 
This is potential for remote code execution.
","The coding mistake that lead to this vulnerability was introduced in one commit. The
mistake was introducing new code but not testing against it completely. The quick fix
was to update to a different version of Struts. The code fix was implemented only after 
being exploited by attackers.

The original author that pushed code intended to improve error handling, by introducing a
new class to store and handle the error, the unit tests were updated by did not test for 
potential remote code execution.
"
1877,CVE-2017-7525,struts,,
1878,CVE-2017-7672,struts,"This vulnerability may overload the server process with a specially crafted
URL. If a special URL is put in a form field and validated using Struts' built
in URLValidator, the validation may cause a DoS. The URL validation is done
using regular expressions. This vulnerability affects Struts versions 2.5 to
2.5.20.1. Checkout CVE-2017-9804 and CVE-2016-8738 for similar CVEs.
","I believe that this is a mistake in the design. The unit tests were not
designed well enough to cover some possibilities of DoS. See CVE-2016-8738
and CVE-2017-9804 for more information.
"
1879,CVE-2017-9787,struts,A specific type of proxy could be used to make many connections and launch denial of service attacks on Struts.,"I believe they just missed what looks like a simple check to prevent proxy connections. Rather than a coding mistake, it seems their design totally neglected handling proxies differently. You can't catch every vulnerability and this one must have slipped through risk assessment. CWE-284 mentions carefully handling permissions and trust boundaries, and it seems from this bug that a proxy user may need restricted access (or none at all) if DoS attacks are a significant risk."
1880,CVE-2017-9791,struts,"When using Struts' ActionMessage, the development team recommended to *not* use string concatenation to get a resource key. This is akin to OS Command Injection or SQL Injection where string concatenation leads to modifying the underlying instructions.
The vulnerability was never patched. The development team simply put out a bulletin, along with a code example, to educate their developers. So there is no fix, nor VCC.
From their website - *""It is possible to perform a RCE attack with a malicious field value when using the Struts 2 Struts 1 plugin and it's a Struts 1 action and the value is a part of a message presented to the user, i.e. when using untrusted input as a part of the error message in the ActionMessage class.""*",
1881,CVE-2017-9793,struts,"This vulnerability is located in the REST Plugin of Apache Struts, which provides
the ability to interface with other web applications. The REST Plugin is using an
outdated XStream library (provides serializing objects to XML) that is vulnerable
to DoS. The DoS is achieved through a crafted XML payload. This vulnerability affects
Apache Struts versions 2.3.7 to 2.3.33 and 2.5 to 2.5.12. See CVE-2018-1327 and CVE-2017-9805
for similar vulnerabilities.
","This vulnerability was exploited due to an outdated library dependency that the REST Plugin on this application utilizes. The ideal scenario to avoid this sort of vulnerability is to restrict the use of third party dependencies, this can be mitigated by either redesigning the architecture of the plugin or attempting to design an internal library that was thorougly tested before production. It is always important to be wary of third-party dependencies which are constantly targeted by attackers, especially for open source software like Struts. In addition, if trust boundaries were implemented where the application would validate input that affects critical system functions, and deny anything that is not trustful this type of vulnerability could have been avoided."
1882,CVE-2017-9804,struts,"This vulnerability is due to the uncomplete fix of CVE-2017-7672. A crafted
URL can overload the server process when validated using URLValidator. See
CVE-2017-7672 for more information. This vulnerability is also similar to
CVE-2016-8738. Apache Struts versions 2.3.7 to 2.3.33 and 2.5 to 2.5.12 are
affected.
","I believe the biggest lesson you can learn from this vulnerability is make
sure your unit testing is complete. While complete coverage of every possible
input is impossible, testing should cover as much as possible. Before the fix,
no unit tests covered potential cases for DoS. Another lesson that can be
learned is be careful with regex. While regex can be exremely powerful, make
sure you know exactly what it does. This can be difficult if it becomes too long,
like in the case of URLValidator.
"
